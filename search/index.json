[{"content":" # SpringBoot基础 # 课程内容 SpringBootWeb入门\nHTTP协议\nWeb服务器-Tomcat\n# 前言 下面我们将进入SpringBoot基础阶段的学习。\n在没有正式的学习SpringBoot之前，我们要先来了解下什么是Spring。\n我们可以打开Spring的官网(https://spring.io)，去看一下Spring的简介：Spring makes Java simple。\nSpring的官方提供很多开源的项目，我们可以点击上面的projects，看到spring家族旗下的项目，按照流行程度排序为：\nSpring发展到今天已经形成了一种开发生态圈，Spring提供了若干个子项目，每个项目用于完成特定的功能。而我们在项目开发时，一般会偏向于选择这一套spring家族的技术，来解决对应领域的问题，那我们称这一套技术为spring全家桶。\n而Spring家族旗下这么多的技术，最基础、最核心的是 SpringFramework。其他的spring家族的技术，都是基于SpringFramework的，SpringFramework中提供很多实用功能，如：依赖注入、事务管理、web开发支持、数据访问、消息服务等等。\n而如果我们在项目中，直接基于SpringFramework进行开发，存在两个问题：配置繁琐、入门难度大。\n所以基于此呢，spring官方推荐我们从另外一个项目开始学习，那就是目前最火爆的SpringBoot。\n通过springboot就可以快速的帮我们构建应用程序，所以springboot呢，最大的特点有两个 ：\n简化配置 快速开发 Spring Boot 可以帮助我们非常快速的构建应用程序、简化开发、提高效率 。\n接下来，我们就直接通过一个SpringBoot的web入门程序，让大家快速感受一下，基于SpringBoot进行Web开发的便捷性。\n# 1. SpringBootWeb快速入门 # 1.1 需求 需求：基于SpringBoot的方式开发一个web应用，浏览器发起请求/hello后，给浏览器返回字符串 “Hello World ~”。\n# 1.2 开发步骤 第1步：创建SpringBoot工程项目\n第2步：定义HelloController类，添加方法hello，并添加注解\n第3步：测试运行\n# 1.2.1 创建SpringBoot工程（需要联网） 基于Spring官方骨架，创建SpringBoot工程。\n基本信息描述完毕之后，勾选web开发相关依赖。\n点击Finish之后，就会联网创建这个SpringBoot工程，创建好之后，结构如下：\n==注意：在联网创建过程中，会下载相关资源(请耐心等待)== # 1.2.2 定义请求处理类 在com.itheima这个包下创建一个子包controller\n然后在controller包下新建一个类：HelloController\n1 2 3 4 5 6 7 8 9 10 11 12 13 package com.itheima.controller; import org.springframework.web.bind.annotation.*; @RestController public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello(){ System.out.println(\u0026#34;Hello World ~\u0026#34;); return \u0026#34;Hello World ~\u0026#34;; } } # 1.2.3 运行测试 运行SpringBoot自动生成的引导类\n打开浏览器，输入 http://localhost:8080/hello\n# 1.3 Web分析 浏览器：\n输入网址：http://192.168.100.11:8080/hello\n通过IP地址192.168.100.11定位到网络上的一台计算机\n我们之前在浏览器中输入的localhost，就是127.0.0.1（本机）\n通过端口号8080找到计算机上运行的程序\nlocalhost:8080 , 意思是在本地计算机中找到正在运行的8080端口的程序\n/hello是请求资源位置\n资源：对计算机而言资源就是数据 web资源：通过网络可以访问到的资源（通常是指存放在服务器上的数据） localhost:8080/hello ，意思是向本地计算机中的8080端口程序，获取资源位置是/hello的数据\n8080端口程序，在服务器找/hello位置的资源数据，发给浏览器 服务器：（可以理解为ServerSocket）\n接收到浏览器发送的信息（如：/hello） 在服务器上找到/hello的资源 把资源发送给浏览器 我们在JavaSE阶段学习网络编程时，有讲过网络三要素：\nIP ：网络中计算机的唯一标识 端口 ：计算机中运行程序的唯一标识 协议 ：网络中计算机之间交互的规则 问题：浏览器和服务器两端进行数据交互，使用什么协议？\n答案：http协议\n# 2. HTTP协议 # 2.1 HTTP-概述 # 2.1.1 介绍 HTTP：Hyper Text Transfer Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。\nhttp是互联网上应用最为广泛的一种网络协议 http协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输 如果想知道http协议的数据传输格式有哪些，可以打开浏览器，点击F12打开开发者工具，点击Network来查看\n浏览器向服务器进行请求时：\n服务器按照固定的格式进行解析 服务器向浏览器进行响应时：\n浏览器按照固定的格式进行解析 所以，我们学习HTTP主要就是学习请求和响应数据的具体格式内容。\n# 2.2.2 特点 我们刚才初步认识了HTTP协议，那么我们在看看HTTP协议有哪些特点：\n**基于TCP协议: ** 面向连接，安全\nTCP是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全\n基于请求-响应模型: 一次请求对应一次响应（先请求后响应）\n请求和响应是一一对应关系，没有请求，就没有响应\nHTTP协议是无状态协议: 对于数据没有记忆能力。每次请求-响应都是独立的\n无状态指的是客户端发送HTTP请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。\n缺点: 多次请求间不能共享数据 优点: 速度快 请求之间无法共享数据会引发的问题：\n如：京东购物。加入购物车和去购物车结算是两次请求 由于HTTP协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品 发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据 具体使用的时候，我们发现京东是可以正常展示数据的，原因是Java早已考虑到这个问题，并提出了使用会话技术(Cookie、Session)来解决这个问题。具体如何来做，我们后面课程中会讲到。\n刚才提到HTTP协议是规定了请求和响应数据的格式，那具体的格式是什么呢?\n# 2.2 HTTP-请求协议 浏览器和服务器是按照HTTP协议进行数据通信的。\nHTTP协议又分为：请求协议和响应协议\n请求协议：浏览器将数据以请求格式发送到服务器 包括：请求行、请求头 、请求体 响应协议：服务器将数据以响应格式返回给浏览器 包括：响应行 、响应头 、响应体 在HTTP1.1版本中，浏览器访问服务器的几种方式：\n请求方式 请求说明 GET 获取资源。向特定的资源发出请求。例：http://www.baidu.com/s?wd=itheima POST 传输实体主体。向指定资源提交数据进行处理请求（例：上传文件），数据被包含在请求体中。 OPTIONS 返回服务器针对特定资源所支持的HTTP请求方式。因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法，例如：DELETE、PUT等。那么OPTIONS就是用来询问服务器支持的方法。 HEAD 获得报文首部。HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据。通常用于确认URI的有效性及资源更新时间等。 PUT 传输文件。PUT方法用来传输文件。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。 DELETE 删除文件。请求服务器删除Request-URI所标识的资源 TRACE 追踪路径。回显服务器收到的请求，主要用于测试或诊断 CONNECT 要求用隧道协议连接代理。HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器 在我们实际应用中常用的也就是 ：GET、POST\nGET方式的请求协议：\n请求行 ：HTTP请求中的第一行数据。由：请求方式、资源路径、协议/版本组成（之间使用空格分隔）\n请求方式：GET 资源路径：/brand/findAll?name=OPPO\u0026amp;status=1 请求路径：/brand/findAll 请求参数：name=OPPO\u0026amp;status=1 请求参数是以key=value形式出现 多个请求参数之间使用\u0026amp;连接 请求路径和请求参数之间使用?连接 协议/版本：HTTP/1.1 请求头 ：第二行开始，上图黄色部分内容就是请求头。格式为key: value形式\nhttp是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式。这样服务器在收到信息后，就可以知道是谁，想干什么了 常见的HTTP请求头有:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Host: 表示请求的主机名 User-Agent: 浏览器版本。 例如：Chrome浏览器的标识类似Mozilla/5.0 ...Chrome/79 ，IE浏览器的标识类似Mozilla/5.0 (Windows NT ...)like Gecko Accept：表示浏览器能接收的资源类型，如text/*，image/*或者*/*表示所有； Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页； Accept-Encoding：表示浏览器可以支持的压缩类型，例如gzip, deflate等。 Content-Type：请求主体的数据类型 Content-Length：数据主体的大小（单位：字节） 举例说明：服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求。\n比如:\n不同浏览器解析HTML和CSS标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果 服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果（这就是我们常说的浏览器兼容问题） 请求体 ：存储请求参数 GET请求的请求参数在请求行中，故不需要设置请求体 POST方式的请求协议：\n请求行(以上图中红色部分)：包含请求方式、资源路径、协议/版本 请求方式：POST 资源路径：/brand 协议/版本：HTTP/1.1 请求头(以上图中黄色部分) 请求体(以上图中绿色部分) ：存储请求参数 请求体和请求头之间是有一个空行隔开（作用：用于标记请求头结束） GET请求和POST请求的区别：\n区别方式 GET请求 POST请求 请求参数 请求参数在请求行中。例：/brand/findAll?name=OPPO\u0026amp;status=1 请求参数在请求体中 请求参数长度 请求参数长度有限制(浏览器不同限制也不同) 请求参数长度没有限制 安全性 安全性低。原因：请求参数暴露在浏览器地址栏中。 安全性相对高 # 2.3 HTTP-响应协议 # 2.3.1 格式介绍 与HTTP的请求一样，HTTP响应的数据也分为3部分：响应行、响应头 、响应体\n响应行(以上图中红色部分)：响应数据的第一行。响应行由协议及版本、响应状态码、状态码描述组成\n协议/版本：HTTP/1.1 响应状态码：200 状态码描述：OK 响应头(以上图中黄色部分)：响应数据的第二行开始。格式为key：value形式\nhttp是个无状态的协议，所以可以在请求头和响应头中设置一些信息和想要执行的动作，这样，对方在收到信息后，就可以知道你是谁，你想干什么 常见的HTTP响应头有:\n1 2 3 4 5 6 7 8 9 Content-Type：表示该响应内容的类型，例如text/html，image/jpeg ； Content-Length：表示该响应内容的长度（字节数）； Content-Encoding：表示该响应压缩算法，例如gzip ； Cache-Control：指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒 ; Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie ; 响应体(以上图中绿色部分)： 响应数据的最后一部分。存储响应的数据 响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束） # 2.3.2 响应状态码 状态码分类 说明 1xx 响应中 \u0026mdash; 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略 2xx 成功 \u0026mdash; 表示请求已经被成功接收，处理已完成 3xx 重定向 \u0026mdash; 重定向到其它地方，让客户端再发起一个请求以完成整个处理 4xx 客户端错误 \u0026mdash; 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx 服务器端错误 \u0026mdash; 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 参考: 资料/SpringbootWeb/响应状态码.md\n关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握：\n200 ok 客户端请求成功 404 Not Found 请求资源不存在 500 Internal Server Error 服务端发生不可预期的错误 # 2.4 HTTP-协议解析 将资料中准备好的Demo工程，导入到我们的IDEA中，有一个Server.java类，这里面就是自定义的一个服务器代码，主要使用到的是ServerSocket和Socket\n==说明：以下代码大家不需要自己写，我们主要是通过代码，让大家了解到服务器针对HTTP协议的解析机制==\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 package com.itheima; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.nio.charset.StandardCharsets; /* * 自定义web服务器 */ public class Server { public static void main(String[] args) throws IOException { ServerSocket ss = new ServerSocket(8080); // 监听指定端口 System.out.println(\u0026#34;server is running...\u0026#34;); while (true){ Socket sock = ss.accept(); System.out.println(\u0026#34;connected from \u0026#34; + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); } } } class Handler extends Thread { Socket sock; public Handler(Socket sock) { this.sock = sock; } public void run() { try (InputStream input = this.sock.getInputStream(); OutputStream output = this.sock.getOutputStream()) { handle(input, output); } catch (Exception e) { try { this.sock.close(); } catch (IOException ioe) { } System.out.println(\u0026#34;client disconnected.\u0026#34;); } } private void handle(InputStream input, OutputStream output) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); // 读取HTTP请求: boolean requestOk = false; String first = reader.readLine(); if (first.startsWith(\u0026#34;GET / HTTP/1.\u0026#34;)) { requestOk = true; } for (;;) { String header = reader.readLine(); if (header.isEmpty()) { // 读取到空行时, HTTP Header读取完毕 break; } System.out.println(header); } System.out.println(requestOk ? \u0026#34;Response OK\u0026#34; : \u0026#34;Response Error\u0026#34;); if (!requestOk) {// 发送错误响应: writer.write(\u0026#34;HTTP/1.0 404 Not Found\\r\\n\u0026#34;); writer.write(\u0026#34;Content-Length: 0\\r\\n\u0026#34;); writer.write(\u0026#34;\\r\\n\u0026#34;); writer.flush(); } else {// 发送成功响应: //读取html文件，转换为字符串 InputStream is = Server.class.getClassLoader().getResourceAsStream(\u0026#34;html/a.html\u0026#34;); BufferedReader br = new BufferedReader(new InputStreamReader(is)); StringBuilder data = new StringBuilder(); String line = null; while ((line = br.readLine()) != null){ data.append(line); } br.close(); int length = data.toString().getBytes(StandardCharsets.UTF_8).length; writer.write(\u0026#34;HTTP/1.1 200 OK\\r\\n\u0026#34;); writer.write(\u0026#34;Connection: keep-alive\\r\\n\u0026#34;); writer.write(\u0026#34;Content-Type: text/html\\r\\n\u0026#34;); writer.write(\u0026#34;Content-Length: \u0026#34; + length + \u0026#34;\\r\\n\u0026#34;); writer.write(\u0026#34;\\r\\n\u0026#34;); // 空行标识Header和Body的分隔 writer.write(data.toString()); writer.flush(); } } } 启动ServerSocket程序：\n浏览器输入：http://localhost:8080 就会访问到ServerSocket程序\nServerSocket程序，会读取服务器上html/a.html文件，并把文件数据发送给浏览器 浏览器接收到a.html文件中的数据后进行解析，显示以下内容 现在大家知道了服务器是可以使用java完成编写，是可以接受页面发送的请求和响应数据给前端浏览器的，而在开发中真正用到的Web服务器，我们不会自己写的，都是使用目前比较流行的web服务器。如：Tomcat\n# 3. WEB服务器-Tomcat # 3.1 简介 # 3.1.1 服务器概述 服务器硬件\n指的也是计算机，只不过服务器要比我们日常使用的计算机大很多。 服务器，也称伺服器。是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。\n服务器的构成包括处理器、硬盘、内存、系统总线等，和通用的计算机架构类似，但是由于需要提供高可靠的服务，因此在处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要求较高。\n在网络环境下，根据服务器提供的服务类型不同，可分为：文件服务器，数据库服务器，应用程序服务器，WEB服务器等。\n服务器只是一台设备，必须安装服务器软件才能提供相应的服务。\n服务器软件\n服务器软件：基于ServerSocket编写的程序\n服务器软件本质是一个运行在服务器设备上的应用程序 能够接收客户端请求，并根据请求给客户端响应数据 # 3.1.2 Web服务器 Web服务器是一个应用程序(软件)，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作(不用程序员自己写代码去解析http协议规则)，让Web开发更加便捷。主要功能是\u0026quot;提供网上信息浏览服务\u0026quot;。\nWeb服务器是安装在服务器端的一款软件，将来我们把自己写的Web项目部署到Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。\nWeb服务器软件使用步骤\n准备静态资源 下载安装Web服务器软件 将静态资源部署到Web服务器上 启动Web服务器使用浏览器访问对应的资源 第1步：准备静态资源\n在提供的资料中找到静态资源文件 第2步：下载安装Web服务器软件\n第3步：将静态资源部署到Web服务器上\n第4步：启动Web服务器使用浏览器访问对应的资源\n浏览器输入：http://localhost:8080/demo/index.html\n上述内容在演示的时候，使用的是Apache下的Tomcat软件，至于Tomcat软件如何使用，后面会详细的讲到。而对于Web服务器来说，实现的方案有很多，Tomcat只是其中的一种，而除了Tomcat以外，还有很多优秀的Web服务器，比如:\nTomcat就是一款软件，我们主要是以学习如何去使用为主。具体我们会从以下这些方向去学习:\n简介：初步认识下Tomcat\n基本使用: 安装、卸载、启动、关闭、配置和项目部署，这些都是对Tomcat的基本操作\nIDEA中如何创建Maven Web项目\nIDEA中如何使用Tomcat,后面这两个都是我们以后开发经常会用到的方式\n首选我们来认识下Tomcat。\n# 3.1.3 Tomcat Tomcat服务器软件是一个免费的开源的web应用服务器。是Apache软件基金会的一个核心项目。由Apache，Sun和其他一些公司及个人共同开发而成。\n由于Tomcat只支持Servlet/JSP少量JavaEE规范，所以是一个开源免费的轻量级Web服务器。\nJavaEE规范： JavaEE =\u0026gt; Java Enterprise Edition(Java企业版)\nJavaEE规范就是指Java企业级开发的技术规范总和。包含13项技术规范：JDBC、JNDI、EJB、RMI、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAF\n因为Tomcat支持Servlet/JSP规范，所以Tomcat也被称为Web容器、Servlet容器。JavaWeb程序需要依赖Tomcat才能运行。\nTomcat的官网: https://tomcat.apache.org/\n# 3.2 基本使用 # 3.2.1 下载 直接从官方网站下载：https://tomcat.apache.org/download-90.cgi\nTomcat软件类型说明：\ntar.gz文件，是linux和mac操作系统下的压缩版本 zip文件，是window操作系统下压缩版本（我们选择zip文件） 大家可以自行下载，也可以直接使用资料中已经下载好的资源，\nTomcat的软件程序 ：/资料/SpringbootWeb/apache-tomcat-9.0.27-windows-x64.zip\n# 3.2.2 安装与卸载 安装: Tomcat是绿色版，直接解压即安装\n在E盘的develop目录下，将apache-tomcat-9.0.27-windows-x64.zip进行解压缩，会得到一个apache-tomcat-9.0.27的目录，Tomcat就已经安装成功。\n==注意，Tomcat在解压缩的时候，解压所在的目录可以任意，但最好解压到一个不包含中文和空格的目录，因为后期在部署项目的时候，如果路径有中文或者空格可能会导致程序部署失败。==\n打开apache-tomcat-9.0.27目录就能看到如下目录结构，每个目录中包含的内容需要认识下\nbin：目录下有两类文件，一种是以.bat结尾的，是Windows系统的可执行文件，一种是以.sh结尾的，是Linux系统的可执行文件。\nwebapps：就是以后项目部署的目录\n**卸载：**卸载比较简单，可以直接删除目录即可\n# 3.2.3 启动与关闭 启动Tomcat\n双击tomcat解压目录/bin/startup.bat文件即可启动tomcat ==注意: tomcat服务器启动后,黑窗口不会关闭,只要黑窗口不关闭,就证明tomcat服务器正在运行==\nTomcat的默认端口为8080，所以在浏览器的地址栏输入：http://127.0.0.1:8080 即可访问tomcat服务器\n127.0.0.1 也可以使用localhost代替。如：http://localhost:8080\n能看到以上图片中Apache Tomcat的内容就说明Tomcat已经启动成功 ==注意事项== ：Tomcat启动的过程中，遇到控制台有中文乱码时，可以通常修改conf/logging.prooperties文件解决\n关闭: 关闭有三种方式\n1、强制关闭：直接x掉Tomcat窗口（不建议）\n2、正常关闭：bin\\shutdown.bat\n3、正常关闭：在Tomcat启动窗口中按下 Ctrl+C\n说明：如果按下Ctrl+C没有反映，可以多按几次 # 3.2.4 常见问题 问题1：Tomcat启动时，窗口一闪而过\n检查JAVA_HOME环境变量是否正确配置 问题2：端口号冲突\n发生问题的原因：Tomcat使用的端口被占用了。\n解决方案：换Tomcat端口号\n要想修改Tomcat启动的端口号，需要修改 conf/server.xml文件 注: HTTP协议默认端口号为80，如果将Tomcat端口号改为80，则将来访问Tomcat时，将不用输入端口号。\n# 3.3 入门程序解析 关于web开发的基础知识，我们可以告一段落了。下面呢，我们在基于今天的核心技术点SpringBoot快速入门案例进行分析。\n# 3.3.1 Spring官方骨架 之前我们创建的SpringBoot入门案例，是基于Spring官方提供的骨架实现的。\nSpring官方骨架，可以理解为Spring官方为程序员提供一个搭建项目的模板。\n我们可以通过访问：https://start.spring.io/ ，进入到官方骨架页面\nSpring官方生成的SpringBoot项目，怎么使用呢？\n解压缩后，就会得到一个SpringBoot项目工程 打开pom.xml文件，我们可以看到springboot项目中引入了web依赖和test依赖\n结论：不论使用IDEA创建SpringBoot项目，还是直接在官方网站利用骨架生成SpringBoot项目，项目的结构和pom.xml文件中内容是相似的。\n# 3.3.2 起步依赖 在我们之前讲解的SpringBoot快速入门案例中，同样也引用了：web依赖和test依赖\nspring-boot-starter-web和spring-boot-starter-test，在SpringBoot中又称为：起步依赖\n而在SpringBoot的项目中，有很多的起步依赖，他们有一个共同的特征：就是以spring-boot-starter-作为开头。在以后大家遇到spring-boot-starter-xxx这类的依赖，都为起步依赖。\n起步依赖有什么特殊之处呢，这里我们以入门案例中引入的起步依赖做为讲解：\nspring-boot-starter-web：包含了web应用开发所需要的常见依赖 spring-boot-starter-test：包含了单元测试所需要的常见依赖 spring-boot-starter-web内部把关于Web开发所有的依赖都已经导入并且指定了版本，只需引入 spring-boot-starter-web 依赖就可以实现Web开发的需要的功能\nSpring的官方提供了很多现成的starter(起步依赖)，我们在开发相关应用时，只需要引入对应的starter即可。\n官方地址：https://docs.spring.io/spring-boot/docs/2.7.2/reference/htmlsingle/#using.build-systems.starters\n每一个起步依赖，都用于开发一个特定的功能。\n举例：当我们开发中需要使用redis数据库时，只需要在SpringBoot项目中，引入：spring-boot-starter-redis ，即可导入redis开发所需要的依赖。\n# 3.3.2 SpringBoot父工程 在我们之前开发的SpringBoot入门案例中，我们通过maven引入的依赖，是没有指定具体的依赖版本号的。\n为什么没有指定版本号，可以正常使用呢？\n因为每一个SpringBoot工程，都有一个父工程。依赖的版本号，在父工程中统一管理。 # 3.3.3 内嵌Tomcat 问题：为什么我们之前书写的SpringBoot入门程序中，并没有把程序部署到Tomcat的webapps目录下，也可以运行呢？\n原因呢，是因为在我们的SpringBoot中，引入了web运行环境(也就是引入spring-boot-starter-web起步依赖)，其内部已经集成了内置的Tomcat服务器。\n我们可以通过IDEA开发工具右侧的maven面板中，就可以看到当前工程引入的依赖。其中已经将Tomcat的相关依赖传递下来了，也就是说在SpringBoot中可以直接使用Tomcat服务器。\n当我们运行SpringBoot的引导类时(运行main方法)，就会看到命令行输出的日志，其中占用8080端口的就是Tomcat。\n","date":"2024-04-29T11:39:09+08:00","permalink":"http://localhost:1313/p/%E5%88%9D%E8%AF%86springboot/","title":"初识springboot"},{"content":" # Maven # 1.1 课程安排 学习完前端Web开发技术后，我们即将开始学习后端Web开发技术。做为一名Java开发工程师，后端Web开发技术是我们学习的重点。\n后端Web开发技术的学习，我们会先学习Java项目的构建工具：Maven\n# 1.2 初识Maven # 1.2.1 什么是Maven Maven是Apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。\n官网：https://maven.apache.org/\nApache 软件基金会，成立于1999年7月，是目前世界上最大的最受欢迎的开源软件基金会，也是一个专门为支持开源项目而生的非盈利性组织。\n开源项目：https://www.apache.org/index.html#projects-list\n# 1.2.2 Maven的作用 使用Maven能够做什么呢？\n依赖管理 统一项目结构 项目构建 依赖管理：\n方便快捷的管理项目依赖的资源(jar包)，避免版本冲突问题 当使用maven进行项目依赖(jar包)管理，则很方便的可以解决这个问题。 我们只需要在maven项目的pom.xml文件中，添加一段如下图所示的配置即可实现。\n**统一项目结构 : **\n提供标准、统一的项目结构 在项目开发中，当你使用不同的开发工具 (如：Eclipse、Idea)，创建项目工程时：\n若我们创建的是一个maven工程，是可以帮我们自动生成统一、标准的项目目录结构：\n具体的统一结构如下：\n目录说明：\nsrc/main/java: java源代码目录 src/main/resources: 配置文件信息 src/test/java: 测试代码 src/test/resources: 测试配置文件信息 项目构建 :\nmaven提供了标准的、跨平台(Linux、Windows、MacOS) 的自动化项目构建方式 如上图所示我们开发了一套系统，代码需要进行编译、测试、打包、发布，这些操作如果需要反复进行就显得特别麻烦，而Maven提供了一套简单的命令来完成项目构建。\n综上所述，可以得到一个结论：Maven是一款管理和构建java项目的工具\n# 02. Maven概述 # 2.1 Maven介绍 Apache Maven是一个项目管理和构建工具，它基于项目对象模型(Project Object Model , 简称: POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档。\n官网：https://maven.apache.org/\nMaven的作用：\n方便的依赖管理 统一的项目结构 标准的项目构建流程 # 2.2 Maven模型 项目对象模型 (Project Object Model) 依赖管理模型(Dependency) 构建生命周期/阶段(Build lifecycle \u0026amp; phases) 1). 构建生命周期/阶段(Build lifecycle \u0026amp; phases)\n以上图中紫色框起来的部分，就是用来完成标准化构建流程 。当我们需要编译，Maven提供了一个编译插件供我们使用；当我们需要打包，Maven就提供了一个打包插件供我们使用等。\n2). 项目对象模型 (Project Object Model)\n以上图中紫色框起来的部分属于项目对象模型，就是将我们自己的项目抽象成一个对象模型，有自己专属的坐标，如下图所示是一个Maven项目：\n坐标，就是资源(jar包)的唯一标识，通过坐标可以定位到所需资源(jar包)位置\n3). 依赖管理模型(Dependency)\n以上图中紫色框起来的部分属于依赖管理模型，是使用坐标来描述当前项目依赖哪些第三方jar包。groupId表示组织名（域名+公司/组织+项目/模块名）、artifactId表示项目/模块名\n之前我们项目中需要jar包时，直接就把jar包复制到项目下的lib目录，而现在书写在pom.xml文件中的坐标又是怎么能找到所要的jar包文件的呢？\n答案：Maven仓库\n# 2.3 Maven仓库 仓库：用于存储资源，管理各种jar包\n仓库的本质就是一个目录(文件夹)，这个目录被用来存储开发中所有依赖(就是jar包)和插件\nMaven仓库分为：\n本地仓库：自己计算机上的一个目录(用来存储jar包) 中央仓库：由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/ 远程仓库(私服)：一般由公司团队搭建的私有仓库 当项目中使用坐标引入对应依赖jar包后，首先会查找本地仓库中是否有对应的jar包\n如果有，则在项目直接引用\n如果没有，则去中央仓库中下载对应的jar包到本地仓库\n如果还可以搭建远程仓库(私服)，将来jar包的查找顺序则变为： 本地仓库 \u0026ndash;\u0026gt; 远程仓库\u0026ndash;\u0026gt; 中央仓库\n# 2.4 Maven安装 认识了Maven后，我们就要开始使用Maven了，那么首先我们要进行Maven的下载与安装。\n# 2.4.1 下载 下载地址：https://maven.apache.org/download.cgi\n在提供的资料中，已经提供了下载好的安装包。如下：\n# 2.4.2 安装步骤 Maven安装配置步骤：\n解压安装 配置仓库 配置Maven环境变量 1、解压 apache-maven-3.6.1-bin.zip（解压即安装）\n建议解压到没有中文、特殊字符的路径下。如课程中解压到 E:\\develop 下。\n解压缩后的目录结构如下：\nbin目录 ： 存放的是可执行命令。（mvn 命令重点关注） conf目录 ：存放Maven的配置文件。（settings.xml配置文件后期需要修改） lib目录 ：存放Maven依赖的jar包。（Maven也是使用java开发的，所以它也依赖其他的jar包） 2、配置本地仓库\n2.1、在自己计算机上新一个目录（本地仓库，用来存储jar包）\n2.2、进入到conf目录下修改settings.xml配置文件\n1). 使用超级记事本软件，打开settings.xml文件，定位到53行\n2). 复制标签，粘贴到注释的外面（55行）\n3). 复制之前新建的用来存储jar包的路径，替换掉标签体内容\n3、配置阿里云私服\n由于中央仓库在国外，所以下载jar包速度可能比较慢，而阿里公司提供了一个远程仓库，里面基本也都有开源项目的jar包。\n进入到conf目录下修改settings.xml配置文件：\n1). 使用超级记事本软件，打开settings.xml文件，定位到160行左右\n2). 在标签下为其添加子标签，内容如下：\n1 2 3 4 5 6 \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; 注意配置的位置，在 \u0026hellip; 中间添加配置。如下图所示：\n==注: 只可配置一个(另一个要注释!) ，不然两个可能发生冲突，导致jar包无法下载!!!!!!!==\n4、配置maven中的JDK版本\n由于maven项目中配置的JDK如果与安装的JDK版本不一致会报错（java:不支持发行版本 5），可以通过在配置文件C:\\develop\\apache-maven-3.6.1\\conf\\settings.xml中的 标签中添加子标签，这样就不用看下面的在idea中修改配置了，内容如下（JDK17）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-17\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;jdk\u0026gt;17\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;17\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; 5、配置环境变量\nMaven环境变量的配置类似于JDK环境变量配置一样\n1). 在系统变量处新建一个变量MAVEN_HOME\nMAVEN_HOME环境变量的值，设置为maven的解压安装目录 2). 在Path中进行配置\nPATH环境变量的值，设置为：%MAVEN_HOME%\\bin 3). 打开DOS命令提示符进行验证，出现如图所示表示安装成功\n1 mvn -v # 03. IDEA集成Maven 我们要想在IDEA中使用Maven进行项目构建，就需要在IDEA中集成Maven\n# 3.1 配置Maven环境 # 3.1.1 当前工程设置 1、选择 IDEA中 File =\u0026gt; Settings =\u0026gt; Build,Execution,Deployment =\u0026gt; Build Tools =\u0026gt; Maven\n2、设置IDEA使用本地安装的Maven，并修改配置文件及本地仓库路径\nMaven home path ：指定当前Maven的安装目录\nUser settings file ：指定当前Maven的settings.xml配置文件的存放路径\nLocal repository ：指定Maven的本地仓库的路径 (如果指定了settings.xml, 这个目录会自动读取出来, 可以不用手动指定)\n3、配置工程的编译版本为11\nMaven默认使用的编译版本为5（版本过低） 上述配置的maven环境，只是针对于当前工程的，如果我们再创建一个project，又恢复成默认的配置了。 要解决这个问题， 我们就需要配置全局的maven环境。\n# 3.1.2 全局设置 1、进入到IDEA欢迎页面\n选择 IDEA中 File =\u0026gt; close project 2、打开 All settings , 选择 Build,Execution,Deployment =\u0026gt; Build Tools =\u0026gt; Maven\n3、配置工程的编译版本为11\n这里所设置的maven的环境信息，并未指定任何一个project，此时设置的信息就属于全局配置信息。 以后，我们再创建project，默认就是使用我们全局配置的信息。\n# 3.2 Maven项目 # 3.2.1 创建Maven项目 1、创建一个空项目\n2、创建模块，选择Maven，点击Next\n3、填写模块名称，坐标信息，点击finish，创建完成\n4、在Maven工程下，创建HelloWorld类\nMaven项目的目录结构:\nmaven-project01 |\u0026mdash; src (源代码目录和测试代码目录) |\u0026mdash; main (源代码目录) |\u0026mdash; java (源代码java文件目录) |\u0026mdash; resources (源代码配置文件目录) |\u0026mdash; test (测试代码目录) |\u0026mdash; java (测试代码java目录) |\u0026mdash; resources (测试代码配置文件目录) |\u0026mdash; target (编译、打包生成文件存放目录)\n5、编写 HelloWorld，并运行\n1 2 3 4 5 public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello Maven ...\u0026#34;); } } # 3.2.2 POM配置详解 POM (Project Object Model) ：指的是项目对象模型，用来描述当前的maven项目。\n使用pom.xml文件来实现 pom.xml文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;!-- POM模型版本 --\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 当前项目坐标 --\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven_project1\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 打包方式 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;/project\u0026gt; pom文件详解：\n：pom文件的根标签，表示当前maven项目 ：声明项目描述遵循哪一个POM模型版本 虽然模型本身的版本很少改变，但它仍然是必不可少的。目前POM模型版本是4.0.0 坐标 ：、、 定位项目在本地仓库中的位置，由以上三个标签组成一个坐标 ：maven项目的打包方式，通常设置为jar或war（默认值：jar） # 3.2.3 Maven坐标详解 什么是坐标？\nMaven中的坐标是==资源的唯一标识== , 通过该坐标可以唯一定位资源位置 使用坐标来定义项目或引入项目中需要的依赖 Maven坐标主要组成\ngroupId：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service） version：定义当前项目版本号 如下图就是使用坐标表示一个项目：\n注意：\n上面所说的资源可以是插件、依赖、当前项目。 我们的项目如果被其他的项目依赖时，也是需要坐标来引入的。 # 3.3 导入Maven项目 方式1：使用Maven面板，快速导入项目 打开IDEA，选择右侧Maven面板，点击 + 号，选中对应项目的pom.xml文件，双击即可\n说明：如果没有Maven面板，选择 View =\u0026gt; Appearance =\u0026gt; Tool Window Bars\n方式2：使用idea导入模块项目 File =\u0026gt; Project Structure =\u0026gt; Modules =\u0026gt; + =\u0026gt; Import Module\n找到要导入工程的pom.xml\n# 04. 依赖管理 # 4.1 依赖配置 依赖：指当前项目运行所需要的jar包。一个项目中可以引入多个依赖：\n例如：在当前工程中，我们需要用到logback来记录日志，此时就可以在maven工程的pom.xml文件中，引入logback的依赖。具体步骤如下：\n在pom.xml中编写标签\n在标签中使用引入坐标\n定义坐标的 groupId、artifactId、version\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;dependencies\u0026gt; \u0026lt;!-- 第1个依赖 : logback --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.11\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 第2个依赖 : junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 点击刷新按钮，引入最新加入的坐标 刷新依赖：保证每一次引入新的依赖，或者修改现有的依赖配置，都可以加入最新的坐标 注意事项：\n如果引入的依赖，在本地仓库中不存在，将会连接远程仓库 / 中央仓库，然后下载依赖（这个过程会比较耗时，耐心等待） 如果不知道依赖的坐标信息，可以到mvn的中央仓库（https://mvnrepository.com/）中搜索 添加依赖的几种方式：\n利用中央仓库搜索的依赖坐标\n利用IDEA工具搜索依赖\n熟练上手maven后，快速导入依赖\n# 4.2 依赖传递 # 4.2.1 依赖具有传递性 早期我们没有使用maven时，向项目中添加依赖的jar包，需要把所有的jar包都复制到项目工程下。如下图所示，需要logback-classic时，由于logback-classic又依赖了logback-core和slf4j，所以必须把这3个jar包全部复制到项目工程下\n我们现在使用了maven，当项目中需要使用logback-classic时，只需要在pom.xml配置文件中，添加logback-classic的依赖坐标即可。\n在pom.xml文件中只添加了logback-classic依赖，但由于maven的依赖具有传递性，所以会自动把所依赖的其他jar包也一起导入。\n依赖传递可以分为：\n直接依赖：在当前项目中通过依赖配置建立的依赖关系\n间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源\n比如以上图中：\nprojectA依赖了projectB。对于projectA 来说，projectB 就是直接依赖。 而projectB依赖了projectC及其他jar包。 那么此时，在projectA中也会将projectC的依赖传递下来。对于projectA 来说，projectC就是间接依赖。 # 4.2.2 排除依赖 问题：之前我们讲了依赖具有传递性。那么A依赖B，B依赖C，如果A不想将C依赖进来，是否可以做到？\n答案：在maven项目中，我们可以通过排除依赖来实现。\n什么是排除依赖？\n排除依赖：指主动断开依赖的资源。（被排除的资源无需指定版本） 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-projectB\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--排除依赖, 主动断开依赖的资源--\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 依赖排除示例：\nmaven-projectA依赖了maven-projectB，maven-projectB依赖了Junit。基于依赖的传递性，所以maven-projectA也依赖了Junit 使用排除依赖后 # 4.3 依赖范围 在项目中导入依赖的jar包后，默认情况下，可以在任何地方使用。\n如果希望限制依赖的使用范围，可以通过标签设置其作用范围。\n作用范围：\n主程序范围有效（main文件夹范围内）\n测试程序范围有效（test文件夹范围内）\n是否参与打包运行（package指令范围内）\n如上图所示，给junit依赖通过scope标签指定依赖的作用范围。 那么这个依赖就只能作用在测试环境，其他环境下不能使用。\nscope标签的取值范围：\nscope值 主程序 测试程序 打包（运行） 范例 compile（默认） Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 # 4.4 生命周期 # 4.4.1 介绍 Maven的生命周期就是为了对所有的构建过程进行抽象和统一。 描述了一次项目构建，经历哪些阶段。\n在Maven出现之前，项目构建的生命周期就已经存在，软件开发人员每天都在对项目进行清理，编译，测试及部署。虽然大家都在不停地做构建工作，但公司和公司间、项目和项目间，往往使用不同的方式做类似的工作。\nMaven从大量项目和构建工具中学习和反思，然后总结了一套高度完美的，易扩展的项目构建生命周期。这个生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有构建步骤。\nMaven对项目构建的生命周期划分为3套（相互独立）：\nclean：清理工作。\ndefault：核心工作。如：编译、测试、打包、安装、部署等。\nsite：生成报告、发布站点等。\n三套生命周期又包含哪些具体的阶段呢, 我们来看下面这幅图:\n我们看到这三套生命周期，里面有很多很多的阶段，这么多生命周期阶段，其实我们常用的并不多，主要关注以下几个：\n• clean：移除上一次构建生成的文件\n• compile：编译项目源代码\n• test：使用合适的单元测试框架运行测试(junit)\n• package：将编译后的文件打包，如：jar、war等\n• install：安装项目到本地仓库\nMaven的生命周期是抽象的，这意味着生命周期本身不做任何实际工作。在Maven的设计中，实际任务（如源代码编译）都交由插件来完成。\nIDEA工具为了方便程序员使用maven生命周期，在右侧的maven工具栏中，已给出快速访问通道\n生命周期的顺序是：clean \u0026ndash;\u0026gt; validate \u0026ndash;\u0026gt; compile \u0026ndash;\u0026gt; test \u0026ndash;\u0026gt; package \u0026ndash;\u0026gt; verify \u0026ndash;\u0026gt; install \u0026ndash;\u0026gt; site \u0026ndash;\u0026gt; deploy\n我们需要关注的就是：clean \u0026ndash;\u0026gt; compile \u0026ndash;\u0026gt; test \u0026ndash;\u0026gt; package \u0026ndash;\u0026gt; install\n说明：在同一套生命周期中，我们在执行后面的生命周期时，前面的生命周期都会执行。\n思考：当运行package生命周期时，clean、compile生命周期会不会运行？\n​\tclean不会运行，compile会运行。 因为compile与package属于同一套生命周期，而clean与package不属于同一套生命周期。\n# 4.4.2 执行 在日常开发中，当我们要执行指定的生命周期时，有两种执行方式：\n在idea工具右侧的maven工具栏中，选择对应的生命周期，双击执行 在DOS命令行中，通过maven命令执行 方式一：在idea中执行生命周期\n选择对应的生命周期，双击执行 compile：\ntest：\npackage：\ninstall：\nclean：\n方式二：在命令行中执行生命周期\n进入到DOS命令行 # 05. 附录 # 5.1 更新依赖索引 有时候给idea配置完maven仓库信息后，在idea中依然搜索不到仓库中的jar包。这是因为仓库中的jar包索引尚未更新到idea中。这个时候我们就需要更新idea中maven的索引了，具体做法如下：\n打开设置\u0026mdash;-搜索maven\u0026mdash;-Repositories\u0026mdash;-选中本地仓库\u0026mdash;\u0026ndash;点击Update\n# 5.2 清理maven仓库 初始情况下，我们的本地仓库是没有任何jar包的，此时会从私服去下载（如果没有配置，就直接从中央仓库去下载），可能由于网络的原因，jar包下载不完全，这些不完整的jar包都是以lastUpdated结尾。此时，maven不会再重新帮你下载，需要你删除这些以lastUpdated结尾的文件，然后maven才会再次自动下载这些jar包。\n如果本地仓库中有很多这样的以lastUpadted结尾的文件，可以定义一个批处理文件，在其中编写如下脚本来删除：\n1 2 3 4 5 6 7 set REPOSITORY_PATH=E:\\develop\\apache-maven-3.6.1\\mvn_repo rem 正在搜索... del /s /q %REPOSITORY_PATH%\\*.lastUpdated rem 搜索完毕 pause 操作步骤如下：\n1). 定义批处理文件del_lastUpdated.bat (直接创建一个文本文件，命名为del_lastUpdated，后缀名直接改为bat即可 )\n2). 在上面的bat文件上右键\u0026mdash;》编辑 。修改文件：\n修改完毕后，双击运行即可删除maven仓库中的残留文件。\n","date":"2024-04-29T11:37:47+08:00","permalink":"http://localhost:1313/p/maven%E5%9F%BA%E7%A1%80/","title":"Maven基础"},{"content":" # 1 Ajax # 1.1 Ajax介绍 # 1.1.1 Ajax概述 我们前端页面中的数据，如下图所示的表格中的学生信息，应该来自于后台，那么我们的后台和前端是互不影响的2个程序，那么我们前端应该如何从后台获取数据呢？因为是2个程序，所以必须涉及到2个程序的交互，所以这就需要用到我们接下来学习的Ajax技术。\nAjax: 全称Asynchronous JavaScript And XML，异步的JavaScript和XML。其作用有如下2点：\n与服务器进行数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据。 异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用的校验等等。 # 1.1.2 Ajax作用 我们详细的解释一下Ajax技术的2个作用\n与服务器进行数据交互\n如下图所示前端资源被浏览器解析，但是前端页面上缺少数据，前端可以通过Ajax技术，向后台服务器发起请求，后台服务器接受到前端的请求，从数据库中获取前端需要的资源，然后响应给前端，前端在通过我们学习的vue技术，可以将数据展示到页面上，这样用户就能看到完整的页面了。此处可以对比JavaSE中的网络编程技术来理解。\n异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。\n如下图所示，当我们再百度搜索java时，下面的联想数据是通过Ajax请求从后台服务器得到的，在整个过程中，我们的Ajax请求不会导致整个百度页面的重新加载，并且只针对搜索栏这局部模块的数据进行了数据的更新，不会对整个页面的其他地方进行数据的更新，这样就大大提升了页面的加载速度，用户体验高。\n# 1.1.3 同步异步 针对于上述Ajax的局部刷新功能是因为Ajax请求是异步的，与之对应的有同步请求。接下来我们介绍一下异步请求和同步请求的区别。\n同步请求发送过程如下图所示：\n浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。\n异步请求发送过程如下图所示：\n浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。\n# 1.2 原生Ajax 对于Ajax技术有了充分的认知了，我们接下来通过代码来演示Ajax的效果。此处我们先采用原生的Ajax代码来演示。因为Ajax请求是基于客户端发送请求，服务器响应数据的技术。所以为了完成快速入门案例，我们需要提供服服务器端和编写客户端。\n服务器端\n因为我们暂时还没学过服务器端的代码，所以此处已经直接提供好了服务器端的请求地址，我们前端直接通过Ajax请求访问该地址即可。后台服务器地址：http://yapi.smart-xwork.cn/mock/169327/emp/list\n上述地址我们也可以直接通过浏览器来访问，访问结果如图所示：只截取部分数据\n客户端\n客户端的Ajax请求代码如下有如下4步，接下来我们跟着步骤一起操作一下。\n第一步：首先我们再VS Code中创建AJAX的文件夹，并且创建名为01. Ajax-原生方式.html的文件，提供如下代码，主要是按钮绑定单击事件，我们希望点击按钮，来发送ajax请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;原生Ajax\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;获取数据\u0026#34; onclick=\u0026#34;getData()\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function getData(){ } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 第二步：创建XMLHttpRequest对象，用于和服务器交换数据，也是原生Ajax请求的核心对象，提供了各种方法。代码如下：\n1 2 //1. 创建XMLHttpRequest var xmlHttpRequest = new XMLHttpRequest(); 第三步：调用对象的open()方法设置请求的参数信息，例如请求地址，请求方式。然后调用send()方法向服务器发送请求，代码如下：\n1 2 3 //2. 发送异步请求 xmlHttpRequest.open(\u0026#39;GET\u0026#39;,\u0026#39;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#39;); xmlHttpRequest.send();//发送请求 第四步：我们通过绑定事件的方式，来获取服务器响应的数据。\n1 2 3 4 5 6 7 //3. 获取服务响应数据 xmlHttpRequest.onreadystatechange = function(){ //此处判断 4表示浏览器已经完全接受到Ajax请求得到的响应， 200表示这是一个正确的Http请求，没有错误 if(xmlHttpRequest.readyState == 4 \u0026amp;\u0026amp; xmlHttpRequest.status == 200){ document.getElementById(\u0026#39;div1\u0026#39;).innerHTML = xmlHttpRequest.responseText; } } 最后我们通过浏览器打开页面，请求点击按钮，发送Ajax请求，最终显示结果如下图所示：\n并且通过浏览器的f12抓包，我们点击网络中的XHR请求，发现可以抓包到我们发送的Ajax请求。XHR代表的就是异步请求\n# 1.3 Axios 上述原生的Ajax请求的代码编写起来还是比较繁琐的，所以接下来我们学习一门更加简单的发送Ajax请求的技术Axios 。Axios是对原生的AJAX进行封装，简化书写。Axios官网是：https://www.axios-http.cn\n# 1.3.1 Axios的基本使用 Axios的使用比较简单，主要分为2步：\n引入Axios文件\n1 \u0026lt;script src=\u0026#34;js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 使用Axios发送请求，并获取响应结果，官方提供的api很多，此处给出2种，如下\n发送 get 请求（浏览器默认get请求）\n1 2 3 4 5 6 axios({ method:\u0026#34;get\u0026#34;, url:\u0026#34;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan\u0026#34; }).then(function (resp){ alert(resp.data); }) 发送 post 请求\n1 2 3 4 5 6 7 axios({ method:\u0026#34;post\u0026#34;, url:\u0026#34;http://localhost:8080/ajax-demo1/aJAXDemo1\u0026#34;, data:\u0026#34;username=zhangsan\u0026#34; }).then(function (resp){ alert(resp.data); }); axios()是用来发送异步请求的，小括号中使用 js的JSON对象传递请求相关的参数：\nmethod属性：用来设置请求方式的。取值为 get 或者 post。 url属性：用来书写请求的资源路径。如果是 get 请求，需要将请求参数拼接到路径的后面，格式为： url?参数名=参数值\u0026amp;参数名2=参数值2。 data属性：作为请求体被发送的数据。也就是说如果是 post 请求的话，数据需要作为 data 属性的值。 then() 需要传递一个匿名函数。我们将 then()中传递的匿名函数称为 回调函数，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。而该回调函数中的 resp 参数是对响应的数据进行封装的对象，通过 resp.data 可以获取到响应的数据。\n# 1.3.2 Axios快速入门 后端实现\n查询所有员工信息服务器地址：http://yapi.smart-xwork.cn/mock/169327/emp/list\n根据员工id删除员工信息服务器地址：http://yapi.smart-xwork.cn/mock/169327/emp/deleteById\n前端实现\n首先在VS Code中创建js文件夹，与html同级，然后将官网下载的axios-0.18.0.js 文件拷贝到js目录下，然后创建名为02. Ajax-Axios.html的文件，工程结果如图所示：\n然后在html中引入axios所依赖的js文件，并且提供2个按钮，绑定单击事件，分别用于点击时发送ajax请求，完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ajax-Axios\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;获取数据GET\u0026#34; onclick=\u0026#34;get()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;删除数据POST\u0026#34; onclick=\u0026#34;post()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function get(){ //通过axios发送异步请求-get } function post(){ //通过axios发送异步请求-post } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 然后分别使用Axios的方法，完整get请求和post请求的发送\nget请求代码如下：\n1 2 3 4 5 6 7 //通过axios发送异步请求-get axios({ method: \u0026#34;get\u0026#34;, url: \u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) post请求代码如下：\n1 2 3 4 5 6 7 8 //通过axios发送异步请求-post axios({ method: \u0026#34;post\u0026#34;, url: \u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/deleteById\u0026#34;, data: \u0026#34;id=1\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) 浏览器打开，f12抓包，然后分别点击2个按钮，查看控制台效果如下：\n完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ajax-Axios\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;获取数据GET\u0026#34; onclick=\u0026#34;get()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;删除数据POST\u0026#34; onclick=\u0026#34;post()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function get(){ //通过axios发送异步请求-get axios({ method: \u0026#34;get\u0026#34;, url: \u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) } function post(){ // 通过axios发送异步请求-post axios({ method: \u0026#34;post\u0026#34;, url: \u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/deleteById\u0026#34;, data: \u0026#34;id=1\u0026#34; }).then(result =\u0026gt; { console.log(result.data); }) } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 1.3.3 请求方法的别名 Axios还针对不同的请求，提供了别名方式的api,具体如下：[]里为可选的\n方法 描述 axios.get(url [, config]) 发送get请求 axios.delete(url [, config]) 发送delete请求 axios.post(url [, data[, config]]) 发送post请求 axios.put(url [, data[, config]]) 发送put请求 我们目前只关注get和post请求，所以在上述的入门案例中，我们可以将get请求代码改写成如下：\n1 2 3 axios.get(\u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34;).then(result =\u0026gt; { console.log(result.data); }) post请求改写成如下：\n1 2 3 axios.post(\u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/deleteById\u0026#34;,\u0026#34;id=1\u0026#34;).then(result =\u0026gt; { console.log(result.data); }) # 1.3.4 案例 需求：基于Vue及Axios完成数据的动态加载展示，如下图所示\n其中数据是来自于后台程序的，地址是：http://yapi.smart-xwork.cn/mock/169327/emp/list\n分析：\n前端首先是一张表格，我们缺少数据，而提供数据的地址已经有了，所以意味这我们需要使用Ajax请求获取后台的数据。但是Ajax请求什么时候发送呢？页面的数据应该是页面加载完成，自动发送请求，展示数据，所以我们需要借助vue的mounted钩子函数。那么拿到数据了，我们该怎么将数据显示表格中呢？这里就得借助v-for指令来遍历数据，展示数据。\n步骤：\n首先创建文件，提前准备基础代码，包括表格以及vue.js和axios.js文件的引入 我们需要在vue的mounted钩子函数中发送ajax请求，获取数据 拿到数据，数据需要绑定给vue的data属性 在\u0026lt;tr\u0026gt;标签上通过v-for指令遍历数据，展示数据 代码实现：\n首先创建文件，提前准备基础代码，包括表格以及vue.js和axios.js文件的引入\n提供初始代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ajax-Axios-案例\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;60%\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;图像\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;职位\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;入职日期\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;最后操作时间\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34; \u0026gt; \u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Tom\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; width=\u0026#34;70px\u0026#34; height=\u0026#34;50px\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span\u0026gt;男\u0026lt;/span\u0026gt; \u0026lt;!-- \u0026lt;span\u0026gt;女\u0026lt;/span\u0026gt;--\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;班主任\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2009-08-09\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;2009-08-09 12:00:00\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { } }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 在vue的mounted钩子函数，编写Ajax请求，请求数据，代码如下：\n1 2 3 4 5 6 mounted () { //发送异步请求,加载数据 axios.get(\u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34;).then(result =\u0026gt; { }) } ajax请求的数据我们应该绑定给vue的data属性，之后才能进行数据绑定到视图；并且浏览器打开后台地址，数据返回格式如下图所示：\n因为服务器响应的json中的data属性才是我们需要展示的信息，所以我们应该将员工列表信息赋值给vue的data属性，代码如下：\n1 2 3 4 5 6 //发送异步请求,加载数据 axios.get(\u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34;).then(result =\u0026gt; { // result.data.data表示响应数据的data字段（一个数组） // this.emps表示当前vue对象的emps数据模型 this.emps = result.data.data;// result表示对返回的响应数据进行封装的对象，result.data表示获取对象的数据 }) 其中，data中生命emps变量，代码如下：\n1 2 3 data: { emps:[] }, 在\u0026lt;tr\u0026gt;标签上通过v-for指令遍历数据，展示数据，其中需要注意的是图片的值，需要使用vue的属性绑定，男女的展示需要使用条件判断，其代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;tr align=\u0026#34;center\u0026#34; v-for=\u0026#34;(emp,index) in emps\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index + 1}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img :src=\u0026#34;emp.image\u0026#34; width=\u0026#34;70px\u0026#34; height=\u0026#34;50px\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span v-if=\u0026#34;emp.gender == 1\u0026#34;\u0026gt;男\u0026lt;/span\u0026gt; \u0026lt;span v-if=\u0026#34;emp.gender == 2\u0026#34;\u0026gt;女\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.job}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.entrydate}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.updatetime}}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; 完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ajax-Axios-案例\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;60%\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;图像\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;职位\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;入职日期\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;最后操作时间\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34; v-for=\u0026#34;(emp,index) in emps\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index + 1}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img :src=\u0026#34;emp.image\u0026#34; width=\u0026#34;70px\u0026#34; height=\u0026#34;50px\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span v-if=\u0026#34;emp.gender == 1\u0026#34;\u0026gt;男\u0026lt;/span\u0026gt; \u0026lt;span v-if=\u0026#34;emp.gender == 2\u0026#34;\u0026gt;女\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.job}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.entrydate}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.updatetime}}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { emps:[] }, mounted () { //发送异步请求,加载数据 axios.get(\u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34;).then(result =\u0026gt; { console.log(result.data); this.emps = result.data.data; }) } }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 2 前后台分离开发 # 2.1 前后台分离开发介绍 在之前的课程中，我们介绍过，前端开发有2种方式：前后台混合开发和前后台分离开发。\n前后台混合开发，顾名思义就是前台后台代码混在一起开发，如下图所示：\n这种开发模式有如下缺点：\n沟通成本高：后台人员发现前端有问题，需要找前端人员修改，前端修改成功，再交给后台人员使用 分工不明确：后台开发人员需要开发后台代码，也需要开发部分前端代码。很难培养专业人才 不便管理：所有的代码都在一个工程中 不便维护和扩展：前端代码更新，和后台无关，但是需要整个工程包括后台一起重新打包部署。 所以我们目前基本都是采用的前后台分离开发方式，如下图所示：\n我们将原先的工程分为前端工程和后端工程这2个工程，然后前端工程交给专业的前端人员开发，后端工程交给专业的后端人员开发。前端页面需要数据，可以通过发送Ajax/Axios异步请求，从后台工程获取。但是，我们前后台是分开来开发的，那么前端人员怎么知道后台返回数据的格式呢？后端人员开发，怎么知道前端人员需要的数据格式呢？所以针对这个问题，我们前后台统一指定一套规范！我们前后台开发人员都需要遵循这套规范开发，这就是我们的接口文档。接口文档有离线版和在线版本，那么接口文档的内容怎么来的呢？是我们后台开发者根据产品经理提供的产品原型和需求文档所撰写出来的。\n那么基于前后台分离开发的模式下，我们后台开发者开发一个功能的具体流程如何呢？如下图所示：\n需求分析：首先我们需要阅读需求文档，分析需求，理解需求。 接口定义：查询接口文档中关于需求的接口的定义，包括地址，参数，响应数据类型等等 前后台并行开发：各自按照接口文档进行开发，实现需求 测试：前后台开发完了，各自按照接口文档进行测试 前后段联调测试：前段工程请求后端工程，测试功能 # 2.2 YAPI # 2.2.1 YAPI介绍 前后台分离开发中，我们前后台开发人员都需要遵循接口文档，所以接下来我们介绍一款撰写接口文档的平台。\nYApi 是高效、易用、功能强大的 api 管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。\n其官网地址：http://yapi.pro\nYApi主要提供了2个功能：\nAPI接口管理：根据需求撰写接口，包括接口的地址，参数，响应等等信息。 Mock服务：模拟真实接口，生成接口的模拟测试数据，用于前端的测试。 # 2.2.2 接口文档管理 接下来我们演示一下YApi是如何管理接口文档的。\n首先我们登录YAPI的官网，然后使用github或者百度账号登录，没有的话去注册一个，如下图所示：\n登录进去后，在个人空间中，选择项目列表-\u0026gt;添加测试项目，效果如图所示：\n然后点击创建的项目，进入到项目中，紧接着先添加接口的分类，如下图所示\n然后我们选择当前创建的分类，创建接口信息，如下图所示：\n紧接着，我们来到接口的编辑界面，对接口做生层次的定制，例如：接口的参数，接口的返回值等等，效果图下图所示：\n添加接口的请求参数，如下图所示：\n添加接口的返回值，如下图所示：\n然后保存上述设置，紧接着我们可以来到接口的预览界面，查询接口的信息，其效果如下图所示：篇幅有限，只截取部分\n最后，我们还可以设置接口的mock信息，\n来到接口的Mock设置窗口，如下图所示：\n紧接着我们来到接口的预览界面，直接点击Mock地址，如下图所示：\n我们发现浏览器直接打开，并返回如下数据：\n如上步骤就是YAPI接口平台中对于接口的配置步骤。\n# 3 前端工程化 # 3.1 前端工程化介绍 我们目前的前端开发中，当我们需要使用一些资源时，例如：vue.js，和axios.js文件，都是直接再工程中导入的，如下图所示：\n但是上述开发模式存在如下问题：\n每次开发都是从零开始，比较麻烦 多个页面中的组件共用性不好 js、图片等资源没有规范化的存储目录，没有统一的标准，不方便维护 所以现在企业开发中更加讲究前端工程化方式的开发，主要包括如下4个特点\n模块化：将js和css等，做成一个个可复用模块 组件化：我们将UI组件，css样式，js行为封装成一个个的组件，便于管理 规范化：我们提供一套标准的规范的目录接口和编码规范，所有开发人员遵循这套规范 自动化：项目的构建，测试，部署全部都是自动完成 所以对于前端工程化，说白了，就是在企业级的前端项目开发中，把前端开发所需要的工具、技术、流程、经验进行规范化和标准化。从而提升开发效率，降低开发难度等等。接下来我们就需要学习vue的官方提供的脚手架帮我们完成前端的工程化。\n# 3.2 前端工程化入门 # 3.2.1 环境准备 我们的前端工程化是通过vue官方提供的脚手架Vue-cli来完成的，用于快速的生成一个Vue的项目模板。Vue-cli主要提供了如下功能：\n统一的目录结构 本地调试 热部署 单元测试 集成打包上线 我们需要运行Vue-cli，需要依赖NodeJS，NodeJS是前端工程化依赖的环境。所以我们需要先安装NodeJS，然后才能安装Vue-cli\nNodeJS安装和Vue-cli安装\n详细安装步骤，请参考D:\\Code\\JAVAWEB\\NodeJS安装文档/NodeJS安装文档.md文件\n# 3.2.2 Vue项目简介 环境准备好了，接下来我们需要通过Vue-cli创建一个vue项目，然后再学习一下vue项目的目录结构。Vue-cli提供了如下2种方式创建vue项目:\n命令行：直接通过命令行方式创建vue项目\n1 vue create vue-project01 图形化界面：通过命令先进入到图形化界面，然后再进行vue工程的创建\n1 vue ui 图形化界面如下：\n# 3.2.2.1 创建vue项目 此处我们通过第二种图形化界面方式给大家演示。\n首先，我们再桌面创建vue文件夹，然后双击进入文件夹，来到地址目录，输入cmd，然后进入到vue文件夹的cmd窗口界面，如下图所示：\n然后进入如下界面：\n然后再当前目录下，直接输入命令vue ui进入到vue的图形化界面，如下图所示：\n然后我门选择创建按钮，在vue文件夹下创建项目，如下图所示：\n然后来到如下界面，进行vue项目的创建\n然后预设模板选择手动，如下图所示：\n然后再功能页面开启路由功能，如下图所示：\n然后再配置页面选择语言版本和语法检查规范，如下图所示：\n然后创建项目，进入如下界面：\n最后我们只需要等待片刻，即可进入到创建创建成功的界面，如下图所示：\n到此，vue项目创建结束\n# 3.2.2.2 vue项目目录结构介绍 我们通过VS Code打开之前创建的vue文件夹，打开之后，呈现如下图所示页面：\nvue项目的标准目录结构以及目录对应的解释如下图所示:\n其中我们平时开发代码就是在src目录下\n# 3.2.2.3 运行vue项目 那么vue项目开发好了，我们应该怎么运行vue项目呢？主要提供了2种方式\n第一种方式：通过VS Code提供的图形化界面 ，如下图所示：（注意：NPM脚本窗口默认不显示，可以参考本节的最后调试出来）\n点击之后，我们等待片刻，即可运行，在终端界面中，我们发现项目是运行在本地服务的8080端口，我们直接通过浏览器打开地址\n最终浏览器打开后，呈现如下界面，表示项目运行成功\n其实此时访问的是 src/App.vue这个根组件，此时我们打开这个组件，修改代码：添加内容Vue\n只要我们保存更新的代码，我们直接打开浏览器，不需要做任何刷新，发现页面呈现内容发生了变化，如下图所示：\n这就是我们vue项目的热更新功能\n对于8080端口，经常被占用，所以我们可以去修改默认的8080端口。我们修改vue.config.js文件的内容，添加如下代码：\n1 2 3 devServer:{ port:7000 } 如下图所示，然后我们关闭服务器（ctrl c），并且重新启动，\n​ 重新启动如下图所示：\n​\t​\t端口更改成功，可以通过浏览器访问7000端口来访问我们之前的项目\n第二种方式：命令行方式\n直接基于cmd命令窗口，在vue目录下，执行输入命令npm run serve即可，如下图所示：\n补充：NPM脚本窗口调试出来\n第一步：通过设置/用户设置/扩展/MPM更改NPM默认配置，如下图所示\n然后重启VS Code，并且双击打开package.json文件，然后点击资源管理器处的3个小点，勾选npm脚本选项，如图所示\n然后就能都显示NPM脚本小窗口了。\n# 3.2.3 Vue项目开发流程 那么我们访问的首页是index.html，但是我们找到public/index.html文件，打开之后发现，里面没有什么代码，但是能够呈现内容丰富的首页：如下图所示：\n我们仔细观察发现，index.html的代码很简洁，但是浏览器所呈现的index.html内容却很丰富，代码和内容不匹配，所以vue是如何做到的呢？接下来我们学习一下vue项目的开发流程。\n对于vue项目，index.html文件默认是引入了入口函数main.js文件，我们找到src/main.js文件，其代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 引用这些组件/模块并重命名 import Vue from \u0026#39;vue\u0026#39; import App from \u0026#39;./App.vue\u0026#39; import router from \u0026#39;./router\u0026#39; Vue.config.productionTip = false new Vue({ router, render: h =\u0026gt; h(App) }).$mount(\u0026#39;#app\u0026#39;) // 等价于上面Vue对象 new Vue({ el:\u0026#34;#app\u0026#34;, router:router, render:h =\u0026gt; h(App) }) 上述代码中，包括如下几个关键点：\nimport: 导入指定文件，并且重新起名。例如上述代码import App from './App.vue'导入当前目录下得App.vue并且起名为App export：将对象或函数导出为模块，之后别人就能导入模块了 new Vue(): 创建vue对象 $mount(\u0026rsquo;#app\u0026rsquo;);将vue对象创建的dom对象挂载到id=app的这个标签区域中，作用和之前学习的vue对象的le属性一致。 router: 路由，详细在后面的小节讲解。router,等价于router:router render: 是一个函数，将上面导入进来的App当中所定义的视图，创建出对应的虚拟dom元素，然后挂载到id=app这个区域。总之，就是用于视图的渲染的。 来到public/index.html中，我们删除div的id=app属性，打开浏览器，发现之前访问的首页一片空白，如下图所示，这样就证明了，我们main.js中通过代码挂载到index.html的id=app的标签区域的。\n此时我们知道了vue创建的dom对象挂载到id=app的标签区域，但是我们还是没有解决最开始的问题：首页内容如何呈现的？这就涉及到render中的App了，如下图所示：\n那么这个App对象怎么回事呢，我们打开App.vue,注意的是.vue结尾的都是vue组件。而vue的组件文件包含3个部分：\ntemplate: 模板部分，主要是HTML代码，用来展示页面主体结构的 script: js代码区域，主要是通过js代码来控制模板的数据来源和行为的 style: css样式部分，主要通过css样式控制模板的页面效果得 如下图所示就是一个vue组件的小案例：\n此时我们可以打开App.vue，观察App.vue的代码，其中可以发现，App.vue组件的template部分内容，和我们浏览器访问的首页内容是一致的，如下图所示：\n接下来我们可以简化模板部分内容，添加script部分的数据模型，删除css样式，完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{message}} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; // 直接选择javascript.vue会自动生成代码框架 \u0026lt;script\u0026gt; export default { //为data属性指定一个函数，等价data:function(){return{对象}} data(){ // return一个对象 return { message:\u0026#34;hello world\u0026#34; } }, methods:{ } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 保存直接，回到浏览器，我们发现首页展示效果发生了变化，如下图所示：\n# 4 Vue组件库Element # 4.1 Element介绍 不知道同学们还否记得我们之前讲解的前端开发模式MVVM，我们之前学习的vue是侧重于VM开发的，主要用于数据绑定到视图的，那么接下来我们学习的ElementUI就是一款侧重于V开发的前端框架，主要用于开发美观的页面的。\nElement：是饿了么公司前端开发团队提供的一套基于 Vue 的网站组件库，用于快速构建网页。\nElement 提供了很多组件（组成网页的部件）供我们使用。例如 超链接、按钮、图片、表格等等。如下图所示就是我们开发的页面和ElementUI提供的效果对比：可以发现ElementUI提供的各式各样好看的按钮\nElementUI的学习方式和我们之前的学习方式不太一样，对于ElementUI，我们作为一个后台开发者，只需要学会如何从ElementUI的官网拷贝组件到我们自己的页面中，并且做一些修改即可。其官网地址：https://element.eleme.cn/#/zh-CN，我们主要学习的是ElementUI中提供的常用组件，至于其他组件同学们可以通过我们这几个组件的学习掌握到ElementUI的学习技巧，然后课后自行学习。\n# 4.2 快速入门 首先我们要掌握ElementUI的快速入门，接下来同学们就一起跟着步骤来操作一下。\n首先，我们先要安装ElementUI的组件库，打开VS Code，停止之前的项目，然后在命令行输入如下命令，会把该组件安装在node_modules目录下\n1 npm install element-ui@2.15.3 具体操作如下图所示：\n然后我们需要在main.js这个入口js文件中引入ElementUI的组件库，其代码如下：\n1 2 3 4 import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.use(ElementUI); 具体操作如图所示：\n然后我们需要按照vue项目的开发规范，在src/views目录下创建一个vue组件文件（采用大驼峰命名，多个vue组件文件的话，在views目录下再建个element文件来放），注意组件名称后缀是.vue，并且在组件文件中编写之前介绍过的基本组件语法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 具体操作如图所示：\n最后我们只需要去ElementUI的官网，找到组件库，然后找到按钮组件，抄写代码即可，具体操作如下图所示：\n然后找到按钮的代码，如下图所示：\n紧接着我们复制组件代码到我们的vue组件文件中，操作如下图所示：\n最后，我们需要在默认访问的根组件src/App.vue中引入我们自定义的组件，具体操作步骤如下：\n然后App.vue组件中的具体代码如下，代码是我们通过上述步骤引入element-view组件时自动生成的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- {{message}} --\u0026gt; \u0026lt;element-view\u0026gt;\u0026lt;/element-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import ElementView from \u0026#39;./views/Element/ElementView.vue\u0026#39; export default { components: { ElementView }, data(){ return { \u0026#34;message\u0026#34;:\u0026#34;hello world\u0026#34; } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 然后运行我们的vue项目，浏览器直接访问之前的7000端口，展示效果如下图所示：\n到此，我们ElementUI的入门程序编写成功\n# 4.3 Element组件 接下来我们来学习一下ElementUI的常用组件，对于组件的学习比较简单，我们只需要参考官方提供的代码，然后复制粘贴即可。\n# 4.3.1 Table表格 # 4.3.1.1 组件演示 Table 表格：用于展示多条结构类似的数据，可对数据进行排序、筛选、对比或其他自定义操作。\n接下来我们通过代码来演示。\n首先我们需要来到ElementUI的组件库中，找到表格组件，如下图所示：\n然后复制代码到我们之前的ElementVue.vue组件中，需要注意的是，我们组件包括了3个部分，如果官方有除了template部分之外的style和script都需要复制。具体操作如下图所示：\ntemplate模板部分：\nscript脚本部分\nElementView.vue组件文件整体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- Button按钮 --\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button\u0026gt;默认按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34;\u0026gt;主要按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34;\u0026gt;成功按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34;\u0026gt;信息按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34;\u0026gt;警告按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34;\u0026gt;危险按钮\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;!-- Table表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { tableData: [{ date: \u0026#39;2016-05-02\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-04\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1517 弄\u0026#39; }, { date: \u0026#39;2016-05-01\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1519 弄\u0026#39; }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1516 弄\u0026#39; }] } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 此时回到浏览器，我们页面呈现如下效果：\n# 4.3.1.2 组件属性详解 那么我们的ElementUI是如何将数据模型绑定到视图的呢？主要通过如下几个属性：\ndata: 主要定义table组件的数据模型 prop: 定义列的数据应该绑定data中定义的具体的数据模型 label: 定义列的标题 width: 定义列的宽度 其具体示例含义如下图所示：\nPS:Element组件的所有属性都可以在组件页面的最下方找到，如下图所示：\n# 4.3.2 Pagination分页 # 4.3.2.1 组件演示 Pagination: 分页组件，主要提供分页工具条相关功能。其展示效果图下图所示：\n接下来我们通过代码来演示功能。\n首先在官网找到分页组件，我们选择带背景色分页组件，如下图所示：\n然后复制代码到我们的ElementView.vue组件文件的template中，拷贝如下代码：\n1 2 3 4 5 \u0026lt;el-pagination background layout=\u0026#34;prev, pager, next\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; 浏览器打开呈现如下效果：\n# 4.3.2.2 组件属性详解 对于分页组件我们需要关注的是如下几个重要属性（可以通过查阅官网组件中最下面的组件属性详细说明得到）：\nbackground: 添加北京颜色，也就是上图蓝色背景色效果。 layout: 分页工具条的布局，其具体值包含sizes, prev, pager, next, jumper, -\u0026gt;, total, slot 这些值 total: 数据的总数量 然后根据官方分页组件提供的layout属性说明，如下图所示：\n我们修改layout属性如下：\n1 layout=\u0026#34;sizes,prev, pager, next,jumper,total\u0026#34; 浏览器打开呈现如下效果：\n发现在原来的功能上，添加了一些额外的功能，其具体对应关系如下图所示：\n# 4.3.2.3 组件事件详解 对于分页组件，除了上述几个属性，还有2个非常重要的事件我们需要去学习：\nsize-change ： pageSize 改变时会触发 current-change ：currentPage 改变时会触发 其官方详细解释含义如下图所示：\n对于这2个事件的参考代码，我们同样可以通过官方提供的完整案例中找到，如下图所示：\n然后我们找到对应的代码，首先复制事件，复制代码如下：\n1 2 @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; 此时Panigation组件的template完整代码如下：\n1 2 3 4 5 6 7 8 \u0026lt;!-- Pagination分页 --\u0026gt; \u0026lt;el-pagination @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; background layout=\u0026#34;sizes,prev, pager, next,jumper,total\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; 紧接着需要复制事件需要的2个函数，需要注意methods属性和data同级，其代码如下：\n1 2 3 4 5 6 7 8 methods: { handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } }, 此时Panigation组件的script部分完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;script\u0026gt; export default { methods: { handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } }, data() { return { tableData: [{ date: \u0026#39;2016-05-02\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-04\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1517 弄\u0026#39; }, { date: \u0026#39;2016-05-01\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1519 弄\u0026#39; }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1516 弄\u0026#39; }] } } } \u0026lt;/script\u0026gt; 回到浏览器中，我们f12打开开发者控制台，然后切换当前页码和切换每页显示的数量，呈现如下效果：\n# 4.3.3 Dialog对话框 # 4.3.3.1 组件演示 Dialog: 在保留当前页面状态的情况下，告知用户并承载相关操作。其企业开发应用场景示例如下图所示：\n首先我们需要在ElementUI官方找到Dialog组件，如下图所示：\n然后复制如下代码到我们的组件文件的template模块中\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;!--Dialog 对话框 --\u0026gt; \u0026lt;!-- Table --\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;dialogTableVisible = true\u0026#34;\u0026gt;打开嵌套表格的 Dialog\u0026lt;/el-button\u0026gt; \u0026lt;el-dialog title=\u0026#34;收货地址\u0026#34; :visible.sync=\u0026#34;dialogTableVisible\u0026#34;\u0026gt; \u0026lt;el-table :data=\u0026#34;gridData\u0026#34;\u0026gt; \u0026lt;el-table-column property=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;150\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column property=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column property=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/el-dialog\u0026gt; 并且复制数据模型script模块中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 gridData: [{ date: \u0026#39;2016-05-02\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-04\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-01\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }], dialogTableVisible: false, 其完整的script部分代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 \u0026lt;script\u0026gt; export default { methods: { handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } }, data() { return { gridData: [{ date: \u0026#39;2016-05-02\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-04\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-01\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }], dialogTableVisible: false, tableData: [{ date: \u0026#39;2016-05-02\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-04\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1517 弄\u0026#39; }, { date: \u0026#39;2016-05-01\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1519 弄\u0026#39; }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1516 弄\u0026#39; }] } } } \u0026lt;/script\u0026gt; 然后我们打开浏览器，点击按钮，呈现如下效果：\n# 4.3.3.2 组件属性详解 那么ElementUI是如何做到对话框的显示与隐藏的呢？是通过如下的属性：\nvisible.sync ：是否显示 Dialog 具体释意如下图所示：\nvisible属性绑定的dialogTableVisble属性一开始默认是false，所以对话框隐藏；然后我们点击按钮，触发事件，修改属性值为true，\n然后对话框visible属性值为true，所以对话框呈现出来。\n# 4.3.4 Form表单 # 4.3.4.1 组件演示 Form 表单：由输入框、选择器、单选框、多选框等控件组成，用以收集、校验、提交数据。\n表单在我们前端的开发中使用的还是比较多的，接下来我们学习这个组件，与之前的流程一样，我们首先需要在ElementUI的官方找到对应的组件示例：如下图所示：\n我们的需求效果是：在对话框中呈现表单内容，类似如下图所示：\n所以，首先我们先要根据上一小结所学习的内容，制作一个新的对话框，其代码如下：\n1 2 3 4 5 6 7 \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;!-- Dialog对话框-Form表单 --\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;dialogFormVisible = true\u0026#34;\u0026gt;打开嵌套Form的 Dialog\u0026lt;/el-button\u0026gt; \u0026lt;el-dialog title=\u0026#34;Form表单\u0026#34; :visible.sync=\u0026#34;dialogFormVisible\u0026#34;\u0026gt; \u0026lt;/el-dialog\u0026gt; 还需要注意的是，针对这个新的对话框，我们需要在data中声明新的变量dialogFormVisible来控制对话框的隐藏与显示，代码如下：\n1 dialogFormVisible: false, 打开浏览器，此时呈现如图所示的效果：\n然后我们复制官网提供的template部分代码到我们的vue组件文件的Dialog组件中，但是，此处官方提供的表单项标签太多，所以我们只需要保留前面3个表单项组件，其他多余的删除，所以最终template部分代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;el-dialog title=\u0026#34;Form表单\u0026#34; :visible.sync=\u0026#34;dialogFormVisible\u0026#34;\u0026gt; \u0026lt;el-form ref=\u0026#34;form\u0026#34; :model=\u0026#34;form\u0026#34; label-width=\u0026#34;80px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动名称\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;form.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动区域\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;form.region\u0026#34; placeholder=\u0026#34;请选择活动区域\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;区域一\u0026#34; value=\u0026#34;shanghai\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;区域二\u0026#34; value=\u0026#34;beijing\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动时间\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;11\u0026#34;\u0026gt; \u0026lt;el-date-picker type=\u0026#34;date\u0026#34; placeholder=\u0026#34;选择日期\u0026#34; v-model=\u0026#34;form.date1\u0026#34; style=\u0026#34;width: 100%;\u0026#34;\u0026gt;\u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col class=\u0026#34;line\u0026#34; :span=\u0026#34;2\u0026#34;\u0026gt;-\u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;11\u0026#34;\u0026gt; \u0026lt;el-time-picker placeholder=\u0026#34;选择时间\u0026#34; v-model=\u0026#34;form.date2\u0026#34; style=\u0026#34;width: 100%;\u0026#34;\u0026gt;\u0026lt;/el-time-picker\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;立即创建\u0026lt;/el-button\u0026gt; \u0026lt;el-button\u0026gt;取消\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/el-dialog\u0026gt; 观察上述代码，我们发现其中表单项标签使用了v-model双向绑定，所以我们需要在vue的数据模型中声明变量，同样可以从官方提供的代码中复制粘贴，但是我们需要去掉我们不需要的属性，通过观察上述代码，我们发现双向绑定的属性有4个，分别是form.name,form.region,form.date1,form.date2,所以最终数据模型如下：\n1 2 3 4 5 6 form: { name: \u0026#39;\u0026#39;, region: \u0026#39;\u0026#39;, date1: \u0026#39;\u0026#39;, date2:\u0026#39;\u0026#39; }, 同样，官方的代码中，在script部分中，还提供了onSubmit函数，表单的立即创建按钮绑定了此函数，我们可以输入表单的内容，而表单的内容是双向绑定到form对象的，所以我们修改官方的onSubmit函数如下即可，而且我们还需要关闭对话框，最终函数代码如下：\n1 2 3 4 onSubmit() { console.log(this.form); //输出表单内容到控制台 this.dialogFormVisible=false; //关闭表案例的对话框 } 然后打开浏览器，我们打开对话框，并且输入表单内容，点击立即创建按钮，呈现如下效果；\n最终vue组件完整代码如下，同学们可以针对form表单案例，参考该案例对应的template部分和script部分代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- Button按钮 --\u0026gt; \u0026lt;el-row\u0026gt; \u0026lt;el-button\u0026gt;默认按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34;\u0026gt;主要按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;success\u0026#34;\u0026gt;成功按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;info\u0026#34;\u0026gt;信息按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;warning\u0026#34;\u0026gt;警告按钮\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34;\u0026gt;危险按钮\u0026lt;/el-button\u0026gt; \u0026lt;/el-row\u0026gt; \u0026lt;!-- Table表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; style=\u0026#34;width: 100%\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- Pagination分页 --\u0026gt; \u0026lt;el-pagination @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; background layout=\u0026#34;sizes,prev, pager, next,jumper,total\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;!--Dialog 对话框 --\u0026gt; \u0026lt;!-- Table --\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;dialogTableVisible = true\u0026#34;\u0026gt;打开嵌套表格的 Dialog\u0026lt;/el-button\u0026gt; \u0026lt;el-dialog title=\u0026#34;收货地址\u0026#34; :visible.sync=\u0026#34;dialogTableVisible\u0026#34;\u0026gt; \u0026lt;el-table :data=\u0026#34;gridData\u0026#34;\u0026gt; \u0026lt;el-table-column property=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;150\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column property=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;200\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column property=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;!-- Dialog对话框-Form表单 --\u0026gt; \u0026lt;el-button type=\u0026#34;text\u0026#34; @click=\u0026#34;dialogFormVisible = true\u0026#34;\u0026gt;打开嵌套Form的 Dialog\u0026lt;/el-button\u0026gt; \u0026lt;el-dialog title=\u0026#34;Form表单\u0026#34; :visible.sync=\u0026#34;dialogFormVisible\u0026#34;\u0026gt; \u0026lt;el-form ref=\u0026#34;form\u0026#34; :model=\u0026#34;form\u0026#34; label-width=\u0026#34;80px\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动名称\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;form.name\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动区域\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;form.region\u0026#34; placeholder=\u0026#34;请选择活动区域\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;区域一\u0026#34; value=\u0026#34;shanghai\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;区域二\u0026#34; value=\u0026#34;beijing\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;活动时间\u0026#34;\u0026gt; \u0026lt;el-col :span=\u0026#34;11\u0026#34;\u0026gt; \u0026lt;el-date-picker type=\u0026#34;date\u0026#34; placeholder=\u0026#34;选择日期\u0026#34; v-model=\u0026#34;form.date1\u0026#34; style=\u0026#34;width: 100%;\u0026#34;\u0026gt;\u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;el-col class=\u0026#34;line\u0026#34; :span=\u0026#34;2\u0026#34;\u0026gt;-\u0026lt;/el-col\u0026gt; \u0026lt;el-col :span=\u0026#34;11\u0026#34;\u0026gt; \u0026lt;el-time-picker placeholder=\u0026#34;选择时间\u0026#34; v-model=\u0026#34;form.date2\u0026#34; style=\u0026#34;width: 100%;\u0026#34;\u0026gt;\u0026lt;/el-time-picker\u0026gt; \u0026lt;/el-col\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;立即创建\u0026lt;/el-button\u0026gt; \u0026lt;el-button\u0026gt;取消\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;/el-dialog\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { methods: { handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); }, //表单案例的提交事件 onSubmit() { console.log(this.form); //输出表单内容到控制台 this.dialogFormVisible=false; //关闭表案例的对话框 } }, data() { return { //表单案例的数据双向绑定 form: { name: \u0026#39;\u0026#39;, region: \u0026#39;\u0026#39;, date1: \u0026#39;\u0026#39;, date2:\u0026#39;\u0026#39; }, gridData: [{ date: \u0026#39;2016-05-02\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-04\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-01\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }], dialogTableVisible: false, dialogFormVisible: false, //控制form表单案例的对话框 tableData: [{ date: \u0026#39;2016-05-02\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; }, { date: \u0026#39;2016-05-04\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1517 弄\u0026#39; }, { date: \u0026#39;2016-05-01\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1519 弄\u0026#39; }, { date: \u0026#39;2016-05-03\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1516 弄\u0026#39; }] } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; # 4.4 案例 # 4.4.1 案例需求 参考 资料/页面原型/tlias智能学习辅助系统/首页.html 文件，浏览器打开，点击页面中的左侧栏的员工管理，如下所示：\n需求说明：\n制作类似格式的页面\n即上面是标题，左侧栏是导航，右侧是数据展示区域\n右侧需要展示搜索表单\n右侧表格数据是动态展示的，数据来自于后台\n实际示例效果如下图所示：\n数据Mock地址：http://yapi.smart-xwork.cn/mock/169327/emp/list，浏览器打开，数据格式如下图所示：\n通过观察数据，我们发现返回的json数据的data属性中，才是返回的人员列表信息\n# 4.4.2 案例分析 整个案例相对来说功能比较复杂，需求较多，所以我们需要先整体，后局部细节。整个页面我们可以分为3个部分，如下图所示：\n一旦这样拆分，那么我们的思路就清晰了，主要步骤如下：\n创建页面，完成页面的整体布局规划 然后分别针对3个部分进行各自组件的具体实现 针对于右侧核心内容展示区域，需要使用异步加载数据，以表格渲染数据 # 4.4.3 代码实现 # 4.4.3.1 环境搭建 首先我们来到VS Code中，在views目录下创建 tlias/EmpView.vue这个vue组件，并且编写组件的基本模板代码，其效果如下图所示：其中模板代码在之前的案例中已经提供，此处不再赘述\n并且需要注意的是，我们默认访问的是App.vue这个组件，而我们App.vue这个组件之前是引入了element-view这个组件，此时我们需要修改成引入emp-view这个组件，并且注释掉之前的element-view这个组件，此时App.vue整体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- {{message}} --\u0026gt; \u0026lt;!-- \u0026lt;element-view\u0026gt;\u0026lt;/element-view\u0026gt; --\u0026gt; \u0026lt;emp-view\u0026gt;\u0026lt;/emp-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import EmpView \u0026#39;./views/tlias/EmpView.vue\u0026#39; // import ElementView \u0026#39;./views/Element/ElementView.vue\u0026#39; export default { components: {EmpView }, data(){ return { \u0026#34;message\u0026#34;:\u0026#34;hello world\u0026#34; } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 打开浏览器，我们发现之前的element案例内容没了，从而呈现的是一片空白，那么接下来我们就可以继续开发了。\n# 4.4.3.2 整体布局 此处肯定不需要我们自己去布局的，我们直接来到ElementUI的官网，找到布局组件，如下图所示：\n从官网提供的示例，我们发现由现成的满足我们需求的布局，所以我们只需要做一位代码搬运工即可。拷贝官方提供的如下代码直接粘贴到我们EmpView.vue组件的template模块中即可：\n1 2 3 4 5 6 7 \u0026lt;el-container\u0026gt; \u0026lt;el-header\u0026gt;Header\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt;Aside\u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt;Main\u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; 打开浏览器，此时呈现如下效果：\n因为我们没有拷贝官方提供的css样式，所以和官方案例的效果不太一样，但是我们需要的布局格式已经有，具体内容我们有自己的安排。首先我们需要调整整体布局的高度，所以我们需要在\u0026lt;el-container\u0026gt;上添加一些样式，代码如下：\n1 2 \u0026lt;!-- 设置最外层容器高度为700px,在加上一个很细的边框 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 1px solid #eee\u0026#34;\u0026gt; 到此我们布局功能就完成了\n# 4.4.3.3 顶部标题 对于顶部，我们需要实现的效果如下图所示：\n所以我们需要修改顶部的文本内容，并且提供背景色的css样式，具体代码如下：\n1 \u0026lt;el-header style=\u0026#34;font-size:40px;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt;tlias 智能学习辅助系统\u0026lt;/el-header\u0026gt; 此时浏览器打开，呈现效果如下图所示：\n至此，我们的顶部标题就搞定了\n此时整体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 设置最外层容器高度为700px,在加上一个很细的边框 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:40px;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt;tlias 智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt;Aside\u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt;Main\u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; # 4.4.3.4 左侧导航栏 接下来我们来实现左侧导航栏，那么还是在上述布局组件中提供的案例，找到左侧栏的案例，如下图所示：\n所以我们依然只需要搬运代码，然后做简单修改即可。官方提供的导航太多，我们不需要，所以我们需要做删减，在我们的左侧导航栏中粘贴如下代码即可：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;导航一\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;选项1\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;选项2\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; 删减前后对比图：\n然后我们打开浏览器，展示如下内容：\n最后我们只需要替换文字内容即可。\n此时整体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 设置最外层容器高度为700px,在加上一个很细的边框 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:40px;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt;tlias 智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;系统信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;部门管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;员工管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; # 4.4.3.5 右侧核心内容 # 4.4.3.5.1 表格编写 右侧显示的是表单和表格，首先我们先来完成表格的制作，我们同样在官方直接找表格组件，也可以直接通过我们上述容器组件中提供的案例中找到表格相关的案例，如下图所示：\n然后找到表格的代码，复制到我们布局容器的主题区域，template模块代码如下：\n1 2 3 4 5 6 7 8 \u0026lt;el-table :data=\u0026#34;tableData\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;date\u0026#34; label=\u0026#34;日期\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;120\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;address\u0026#34; label=\u0026#34;地址\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; 表格是有数据模型的绑定的，所以我们需要继续拷贝数据模型，代码如下：\n1 2 3 4 5 6 7 8 9 10 data() { return { tableData: [ { date: \u0026#39;2016-05-02\u0026#39;, name: \u0026#39;王小虎\u0026#39;, address: \u0026#39;上海市普陀区金沙江路 1518 弄\u0026#39; } ] } 浏览器打开，呈现如下效果：\n但是这样的表格和数据并不是我们所需要的，所以，接下来我们需要修改表格，添加列，并且修改列名。代码如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;image\u0026#34; label=\u0026#34;图像\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;job\u0026#34; label=\u0026#34;职位\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entrydate\u0026#34; label=\u0026#34;入职日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;最后操作时间\u0026#34; width=\u0026#34;230\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; \u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; 需要注意的是，我们列名的prop属性值得内容并不是乱写的，因为我们将来需要绑定后台的数据的，所以如下图所示：\n并且此时我们data中之前的数据模型就不可用了，所以需要清空数据，设置为空数组，代码 如下：\n1 2 3 4 5 6 7 data() { return { tableData: [ ] } } 此时打开浏览器，呈现如下效果：\n此时整体页面代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 设置最外层容器高度为700px,在加上一个很细的边框 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:40px;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt;tlias 智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;系统信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;部门管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;员工管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;image\u0026#34; label=\u0026#34;图像\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;job\u0026#34; label=\u0026#34;职位\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entrydate\u0026#34; label=\u0026#34;入职日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;最后操作时间\u0026#34; width=\u0026#34;230\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; \u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { tableData: [ ] } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; # 4.4.3.5.2 表单编写 在表格的上方，还需要如下图所示的表单：\n所以接下来我们需要去ElementUI官网，在表单组件中找到与之类似的示例，加以修改从而打成我们希望的效果，官方示例如下图所示：\n所以我们直接拷贝代码主体区域的table组件的上方即可，并且我们需要修改数据绑定的的变量名，最终代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- 表单 --\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;searchForm\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;姓名\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;searchForm.name\u0026#34; placeholder=\u0026#34;姓名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;searchForm.gender\u0026#34; placeholder=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;男\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;女\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; 代码修改前后对比图：\n既然我们表单使用v-model进行数据的双向绑定了，所以我们紧接着需要在data中定义searchForm的数据模型，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 data() { return { tableData: [ ], searchForm:{ name:\u0026#39;\u0026#39;, gender:\u0026#39;\u0026#39; } } } 而且，表单的提交按钮，绑定了onSubmit函数，所以我们还需要在methods中定义onSubmit函数，代码如下：\n注意的是methods属性需要和data属性同级\n1 2 3 4 5 methods:{ onSubmit:function(){ console.log(this.searchForm); } } 浏览器打开如图所示：\n可以发现我们还缺少一个时间，所以可以从elementUI官网找到日期组件，如下图所示：\n参考官方代码，然后在我们之前的表单中添加一个日期表单，具体代码如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;入职日期\u0026#34;\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;searchForm.entrydate\u0026#34; type=\u0026#34;daterange\u0026#34; range-separator=\u0026#34;至\u0026#34; start-placeholder=\u0026#34;开始日期\u0026#34; end-placeholder=\u0026#34;结束日期\u0026#34;\u0026gt; \u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-form-item\u0026gt; 我们添加了双向绑定，所以我们需要在data的searchForm中定义出来，需要注意的是这个日期包含2个值，所以我们定义为数组，代码如下：\n1 2 3 4 5 searchForm:{ name:\u0026#39;\u0026#39;, gender:\u0026#39;\u0026#39;, entrydate:[] } 此时我们打开浏览器，填写表单，并且点击查询按钮，查看浏览器控制台，可以看到表单的内容，效果如下图所示：\n此时完整代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 设置最外层容器高度为700px,在加上一个很细的边框 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:40px;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt;tlias 智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;系统信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;部门管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;员工管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;!-- 表单 --\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;searchForm\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;姓名\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;searchForm.name\u0026#34; placeholder=\u0026#34;姓名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;searchForm.gender\u0026#34; placeholder=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;男\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;女\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;入职日期\u0026#34;\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;searchForm.entrydate\u0026#34; type=\u0026#34;daterange\u0026#34; range-separator=\u0026#34;至\u0026#34; start-placeholder=\u0026#34;开始日期\u0026#34; end-placeholder=\u0026#34;结束日期\u0026#34;\u0026gt; \u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;image\u0026#34; label=\u0026#34;图像\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;job\u0026#34; label=\u0026#34;职位\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entrydate\u0026#34; label=\u0026#34;入职日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;最后操作时间\u0026#34; width=\u0026#34;230\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; \u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { tableData: [ ], searchForm:{ name:\u0026#39;\u0026#39;, gender:\u0026#39;\u0026#39;, entrydate:[] } } }, methods:{ onSubmit:function(){ console.log(this.searchForm); } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; # 4.4.3.5.3 分页工具栏 分页条我们之前做过，所以我们直接找到之前的案例，复制即可，代码如下：\n其中template模块代码如下：\n1 2 3 4 5 6 7 8 \u0026lt;!-- Pagination分页 --\u0026gt; \u0026lt;el-pagination @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; background layout=\u0026#34;sizes,prev, pager, next,jumper,total\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; 同时methods中需要声明2个函数，代码如下：\n1 2 3 4 5 6 handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } 此时打开浏览器，效果如下图所示：\n此时整体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 设置最外层容器高度为700px,在加上一个很细的边框 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:40px;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt;tlias 智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;200px\u0026#34;\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;系统信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;部门管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;员工管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;!-- 表单 --\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;searchForm\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;姓名\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;searchForm.name\u0026#34; placeholder=\u0026#34;姓名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;searchForm.gender\u0026#34; placeholder=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;男\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;女\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;入职日期\u0026#34;\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;searchForm.entrydate\u0026#34; type=\u0026#34;daterange\u0026#34; range-separator=\u0026#34;至\u0026#34; start-placeholder=\u0026#34;开始日期\u0026#34; end-placeholder=\u0026#34;结束日期\u0026#34;\u0026gt; \u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;image\u0026#34; label=\u0026#34;图像\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;job\u0026#34; label=\u0026#34;职位\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entrydate\u0026#34; label=\u0026#34;入职日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;最后操作时间\u0026#34; width=\u0026#34;230\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; \u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;!-- Pagination分页 --\u0026gt; \u0026lt;el-pagination @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; background layout=\u0026#34;sizes,prev, pager, next,jumper,total\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { tableData: [ ], searchForm:{ name:\u0026#39;\u0026#39;, gender:\u0026#39;\u0026#39;, entrydate:[] } } }, methods:{ onSubmit:function(){ console.log(this.searchForm); }, handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; # 4.4.3.6 异步数据加载 # 4.4.3.6.1 异步加载数据 对于案例，我们只差最后的数据了，而数据的mock地址已经提供：http://yapi.smart-xwork.cn/mock/169327/emp/list\n我们最后要做的就是异步加载数据，所以我们需要使用axios发送ajax请求。\n在vue项目中，对于axios的使用，分为如下2步：\n安装axios: npm install axios 需要使用axios时，导入axios: import axios \u0026lsquo;axios\u0026rsquo; 接下来我们先来到项目的执行终端，然后输入命令，安装axios，具体操作如下图所示：\n然后重启项目，来到我们的EmpView.vue组件页面，通过import命令导入axios，代码如下：\n1 import axios \u0026#39;axios\u0026#39;; 那么我们什么时候发送axios请求呢？页面加载完成，自动加载，所以可以使用之前的mounted钩子函数，并且我们需要将得到的员工数据要展示到表格，所以数据需要赋值给数据模型tableData，所以我们编写如下代码：\n1 2 3 4 5 6 mounted(){ axios.get(\u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34;) .then(resp=\u0026gt;{ this.tableData=resp.data.data; //响应数据赋值给数据模型 }); } 此时浏览器打开，呈现如下效果：\n但是很明显，性别和图片的内容显示不正确，所以我们需要修复。\n# 4.4.3.6.2 性别内容展示修复 首先我们来到ElementUI提供的表格组件，找到如下示例：\n我们仔细对比效果和功能实现代码，发现其中涉及2个非常重要的点：\n\u0026lt;template\u0026gt; : 用于自定义列的内容 slot-scope: 通过属性的row获取当前行的数据 所以接下来，我们可以通过上述的标签自定义列的内容即可，修改性别列的内容代码如下：\n1 2 3 4 5 \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; {{scope.row.gender==1?\u0026#34;男\u0026#34;:\u0026#34;女\u0026#34;}} \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; 此时打开浏览器，效果如下图所示：性别一列的值修复成功\n# 4.4.3.6.3 图片内容展示修复 图片内容的修复和上述一致，需要借助\u0026lt;template\u0026gt;标签自定义列的内容，需要需要展示图片，直接借助\u0026lt;img\u0026gt;标签即可，并且需要设置图片的宽度和高度，所以直接修改图片列的代码如下：\n1 2 3 4 5 \u0026lt;el-table-column prop=\u0026#34;image\u0026#34; label=\u0026#34;图像\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;scope.row.image\u0026#34; width=\u0026#34;100px\u0026#34; height=\u0026#34;70px\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; 此时回到浏览器，效果如下图所示：图片展示修复成功\n此时整个案例完整，其完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 设置最外层容器高度为700px,在加上一个很细的边框 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:40px;background-color: rgb(238, 241, 246)\u0026#34;\u0026gt;tlias 智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;el-aside width=\u0026#34;230px\u0026#34; style=\u0026#34;border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;系统信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt;部门管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt;员工管理\u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;!-- 表单 --\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;searchForm\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;姓名\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;searchForm.name\u0026#34; placeholder=\u0026#34;姓名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;searchForm.gender\u0026#34; placeholder=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;男\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;女\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;入职日期\u0026#34;\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;searchForm.entrydate\u0026#34; type=\u0026#34;daterange\u0026#34; range-separator=\u0026#34;至\u0026#34; start-placeholder=\u0026#34;开始日期\u0026#34; end-placeholder=\u0026#34;结束日期\u0026#34;\u0026gt; \u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34;\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;image\u0026#34; label=\u0026#34;图像\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;scope.row.image\u0026#34; width=\u0026#34;100px\u0026#34; height=\u0026#34;70px\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; {{scope.row.gender==1?\u0026#34;男\u0026#34;:\u0026#34;女\u0026#34;}} \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;job\u0026#34; label=\u0026#34;职位\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entrydate\u0026#34; label=\u0026#34;入职日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;最后操作时间\u0026#34; width=\u0026#34;230\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34; \u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;!-- Pagination分页 --\u0026gt; \u0026lt;el-pagination @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; background layout=\u0026#34;sizes,prev, pager, next,jumper,total\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt; \u0026lt;/el-pagination\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import axios \u0026#39;axios\u0026#39; export default { data() { return { tableData: [ ], searchForm:{ name:\u0026#39;\u0026#39;, gender:\u0026#39;\u0026#39;, entrydate:[] } } }, methods:{ onSubmit:function(){ console.log(this.searchForm); }, handleSizeChange(val) { console.log(`每页 ${val} 条`); }, handleCurrentChange(val) { console.log(`当前页: ${val}`); } }, mounted(){ axios.get(\u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34;) .then(resp=\u0026gt;{ this.tableData=resp.data.data; }); } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; # 5 Vue路由 # 5.1 路由介绍 将资料里的代码/vue-project(路由)/vue-project/src/views/tlias/DeptView.vue拷贝到我们当前EmpView.vue同级，其结构如下：\n此时我们希望基于4.4案例中的功能，实现点击侧边栏的部门管理，显示部门管理的信息，点击员工管理，显示员工管理的信息，效果如下图所示：\n这就需要借助我们的vue的路由功能了。\n前端路由：URL中的hash(#号之后的内容）与组件之间的对应关系，如下图所示：\n当我们点击左侧导航栏时，浏览器的地址栏会发生变化，路由自动更新显示与url所对应的vue组件。\n而我们vue官方提供了路由插件Vue Router,其主要组成如下：\nVueRouter：路由器类，根据路由请求在路由视图中动态渲染选中的组件 \u0026lt;router-link\u0026gt;：请求链接组件，浏览器会解析成\u0026lt;a\u0026gt; \u0026lt;router-view\u0026gt;：动态视图组件，用来渲染展示与路由路径对应的组件 其工作原理如下图所示：\n首先VueRouter根据我们配置的url的hash片段和路由的组件关系去维护一张路由表;\n然后我们页面提供一个\u0026lt;router-link\u0026gt;组件,用户点击，发出路由请求;\n接着我们的VueRouter根据路由请求，在路由表中找到对应的vue组件；\n最后VueRouter会切换\u0026lt;router-view\u0026gt;中的组件，从而进行视图的更新\n# 5.2 路由入门 接下来我们来演示vue的路由功能。\n首先我们需要先安装vue-router插件，可以通过如下命令\n1 npm install vue-router@3.5.1 但是我们不需要安装，因为当初我们再创建项目时，已经勾选了路由功能，已经安装好了。\n然后我们需要在src/router/index.js文件中定义路由表，根据其提供的模板代码进行修改(有两种方式)，最终代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import Vue \u0026#39;vue\u0026#39; import VueRouter \u0026#39;vue-router\u0026#39; Vue.use(VueRouter) const routes = [ { path: \u0026#39;/emp\u0026#39;, //地址hash name: \u0026#39;emp\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/tlias/EmpView.vue\u0026#39;) //对应的vue组件 }, { path: \u0026#39;/dept\u0026#39;, name: \u0026#39;dept\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/tlias/DeptView.vue\u0026#39;) } ] const router = new VueRouter({ routes }) export default router 注意需要去掉没有引用的import模块。\n在main.js中，我们已经引入了router功能，如下图所示：\n路由基本信息配置好了，路由表已经被加载，此时我们还缺少2个东西，就是\u0026lt;router-link\u0026gt;和\u0026lt;router-view\u0026gt;,所以我们需要修改2个页面（EmpView.vue和DeptView.vue）我们左侧栏的2个按钮为router-link,其代码如下：\n1 2 3 4 5 6 \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/dept\u0026#34;\u0026gt;部门管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/emp\u0026#34;\u0026gt;员工管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; 然后我们还需要在内容展示区域即App.vue中定义route-view，作为组件的切换，其App.vue的完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- {{message}} --\u0026gt; \u0026lt;!-- \u0026lt;element-view\u0026gt;\u0026lt;/element-view\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;emp-view\u0026gt;\u0026lt;/emp-view\u0026gt; --\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // import EmpView \u0026#39;./views/tlias/EmpView.vue\u0026#39; // import ElementView \u0026#39;./views/Element/ElementView.vue\u0026#39; export default { components: { }, data(){ return { \u0026#34;message\u0026#34;:\u0026#34;hello world\u0026#34; } } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; 但是我们浏览器打开地址： http://localhost:7000/ ，发现一片空白，因为我们默认的路由路径是/,但是路由配置中没有对应的关系，\n所以我们需要在路由配置中/对应的路由组件，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const routes = [ { path: \u0026#39;/emp\u0026#39;, name: \u0026#39;emp\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/tlias/EmpView.vue\u0026#39;) }, { path: \u0026#39;/dept\u0026#39;, name: \u0026#39;dept\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/tlias/DeptView.vue\u0026#39;) }, { path: \u0026#39;/\u0026#39;, redirect:\u0026#39;/emp\u0026#39; //表示重定向到/emp即可 }, ] 此时我们打开浏览器，访问http://localhost:7000 发现直接访问的是emp的页面，并且能够进行切换了，其具体如下图所示：\n到此我们的路由实现成功。\n# 6 打包部署 我们的前端工程开发好了，但是我们需要发布，那么如何发布呢？主要分为2步：\n前端工程打包 通过nginx服务器发布前端工程 # 6.1 前端工程打包 接下来我们先来对前端工程进行打包\n我们直接通过VS Code的NPM脚本中提供的build按钮来完整，如下图所示，直接点击即可：\n然后会在工程目录下生成一个dist目录，用于存放需要发布的前端资源，如下图所示：\n# 6.2 部署前端工程 # 6.2.1 nginx介绍 nginx: Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强，在各大型互联网公司都有非常广泛的使用。\nniginx在windows中的安装是比较方便的，直接解压即可。所以我们直接将资料中的nginx-1.22.0.zip压缩文件拷贝到无中文的目录下，直接解压即可，如下图所示就是nginx的解压目录以及目录结构说明：\n很明显，我们如果要发布，直接将资源放入到html目录中。\n# 6.2.2 部署 将我们之前打包的前端工程dist目录下得内容拷贝到nginx的html目录下，如下图所示：\n然后我们通过双击nginx下得nginx.exe文件来启动nginx，如下图所示：\nnginx服务器的端口号是80，所以启动成功之后，我们浏览器直接访问http://localhost:80 即可，其中80端口可以省略，其浏览器展示效果如图所示：\n到此，我们的前端工程发布成功。\nPS: 如果80端口被占用，我们需要通过conf/nginx.conf配置文件来修改端口号。如下图所示：\n","date":"2024-04-27T17:44:45+08:00","permalink":"http://localhost:1313/p/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82vue%E5%B7%A5%E7%A8%8Belement%E7%BB%84%E4%BB%B6/","title":"异步请求、vue工程、element组件"},{"content":" # 1 JavaScript html完成了架子，css做了美化，但是网页是死的，我们需要给他注入灵魂，所以接下来我们需要学习JavaScript，这门语言会让我们的页面能够和用户进行交互。\n# 1.1 介绍 通过代码/js效果演示提供资料进行效果演示，通过浏览器打开，我们点击主题5按钮，页面的主题发生了变化，所以js可以让我们的页面更加的智能，让页面和用户进行交互。\n# 1.2 引入方式 同样，js代码也是书写在html中的，那么html中如何引入js代码呢？主要通过下面的2种引入方式：\n**第一种方式：**内部脚本，将JS代码定义在HTML页面中\nJavaScript代码必须位于\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;标签之间 在HTML文档中，可以在任意地方，放置任意数量的\u0026lt;script\u0026gt; 一般会把脚本置于\u0026lt;body\u0026gt;元素的底部，可改善显示速度 例子：\n1 2 3 \u0026lt;script\u0026gt; alert(\u0026#34;Hello JavaScript\u0026#34;) \u0026lt;/script\u0026gt; **第二种方式：**外部脚本，将 JS代码定义在外部 JS文件中，然后引入到 HTML页面中\n外部JS文件中，只包含JS代码，不包含\u0026lt;script\u0026gt;标签 引入外部js的\u0026lt;script\u0026gt;标签，必须是双标签 例子：\n1 \u0026lt;script src=\u0026#34;js/demo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 注意：demo.js中只有js代码，没有\u0026lt;script\u0026gt;标签\n接下来，我们通过VS Code来编写代码，演示html中2种引入js的方式\n第一步：在VS Code中创建名为 10.JS-引入方式.html 的文件\n第二步：按照上述第一种内部脚本的方式引入js，编写如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-引入方式\u0026lt;/title\u0026gt; \u0026lt;!-- 内部脚本 --\u0026gt; \u0026lt;script\u0026gt; alert(\u0026#39;Hello JS\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第三步：浏览器打开效果如图所示：\n第四步：接下来演示外部脚本，注释掉内部脚本，然后在css目录同级创建js目录，然后创建一个名为demo.js的文件：\n第五步：在demo.js中编写如下js内容：\n1 alert(\u0026#39;Hello JS2\u0026#39;); 第六步：注释掉之前的内部脚本代码，添加\u0026lt;script\u0026gt;标签来引入外部demo.js文件,具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-引入方式\u0026lt;/title\u0026gt; \u0026lt;!-- 内部脚本 --\u0026gt; \u0026lt;!-- \u0026lt;script\u0026gt; alert(\u0026#39;Hello JS\u0026#39;); \u0026lt;/script\u0026gt; --\u0026gt; \u0026lt;!-- 外部脚本 --\u0026gt; \u0026lt;script src=\u0026#34;js/demo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第七步：浏览器刷新效果如图：\n# 1.3 基础语法 # 1.3.1 书写语法 掌握了js的引入方式，那么接下来我们需要学习js的书写了，首先需要掌握的是js的书写语法，语法规则如下：\n区分大小写：与 Java 一样，变量名、函数名以及其他一切东西都是区分大小写的\n每行结尾的分号可有可无\n大括号表示代码块\n注释：\n单行注释：// 注释内容\n多行注释：/* 注释内容 */\n我们需要借助js中3钟输出语句，来演示书写语法\napi 描述 window.alert() 警告框 document.write() 在HTML 输出内容 console.log() 写入浏览器控制台 # 1.3.2 变量 书写语法会了，变量是一门编程语言比不可少的，所以接下来我们需要学习js中变量的声明，在js中，变量的声明和java中还是不同的。首先js中主要通过如下3个关键字来声明变量的：\n关键字 解释 var 早期ECMAScript5中用于变量声明的关键字；相当于全局变量 let ECMAScript6中新增的用于变量声明的关键字，相比较var，let只在代码块内生效；相当于局部变量 const 声明常量的，常量一旦声明，不能修改 在js中声明变量还需要注意如下几点：\nJavaScript 是一门弱类型语言，变量可以存放不同类型的值 。 变量名需要遵循如下规则： 组成字符可以是任何字母、数字、下划线（_）或美元符号（$） 数字不能开头 建议使用驼峰命名 接下来我们需要通过VS Code编写代码来演示js中变量的定义\n第一步：在VS Code中创建名为 12.JS-基础语法-变量.html的文件：\n第二步：编写代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-基础语法\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //var定义变量 var a = 10; a = \u0026#34;张三\u0026#34;; alert(a); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 可以看到浏览器弹出张三\n在js中，我们var声明的变量可以接受任何数据类型的值。并且var声明的变量的作用于是全局的，注释掉之前的代码，添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; //var定义变量 // var a = 10; // a = \u0026#34;张三\u0026#34;; // alert(a); //特点1 : 作用域比较大, 全局变量 { var x = 1; } alert(x); \u0026lt;/script\u0026gt; 浏览器照样成功弹出：\n而且var关键字声明的变量可以重复定义，修改代码如下：\n1 2 3 4 5 6 { var x = 1; var x = \u0026#34;A\u0026#34;; } alert(x); 浏览器弹出内容是A\n所以在ECMAScript 6 新增了 let关键字来定义变量，它的用法类似于 var，但是所声明的变量，只在 let关键字所在的代码块内有效，且不允许重复声明。注释掉之前的代码，添加代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;script\u0026gt; //var定义变量 // var a = 10; // a = \u0026#34;张三\u0026#34;; // alert(a); //特点1 : 作用域比较大, 全局变量 //特点2 : 可以重复定义的 // { // var x = 1; // var x = \u0026#34;A\u0026#34;; // } // alert(x); //let : 局部变量 ; 不能重复定义 { let x = 1; } alert(x); \u0026lt;/script\u0026gt; 浏览器打开，f12抓包，来到控制台页面，发现报错，变量没有定义，说明let声明的变量在代码块外不生效\n接着我们使用let重复定义变量，代码修改如下：发现idea直接帮我们报错了，说明let声明的变量不能重复定义\n在ECMAScript6中，还新增了const关键字用来声明常量，但是一旦声明，常量的值是无法更改的。注释之前的内容，添加如下代码：\n1 2 3 const pi = 3.14; pi = 3.15; alert(pi); 浏览器f12抓包，来到控制台页面发现直接报错了，\n# 1.3.3 数据类型和运算符 虽然js是弱数据类型的语言，但是js中也存在数据类型，js中的数据类型分为 ：原始类型 和 引用类型，具体有如下类型\n数据类型 描述 number 数字（整数、小数、NaN(Not a Number)） string 字符串，单双引皆可 boolean 布尔。true，false null 对象为空 undefined 当声明的变量未初始化时，该变量的默认值是 undefined 使用typeof函数可以返回变量的数据类型，接下来我们需要通过书写代码来演示js中的数据类型\n第一步：在VS Code中创建名为13. JS-基础语法-数据类型.html的文件\n第二步：编写如下代码，然后直接挨个观察数据类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-数据类型\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //原始数据类型 alert(typeof 3); //number alert(typeof 3.14); //number alert(typeof \u0026#34;A\u0026#34;); //string alert(typeof \u0026#39;Hello\u0026#39;);//string alert(typeof true); //boolean alert(typeof false);//boolean alert(typeof null); //object var a ; alert(typeof a); //undefined \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 熟悉了js的数据类型了，那么我们需要学习js中的运算法，js中的运算规则绝大多数还是和java中一致的，具体运算符如下：\n运算规则 运算符 算术运算符 + , - , * , / , % , ++ , \u0026ndash; 赋值运算符 = , += , -= , *= , /= , %= 比较运算符 \u0026gt; , \u0026lt; , \u0026gt;= , \u0026lt;= , != , == , === 注意 == 会进行类型转换，=== 不会进行类型转换 逻辑运算符 \u0026amp;\u0026amp; , || , ! 三元运算符 条件表达式 ? true_value: false_value 接下来我们通过代码来演示js中的运算法，主要记忆js中和java中不一致的地方\n第一步：在VS Code中创建名为14. JS-基础语法-运算符.html的文件\n第二步：编写代码\n在js中，绝大多数的运算规则和java中是保持一致的，但是js中的==和===是有区别的。\n==：只比较值是否相等，不区分数据类型，哪怕类型不一致，==也会自动转换类型进行值得比较 ===：不光比较值，还要比较类型，如果类型不一致，直接返回false 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-运算符\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var age = 20; var _age = \u0026#34;20\u0026#34;; var $age = 20; alert(age == _age);//true ，只比较值 alert(age === _age);//false ，类型不一样 alert(age === $age);//true ，类型一样，值一样 \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 在js中，虽然不区分数据类型，但是有时候涉及到数值计算，还是需要进行类型转换的，js中可以通过parseInt()函数来进行将其他类型转换成数值类型。注释之前的代码，添加代码如下：\n1 2 3 4 // 类型转换 - 其他类型转为数字 alert(parseInt(\u0026#34;12\u0026#34;)); //12 alert(parseInt(\u0026#34;12A45\u0026#34;)); //12 alert(parseInt(\u0026#34;A45\u0026#34;));//NaN (not a number) 除此之外，在js中，还有非常重要的一点是：0,null,undefined,\u0026quot;\u0026quot;,NaN理解成false,反之理解成true。注释掉之前的代码，添加如下代码：\n1 2 3 if(0){ //false alert(\u0026#34;0 转换为false\u0026#34;); } 浏览器刷新页面，发现没有任何弹框，因为0理解成false，所以条件不成立。注释掉上述代码，添加如下代码：\n1 2 3 if(1){ //true alert(\u0026#34;除0和NaN其他数字都转为 true\u0026#34;); } 浏览器刷新，因为1理解成true，条件成立，所以浏览器效果如下；\n其他情况可以一一演示，完整演示代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // if(0){ //false // alert(\u0026#34;0 转换为false\u0026#34;); // } // if(NaN){//false // alert(\u0026#34;NaN 转换为false\u0026#34;); // } if(1){ //true alert(\u0026#34;除0和NaN其他数字都转为 true\u0026#34;); } // if(\u0026#34;\u0026#34;){ //false // alert(\u0026#34;空字符串为 false, 其他都是true\u0026#34;); // } // if(null){ //false // alert(\u0026#34;null 转化为false\u0026#34;); // } // if(undefined){ //false // alert(\u0026#34;undefined 转化为false\u0026#34;); // } 流程控制语句if，switch，for等和java保持一致，此处不再演示\n**需要注意的是：**在js中，0,null,undefined,\u0026quot;\u0026quot;,NaN理解成false,反之理解成true\n# 1.4 函数 在java中我们为了提高代码的复用性，可以使用方法。同样，在JavaScript中可以使用函数来完成相同的事情。JavaScript中的函数被设计为执行特定任务的代码块，通过关键字function来定义。接下来我们学习一下JavaScript中定义函数的2种语法\n# 1.4.1 第一种定义格式 第一种定义格式如下：\n1 2 3 function 函数名(参数1,参数2..){ 要执行的代码 } 因为JavaScript是弱数据类型的语言，所以有如下几点需要注意：\n形式参数不需要声明类型，并且JavaScript中不管什么类型都是let或者var去声明，加上也没有意义。 返回值也不需要声明类型，直接return即可 如下示例：\n1 2 3 function add(a, b){ return a + b; } 接下来我们需要在VS Code中编写代码来演示\n第一步：新建名为js的文件夹，创建名为01. JS-函数的html文件，然后在\u0026lt;script\u0026gt;中定义上述示例的函数：\n1 2 3 4 5 \u0026lt;script\u0026gt; function add(a,b){ return a + b; } \u0026lt;/script\u0026gt; 但是上述只是定义函数，**函数需要被调用才能执行！**所以接下来我们需要调用函数\n第二步：因为定义的add函数有返回值，所以我们可以接受返回值，并且输出到浏览器上，添加如下代码：\n1 2 let result = add(10,20); alert(result); 查看浏览器运行结果：浏览器弹框内容如下图所示：\n# 1.4.2 第二种定义格式 第二种可以通过var去定义函数的名字，具体格式如下：\n1 2 3 var functionName = function (参数1,参数2..){ //要执行的代码 } 接下来我们按照上述的格式，修改代码如下：只需要将第一种定义方式注释掉，替换成第二种定义方式即可，函数的调用不变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; //定义函数-1 // function add(a,b){ // return a + b; // } //定义函数-2 var add = function(a,b){ return a + b; } //函数调用 var result = add(10,20); alert(result); \u0026lt;/script\u0026gt; 浏览器弹框效果和上述一致\n我们在调用add函数时，再添加2个参数，修改代码如下：\n1 var result = add(10,20,30,40); 浏览器打开，发现没有错误，并且依然弹出30，这是为什么呢？\n因为在JavaScript中，函数的调用只需要名称正确即可，参数列表不管的。如上述案例，10传递给了变量a，20传递给了变量b,而30和40没有变量接受，但是不影响函数的正常调用。\n# 1.5 JavaScript对象 JavaScript中的对象有很多，主要可以分为如下3大类，我们可以打开W3school在线学习文档，来到首页，在左侧栏找到浏览器脚本下的JavaScript，如下图所示：\n然后进入到如下界面，点击右侧的参考书\n然后进入到如下页面，此页面列举出了JavaScript中的所有对象\n可以大体分页3大类：\n第一类：基本对象,我们主要学习Array和JSON和String\n第二类：BOM对象,主要是和浏览器相关的几个对象\n第三类：DOM对象，JavaScript中将html的每一个标签都封装成一个对象\n我们先来学习基本对象种的Array对象\n# 1.5.1 基本对象 # 1.5.1.1 Array对象 # 语法格式 Array对象时用来定义数组的。常用语法格式有如下2种：\n方式1：\n1 var 变量名 = new Array(元素列表); 例如：\n1 var arr = new Array(1,2,3,4); //1,2,3,4 是存储在数组中的数据（元素） 方式2：\n1 var 变量名 = [ 元素列表 ]; 例如：\n1 var arr = [1,2,3,4]; //1,2,3,4 是存储在数组中的数据（元素） 数组定义好了，那么我们该如何获取数组中的值呢？和java中一样，需要通过索引来获取数组中的值。语法如下：\n1 arr[索引] = 值; 接下来，我们在VS Code中创建名为02. JS-对象-Array.html的文件，按照上述的语法定义数组，并且通过索引来获取数组中的值。\n1 2 3 4 5 6 7 8 \u0026lt;script\u0026gt; //定义数组 var arr = new Array(1,2,3,4); var arr = [1,2,3,4]; //获取数组中的值，索引从0开始计数 console.log(arr[0]); console.log(arr[1]); \u0026lt;/script\u0026gt; 浏览器控制台观察的效果如下：输出1和2\n# 特点 与java中不一样的是，JavaScript中数组相当于java中的集合，数组的长度是可以变化的。而且JavaScript是弱数据类型的语言，所以数组中可以存储任意数据类型的值。接下来我们通过代码来演示上述特点。\n注释掉之前的代码，添加如下代码：\n1 2 3 4 5 6 7 //特点: 长度可变 类型可变 var arr = [1,2,3,4]; arr[10] = 50; console.log(arr[10]); console.log(arr[9]); console.log(arr[8]); 上述代码定义的arr变量中，数组的长度是4，但是我们直接再索引10的位置直接添加了数据10，并且输出索引为10的位置的元素，浏览器控制台数据结果如下：\n因为索引8和9的位置没有值，所以输出内容undefined,当然，我们也可以给数组添加其他类型的值，添加代码如下：注释掉之前控制台输出的代码\n1 2 3 4 5 6 7 8 9 10 11 12 //特点: 长度可变 类型可变 var arr = [1,2,3,4]; arr[10] = 50; // console.log(arr[10]); // console.log(arr[9]); // console.log(arr[8]); arr[9] = \u0026#34;A\u0026#34;; arr[8] = true; console.log(arr); 浏览器控制台输出结果如下：\n# 属性和方法 Array作为一个对象，那么对象是有属性和方法的，所以接下来我们介绍一下Array对象的属性和方法\n官方文档中提供了Array的很多属性和方法，但是我们只学习常用的属性和方法，如下图所示：\n属性：\n属性 描述 length 设置或返回数组中元素的数量。 方法：\n方法方法 描述 forEach() 遍历数组中的每个有值得元素，并调用一次传入的函数 push() 将新元素添加到数组的末尾，并返回新的长度 splice() 从数组中删除元素 length属性：\nlength属性可以用来获取数组的长度，所以我们可以借助这个属性，来遍历数组中的元素，添加如下代码：\n1 2 3 4 5 var arr = [1,2,3,4]; arr[10] = 50; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); } 浏览器控制台输出结果如图所示：\nforEach()函数\n首先我们学习forEach()方法，顾名思义，这是用来遍历的，那么遍历做什么事呢？所以这个方法的参数，需要传递一个函数，而且这个函数接受一个参数，就是遍历时数组的值。修改之前的遍历代码如下：\n1 2 3 4 //e是形参，接受的是数组遍历时的值 arr.forEach(function(e){ console.log(e); }) 当然了，在ES6中，引入箭头函数的写法，语法类似java中lambda表达式，修改上述代码如下：\n1 2 3 arr.forEach((e) =\u0026gt; { console.log(e); }) 浏览器输出结果如下：注意的是，没有元素的内容是不会输出的，因为forEach只会遍历有值的元素\npush()函数\npush()函数是用于向数组的末尾添加元素的，其中函数的参数就是需要添加的元素，编写如下代码：向数组的末尾添加3个元素\n1 2 3 //push: 添加元素到数组末尾 arr.push(7,8,9); console.log(arr); 浏览器输出结果如下：\nsplice()函数\nsplice()函数用来数组中的元素，函数中填入2个参数。\n参数1：表示从哪个索引位置删除\n参数2：表示删除元素的个数\n如下代码表示：从索引2的位置开始删，删除2个元素\n1 2 3 //splice: 删除元素 arr.splice(2,2); console.log(arr); 浏览器执行效果如下：元素3和4被删除了，元素3是索引2\nArray数组的完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-对象-Array\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义数组 // var arr = new Array(1,2,3,4); // var arr = [1,2,3,4]; // console.log(arr[0]); // console.log(arr[1]); //特点: 长度可变 类型可变 // var arr = [1,2,3,4]; // arr[10] = 50; // console.log(arr[10]); // console.log(arr[9]); // console.log(arr[8]); // arr[9] = \u0026#34;A\u0026#34;; // arr[8] = true; // console.log(arr); var arr = [1,2,3,4]; arr[10] = 50; // for (let i = 0; i \u0026lt; arr.length; i++) { // console.log(arr[i]); // } // console.log(\u0026#34;==================\u0026#34;); //forEach: 遍历数组中有值的元素 // arr.forEach(function(e){ // console.log(e); // }) // //ES6 箭头函数: (...) =\u0026gt; {...} -- 简化函数定义 // arr.forEach((e) =\u0026gt; { // console.log(e); // }) //push: 添加元素到数组末尾 // arr.push(7,8,9); // console.log(arr); //splice: 删除元素 arr.splice(2,2); console.log(arr); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 1.5.1.2 String对象 # 语法格式 String对象的创建方式有2种：\n方式1：\n1 var 变量名 = new String(\u0026#34;…\u0026#34;) ; //方式一 例如：\n1 var str = new String(\u0026#34;Hello String\u0026#34;); 方式2：\n1 var 变量名 = \u0026#34;…\u0026#34; ; //方式二 例如：\n1 var str = \u0026#39;Hello String\u0026#39;; 按照上述的格式，在VS Code中创建为名03. JS-对象-String.html的文件，编写代码如下：\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; //创建字符串对象 //var str = new String(\u0026#34;Hello String\u0026#34;); var str = \u0026#34; Hello String \u0026#34;; console.log(str); \u0026lt;/script\u0026gt; 浏览器控制台输出结果如下：\n# 属性和方法 String对象也提供了一些常用的属性和方法，如下表格所示：\n属性：\n属性 描述 length 字符串的长度。 方法：\n方法 描述 charAt() 返回在指定位置的字符。 indexOf() 检索字符串。 trim() 去除字符串两边的空格 substring() 提取字符串中两个指定的索引号之间的字符。 length属性：\nlength属性可以用于返回字符串的长度，添加如下代码：\n1 2 //length console.log(str.length); charAt()函数：\ncharAt()函数用于返回在指定索引位置的字符，函数的参数就是索引。添加如下代码：\n1 console.log(str.charAt(4)); indexOf()函数\nindexOf()函数用于检索指定内容在字符串中的索引位置的，返回值是索引，参数是指定的内容。添加如下代码：\n1 console.log(str.indexOf(\u0026#34;lo\u0026#34;)); trim()函数\ntrim()函数用于去除字符串两边的空格的。添加如下代码：\n1 2 var s = str.trim(); console.log(s.length); substring()函数\nsubstring()函数用于截取字符串的，函数有2个参数。\n参数1：表示从那个索引位置开始截取。包含\n参数2：表示到那个索引位置结束。不包含\n1 console.log(s.substring(0,5)); 整体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-对象-String\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //创建字符串对象 //var str = new String(\u0026#34;Hello String\u0026#34;); var str = \u0026#34; Hello String \u0026#34;; console.log(str); //length console.log(str.length); //charAt console.log(str.charAt(4)); //indexOf console.log(str.indexOf(\u0026#34;lo\u0026#34;)); //trim var s = str.trim(); console.log(s.length); //substring(start,end) --- 开始索引, 结束索引 (含头不含尾) console.log(s.substring(0,5)); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 浏览器执行效果如图所示：\n# 1.5.1.3 JSON对象 # 自定义对象 在学习JSON对象之前，先了解一下自定义对象\n在 JavaScript 中自定义对象特别简单，其语法格式如下：\n1 2 3 4 5 6 var 对象名 = { 属性名1: 属性值1, 属性名2: 属性值2, 属性名3: 属性值3, 函数名称: function(形参列表){} }; 我们可以通过如下语法调用属性：\n1 对象名.属性名 通过如下语法调用函数：\n1 对象名.函数名() 接下来，我们再VS Code中创建名为04. JS-对象-JSON.html的文件演示自定义对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; //自定义对象 var user = { name: \u0026#34;Tom\u0026#34;, age: 10, gender: \u0026#34;male\u0026#34;, eat: function(){ console.log(\u0026#34;用膳~\u0026#34;); } } console.log(user.name); user.eat(); \u0026lt;script\u0026gt; 浏览器控制台结果如下：\n其中上述函数定义的语法可以简化成如下格式：\n1 2 3 4 5 6 7 8 9 10 11 var user = { name: \u0026#34;Tom\u0026#34;, age: 10, gender: \u0026#34;male\u0026#34;, // eat: function(){ // console.log(\u0026#34;用膳~\u0026#34;); // } eat(){ console.log(\u0026#34;用膳~\u0026#34;); } } # json对象 JSON对象：JavaScript Object Notation，JavaScript对象标记法。是通过JavaScript标记法书写的文本。其格式如下：\n1 2 3 4 5 { \u0026#34;key\u0026#34;:value, \u0026#34;key\u0026#34;:value, \u0026#34;key\u0026#34;:value } 其中，key必须使用引号并且是双引号标记，value可以是任意数据类型。\n例如我们可以直接百度搜索“json在线解析”，随便挑一个进入，然后编写内容如下：\n1 2 3 { \u0026#34;name\u0026#34;: \u0026#34;李传播\u0026#34; } 但是当我们将双引号切换成单引号，再次校验，则报错，如下图所示：\n那么json这种数据格式的文本到底应用在企业开发的什么地方呢？\u0026ndash; 经常用来作为前后台交互的数据载体\n如下图所示：前后台交互时，我们需要传输数据，但是java中的对象我们该怎么去描述呢？我们可以使用如图所示的xml格式，可以清晰的描述java中需要传递给前端的java对象。\n但是xml格式存在如下问题：\n标签需要编写双份，占用带宽，浪费资源 解析繁琐 所以我们可以使用json来替代，如下图所示：\n接下来我们通过代码来演示json对象：注释掉之前的代码，编写代码如下：\n1 2 var jsonstr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;addr\u0026#34;:[\u0026#34;北京\u0026#34;,\u0026#34;上海\u0026#34;,\u0026#34;西安\u0026#34;]}\u0026#39;; alert(jsonstr.name); 浏览器输出结果如下：\n为什么呢？**因为上述是一个json字符串，不是json对象，所以我们需要借助如下函数来进行json字符串和json对象的转换。**添加代码如下：\n1 2 var obj = JSON.parse(jsonstr); alert(obj.name); 此时浏览器输出结果如下：\n当然了，我们也可以通过如下函数将json对象再次转换成json字符串。添加如下代码：\n1 alert(JSON.stringify(obj)); 浏览器输出结果如图所示：\n整体全部代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-对象-JSON\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //自定义对象 // var user = { // name: \u0026#34;Tom\u0026#34;, // age: 10, // gender: \u0026#34;male\u0026#34;, // // eat: function(){ // // console.log(\u0026#34;用膳~\u0026#34;); // // } // eat(){ // console.log(\u0026#34;用膳~\u0026#34;); // } // } // console.log(user.name); // user.eat(); // //定义json var jsonstr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;:18, \u0026#34;addr\u0026#34;:[\u0026#34;北京\u0026#34;,\u0026#34;上海\u0026#34;,\u0026#34;西安\u0026#34;]}\u0026#39;; //alert(jsonstr.name); // //json字符串--js对象 var obj = JSON.parse(jsonstr); //alert(obj.name); // //js对象--json字符串 alert(JSON.stringify(obj)); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 1.5.2 BOM对象 接下来我们学习BOM对象，BOM的全称是Browser Object Model,翻译过来是浏览器对象模型。也就是JavaScript将浏览器的各个组成部分封装成了对象。我们要操作浏览器的部分功能，可以通过操作BOM对象的相关属性或者函数来完成。例如：我们想要将浏览器的地址改为http://www.baidu.com,我们就可以通过BOM中提供的location对象的href属性来完成，代码如下：location.href='http://www.baidu.com'\nBOM中提供了如下5个对象：\n对象名称 描述 Window 浏览器窗口对象 Navigator 浏览器对象 Screen 屏幕对象 History 历史记录对象 Location d地址栏对象 上述5个对象与浏览器各组成对应的关系如下图所示：\n对于上述5个对象，我们重点学习的是Window对象、Location对象这2个。\n# 1.5.2.1 Window对象 window对象指的是浏览器窗口对象，是JavaScript的全部对象，所以对于window对象，我们可以直接使用，并且对于window对象的方法和属性，我们可以省略window.例如：我们之前学习的alert()函数其实是属于window对象的,其完整的代码如下：\n1 window.alert(\u0026#39;hello\u0026#39;); 其可以省略window. 所以可以简写成\n1 alert(\u0026#39;hello\u0026#39;) 所以对于window对象的属性和方法，我们都是采用简写的方式。window提供了很多属性和方法，下表列出了常用属性和方法\nwindow对象提供了获取其他BOM对象的属性：\n属性 描述 history 用于获取history对象 location 用于获取location对象 Navigator 用于获取Navigator对象 Screen 用于获取Screen对象 也就是说我们要使用location对象，只需要通过代码window.location或者简写location即可使用\nwindow也提供了一些常用的函数，如下表格所示：\n函数 描述 alert() 显示带有一段消息和一个确认按钮的警告框。 comfirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 接下来，我们通过VS Code中创建名为05. JS-对象-BOM.html文件来编写代码来演示上述函数：\nalert()函数：弹出警告框，函数的内容就是警告框的内容\n1 2 3 4 5 \u0026lt;script\u0026gt; //window对象是全局对象，window对象的属性和方法在调用时可以省略window. window.alert(\u0026#34;Hello BOM\u0026#34;); alert(\u0026#34;Hello BOM Window\u0026#34;); \u0026lt;/script\u0026gt; 浏览器打开，依次弹框，此处只截图一张\nconfirm()函数：弹出确认框，并且提供用户2个按钮，分别是确认和取消。\n添加如下代码：\n1 confirm(\u0026#34;您确认删除该记录吗?\u0026#34;); 浏览器打开效果如图所示：\n但是我们怎么知道用户点击了确认还是取消呢？所以这个函数有一个返回值，当用户点击确认时，返回true，点击取消时，返回false。我们根据返回值来决定是否执行后续操作。修改代码如下：再次运行，可以查看返回值true或者false\n1 2 var flag = confirm(\u0026#34;您确认删除该记录吗?\u0026#34;); alert(flag); setInterval(fn,毫秒值)：定时器，用于周期性的执行某个功能，并且是循环执行。该函数需要传递2个参数：\nfn:函数，需要周期性执行的功能代码\n毫秒值：间隔时间\n注释掉之前的代码，添加代码如下：\n1 2 3 4 5 6 //定时器 - setInterval -- 周期性的执行某一个函数 var i = 0; setInterval(function(){ i++; console.log(\u0026#34;定时器执行了\u0026#34;+i+\u0026#34;次\u0026#34;); },2000); 刷新页面，浏览器每个一段时间都会在控制台输出，结果如下：\nsetTimeout(fn,毫秒值) ：定时器，只会在一段时间后执行一次功能。参数和上述setInterval一致\n注释掉之前的代码，添加代码如下：\n1 2 3 4 //定时器 - setTimeout -- 延迟指定时间执行一次 setTimeout(function(){ alert(\u0026#34;JS\u0026#34;); },3000); 浏览器打开，3s后弹框，关闭弹框，发现再也不会弹框了。\n# 1.5.2.2 Location对象 location是指代浏览器的地址栏对象，对于这个对象，我们常用的是href属性，用于获取或者设置浏览器的地址信息，添加如下代码：\n1 2 3 4 //获取浏览器地址栏信息 alert(location.href); //设置浏览器地址栏信息 location.href = \u0026#34;https://www.itcast.cn\u0026#34;; 浏览器效果如下：首先弹框展示浏览器地址栏信息，\n然后点击确定后，因为我们设置了地址栏信息，所以浏览器跳转到传智首页\n完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-对象-BOM\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //获取 // window.alert(\u0026#34;Hello BOM\u0026#34;); // alert(\u0026#34;Hello BOM Window\u0026#34;); //方法 //confirm - 对话框 -- 确认: true , 取消: false // var flag = confirm(\u0026#34;您确认删除该记录吗?\u0026#34;); // alert(flag); //定时器 - setInterval -- 周期性的执行某一个函数 // var i = 0; // setInterval(function(){ // i++; // console.log(\u0026#34;定时器执行了\u0026#34;+i+\u0026#34;次\u0026#34;); // },2000); //定时器 - setTimeout -- 延迟指定时间执行一次 // setTimeout(function(){ // alert(\u0026#34;JS\u0026#34;); // },3000); //location alert(location.href); location.href = \u0026#34;https://www.itcast.cn\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 1.5.3 DOM对象 # 1.5.3.1 DOM介绍 DOM：Document Object Model 文档对象模型。也就是 JavaScript 将 HTML 文档的各个组成部分封装为对象。\nDOM 其实我们并不陌生，之前在学习 XML 就接触过，只不过 XML 文档中的标签需要我们写代码解析，而 HTML 文档是浏览器解析。封装的对象分为\nDocument：整个文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment：注释对象 如下图，左边是 HTML 文档内容，右边是 DOM 树\n那么我们学习DOM技术有什么用呢？主要作用如下：\n改变 HTML 元素的内容 改变 HTML 元素的样式（CSS） 对 HTML DOM 事件作出反应 添加和删除 HTML 元素 总而达到动态改变页面效果目的，具体我们可以查看代码中提供的06. JS-对象-DOM-演示.html来体会DOM的效果。\n# 1.5.3.2 获取DOM对象 我们知道DOM的作用是通过修改HTML元素的内容和样式等来实现页面的各种动态效果，但是我们要操作DOM对象的前提是先获取元素对象，然后才能操作。所以学习DOM,主要的核心就是学习如下2点：\n如何获取DOM中的元素对象（Element对象 ，也就是标签） 如何操作Element对象的属性,也就是标签的属性。 接下来我们先来学习如何获取DOM中的元素对象。\nHTML中的Element对象可以通过Document对象获取，而Document对象是通过window对象获取的。document对象提供的用于获取Element元素对象的api如下表所示：\n函数 描述 document.getElementById() 根据id属性值获取，返回单个Element对象 document.getElementsByTagName() 根据标签名称获取，返回Element对象数组 document.getElementsByName() 根据name属性值获取，返回Element对象数组 document.getElementsByClassName() 根据class属性值获取，返回Element对象数组 接下来我们通过VS Code中创建名为07. JS-对象-DOM-获取元素.html的文件来演示上述api，首先在准备如下页面代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-对象-DOM\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;h1\u0026#34; src=\u0026#34;img/off.gif\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;传智教育\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;黑马程序员\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 电影 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 旅游 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 游戏 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; document.getElementById()： 根据标签的id属性获取标签对象，id是唯一的，所以获取到是单个标签对象。\n添加如下代码：\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; //1. 获取Element元素 //1.1 获取元素-根据ID获取 var img = document.getElementById(\u0026#39;h1\u0026#39;); alert(img); \u0026lt;/script\u0026gt; 浏览器打开，效果如图所示：从弹出的结果能够看出，这是一个图片标签对象\ndocument.getElementsByTagName() : 根据标签的名字获取标签对象，同名的标签有很多，所以返回值是数组。\n添加如下代码:\n1 2 3 4 5 //1.2 获取元素-根据标签获取 - div var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { alert(divs[i]); } 浏览器输出2次如下所示的弹框\ndocument.getElementsByName() ：根据标签的name的属性值获取标签对象，name属性值可以重复，所以返回值是一个数组。\n添加如下代码：\n1 2 3 4 5 //1.3 获取元素-根据name属性获取 var ins = document.getElementsByName(\u0026#39;hobby\u0026#39;); for (let i = 0; i \u0026lt; ins.length; i++) { alert(ins[i]); } 浏览器会有3次如下图所示的弹框：\ndocument.getElementsByClassName() : 根据标签的class属性值获取标签对象，class属性值也可以重复，返回值是数组。\n添加如下图所示的代码：\n1 2 3 4 5 //1.4 获取元素-根据class属性获取 var divs = document.getElementsByClassName(\u0026#39;cls\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { alert(divs[i]); } 浏览器会弹框2次，都是div标签对象\n操作属性\n那么获取到标签了，我们如何操作标签的属性呢？通过查询文档资料，如下图所示：\n得出我们可以通过div标签对象的innerHTML属性来修改标签的内容。此时我们想把页面中的传智教育替换成传智教育666，所以要获取2个div中的第一个，所以可以通过下标0获取数组中的第一个div，注释之前的代码，编写如下代码：\n1 2 3 4 var divs = document.getElementsByClassName(\u0026#39;cls\u0026#39;); var div1 = divs[0]; div1.innerHTML = \u0026#34;传智教育666\u0026#34;; 浏览器刷新页面，展示效果如下图所示：\n发现页面内容变成了传智教育666\n完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-对象-DOM\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;h1\u0026#34; src=\u0026#34;img/off.gif\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;传智教育\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;黑马程序员\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 电影 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 旅游 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 游戏 \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //1. 获取Element元素 //1.1 获取元素-根据ID获取 // var img = document.getElementById(\u0026#39;h1\u0026#39;); // alert(img); //1.2 获取元素-根据标签获取 - div // var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;); // for (let i = 0; i \u0026lt; divs.length; i++) { // alert(divs[i]); // } //1.3 获取元素-根据name属性获取 // var ins = document.getElementsByName(\u0026#39;hobby\u0026#39;); // for (let i = 0; i \u0026lt; ins.length; i++) { // alert(ins[i]); // } //1.4 获取元素-根据class属性获取 // var divs = document.getElementsByClassName(\u0026#39;cls\u0026#39;); // for (let i = 0; i \u0026lt; divs.length; i++) { // alert(divs[i]); // } //2. 查询参考手册, 属性、方法 var divs = document.getElementsByClassName(\u0026#39;cls\u0026#39;); var div1 = divs[0]; div1.innerHTML = \u0026#34;传智教育666\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 1.5.4 案例 # 1.5.4.1 需求说明 鲁迅说的好，光说不练假把式,光练不说傻把式。所以接下来我们需要通过案例来加强对于上述DOM知识的掌握。需求如下3个：\n点亮灯泡 将所有的div标签的标签体内容后面加上：very good 使所有的复选框呈现被选中的状态 效果如下所示：\n# 1.5.4.2 资料准备 在JS目录下，也就是用于存放html文件的同级创建img文件下，然后将资料/图片素材中提供的2张图片拷贝到img文件夹中，最终整体结果如下图所示：\n在VS Code中创建名为08. JS-对象-DOM-案例.html的文件，然后准备如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-对象-DOM-案例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;h1\u0026#34; src=\u0026#34;img/off.gif\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;传智教育\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;黑马程序员\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 电影 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 旅游 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 游戏 \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 浏览器打开此时效果如图所示：\n# 1.5.4.3 需求1 需求\n点亮灯泡\n分析\n此时我们需要把灯泡点亮，其实就是换一张图片。那么我们需要切换图片，就需要操作图片的src属性。要操作图片的src属性，就需要先来获取img标签对象。\n步骤\n首先获取img标签对象 然后修改img标签对象的src属性值，进行图片的切换 代码实现\n1 2 3 4 5 //1. 点亮灯泡 : src 属性值 //首先获取img标签对象 var img = document.getElementById(\u0026#39;h1\u0026#39;); //然后修改img标签对象的src属性值，进行图片的切换 img.src = \u0026#34;img/on.gif\u0026#34;; 浏览器打开，效果如图所示：\n# 1.5.4.4 需求2 需求\n将所有的div标签的标签体内容后面加上：very good\n并且very good是红色字体\n分析\n我们需要在原有内容后面追加红色的very good.所以我们首先需要获取原有内容，然后再进行内容的追加。但是如何保证very good是红色的呢？所以我们可以通过之前html中学过的\u0026lt;font\u0026gt;标签和属性来完整。如何进行内容的替换呢？之前我们学习过innerHTML属性。需要替换2个div的内容，所以我们需要获取2个div，并且遍历进行替换。\n步骤\n通过标签的名字div获取所有的div标签 遍历所有的div标签 获取div标签的原有内容，然后追加\u0026lt;font color=\u0026lsquo;red\u0026rsquo;\u0026gt;very good\u0026lt;/font\u0026gt;,并且替原内容 代码实现\n1 2 3 4 5 6 //2. 将所有div标签的内容后面加上: very good (红色字体) -- \u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;\u0026lt;/font\u0026gt; var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { const div = divs[i]; div.innerHTML += \u0026#34;\u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;very good\u0026lt;/font\u0026gt;\u0026#34;; } 浏览器打开效果如图所示：\n# 1.5.4.5 需求3 需求\n使所有的复选框呈现被选中的状态\n分析\n要让复选框处于选中状态，那么什么属性或者方法可以使复选框选中？可以查询资料得出checkbox标签对象的checked属性设置为true，可以改变checkbox为选中状态。那么需要设置所有的checkbox，那么我们需要获取所有的checkbox并且遍历\n步骤\n可以通过name属性值获取所有的checkbox标签 遍历所有的checkbox标签， 设置每个checkbox标签的 代码实现\n1 2 3 4 5 6 // //3. 使所有的复选框呈现选中状态 var ins = document.getElementsByName(\u0026#39;hobby\u0026#39;); for (let i = 0; i \u0026lt; ins.length; i++) { const check = ins[i]; check.checked = true;//选中 } 浏览器刷新，效果如图所示:\n# 1.5.4.6 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-对象-DOM-案例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;h1\u0026#34; src=\u0026#34;img/off.gif\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;传智教育\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;黑马程序员\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 电影 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 旅游 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 游戏 \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //1. 点亮灯泡 : src 属性值 var img = document.getElementById(\u0026#39;h1\u0026#39;); img.src = \u0026#34;img/on.gif\u0026#34;; //2. 将所有div标签的内容后面加上: very good (红色字体) -- \u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;\u0026lt;/font\u0026gt; var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { const div = divs[i]; div.innerHTML += \u0026#34;\u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;very good\u0026lt;/font\u0026gt;\u0026#34;; } // //3. 使所有的复选框呈现选中状态 var ins = document.getElementsByName(\u0026#39;hobby\u0026#39;); for (let i = 0; i \u0026lt; ins.length; i++) { const check = ins[i]; check.checked = true;//选中 } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 1.6 JavaScript事件 # 1.6.1 事件介绍 如下图所示的百度注册页面，当我们用户输入完内容，百度可以自动的提示我们用户名已经存在还是可以使用。那么百度是怎么知道我们用户名输入完了呢？这就需要用到JavaScript中的事件了。\n什么是事件呢？HTML事件是发生在HTML元素上的 “事情”，例如：\n按钮被点击 鼠标移到元素上 输入框失去焦点 \u0026hellip;\u0026hellip;.. 而我们可以给这些事件绑定函数，当事件触发时，可以自动的完成对应的功能。这就是事件监听。例如：对于我们所说的百度注册页面，我们给用户名输入框的失去焦点事件绑定函数，当我们用户输入完内容，在标签外点击了鼠标，对于用户名输入框来说，失去焦点，然后执行绑定的函数，函数进行用户名内容的校验等操作。JavaScript事件是js非常重要的一部分，接下来我们进行事件的学习。那么我们对于JavaScript事件需要学习哪些内容呢？我们得知道有哪些常用事件，然后我们得学会如何给事件绑定函数。所以主要围绕2点来学习：\n事件绑定 常用事件 # 1.6.2 事件绑定 JavaScript对于事件的绑定提供了2种方式：\n方式1：通过html标签中的事件属性进行绑定\n例如一个按钮，我们对于按钮可以绑定单机事件，可以借助标签的onclick属性，属性值指向一个函数。\n在VS Code中创建名为09. JS-事件-事件绑定.html，添加如下代码：\n1 \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btn1\u0026#34; value=\u0026#34;事件绑定1\u0026#34; onclick=\u0026#34;on()\u0026#34;\u0026gt; 很明显没有on函数，所以我们需要创建该函数，代码如下：\n1 2 3 4 5 \u0026lt;script\u0026gt; function on(){ alert(\u0026#34;按钮1被点击了...\u0026#34;); } \u0026lt;/script\u0026gt; 浏览器打开，然后点击按钮，弹框如下：\n方式2：通过DOM中Element元素的事件属性进行绑定\n依据我们学习过得DOM的知识点，我们知道html中的标签被加载成element对象，所以我们也可以通过element对象的属性来操作标签的属性。此时我们再次添加一个按钮，代码如下：\n1 \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btn2\u0026#34; value=\u0026#34;事件绑定2\u0026#34;\u0026gt; 我们可以先通过id属性获取按钮对象，然后操作对象的onclick属性来绑定事件，代码如下：\n1 2 3 document.getElementById(\u0026#39;btn2\u0026#39;).onclick = function(){ alert(\u0026#34;按钮2被点击了...\u0026#34;); } 浏览器刷新页面，点击第二个按钮，弹框如下：\n需要注意的是：事件绑定的函数，只有在事件被触发时，函数才会被调用。\n整体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-事件-事件绑定\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btn1\u0026#34; value=\u0026#34;事件绑定1\u0026#34; onclick=\u0026#34;on()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;btn2\u0026#34; value=\u0026#34;事件绑定2\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function on(){ alert(\u0026#34;按钮1被点击了...\u0026#34;); } document.getElementById(\u0026#39;btn2\u0026#39;).onclick = function(){ alert(\u0026#34;按钮2被点击了...\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 1.6.3 常见事件 上面案例中使用到了 onclick 事件属性，那都有哪些事件属性供我们使用呢？下面就给大家列举一些比较常用的事件属性\n事件属性名 说明 onclick 鼠标单击事件 onblur 元素失去焦点 onfocus 元素获得焦点 onload 某个页面或图像被完成加载 onsubmit 当表单提交时触发该事件 onmouseover 鼠标被移到某元素之上 onmouseout 鼠标从某元素移开 在代码中提供了10. JS-事件-常见事件.html的文件，我们可以通过浏览器打开来观察几个常用事件的具体效果：\nonfocus:获取焦点事件，鼠标点击输入框，输入框中光标一闪一闪的，就是输入框获取焦点了\nonblur:失去焦点事件，前提是输入框获取焦点的状态下，在输入框之外的地方点击，光标从输入框中消失了，这就是失去焦点。\n其他事件的效果，同学们可以通过提供好的代码去演示，亲身体会事件在什么时候触发。\n# 1.6.4 案例 # 1.6.4.1 需求说明 接下来我们通过案例来加强所学js知识点的掌握。\n需求如下3个：\n点击 “点亮”按钮 点亮灯泡，点击“熄灭”按钮 熄灭灯泡 输入框鼠标聚焦后，展示小写；鼠标离焦后，展示大写。 点击 “全选”按钮使所有的复选框呈现被选中的状态，点击 “反选”按钮使所有的复选框呈现取消勾选的状态。 效果如图所示：\n# 1.6.4.2 资料准备 在VS Code中创建名为11. JS-事件-案例.html的文件，提前准备如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-事件-案例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;light\u0026#34; src=\u0026#34;img/off.gif\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点亮\u0026#34; \u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;熄灭\u0026#34; \u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; value=\u0026#34;ITCAST\u0026#34; \u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 电影 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 旅游 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 游戏 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;全选\u0026#34; \u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;反选\u0026#34; \u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 浏览器打开如图所示：\n# 1.6.4.3 需求1 需求：\n点击 “点亮”按钮 点亮灯泡，点击“熄灭”按钮 熄灭灯泡\n分析：\n点击按钮的时候触发，所以我们需要绑定单击事件。不管是点亮还是熄灭，都是图片的变化，所以我们需要修改图片。但是修改图片我们还需要先获取标签图片标签对象。\n步骤：\n首先给点亮按钮和熄灭按钮都绑定单击事件。分别绑定函数on()和off（） 然后在js中定义on()和off()函数 on()函数中，通过id获取img标签对象，然后通过img标签对象的src属性切换点亮的图片 off()函数中，通过id获取img标签对象，然后通过img标签对象的src属性切换熄灭的图片 代码实现：\n事件绑定\n1 2 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点亮\u0026#34; onclick=\u0026#34;on()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;熄灭\u0026#34; onclick=\u0026#34;off()\u0026#34;\u0026gt; on()和off()函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //1. 点击 \u0026#34;点亮\u0026#34; 按钮, 点亮灯泡; 点击 \u0026#34;熄灭\u0026#34; 按钮, 熄灭灯泡; -- onclick function on(){ //a. 获取img元素对象 var img = document.getElementById(\u0026#34;light\u0026#34;); //b. 设置src属性 img.src = \u0026#34;img/on.gif\u0026#34;; } function off(){ //a. 获取img元素对象 var img = document.getElementById(\u0026#34;light\u0026#34;); //b. 设置src属性 img.src = \u0026#34;img/off.gif\u0026#34;; } # 1.6.4.4 需求2 需求：\n输入框鼠标聚焦后，展示小写；鼠标离焦后，展示大写。\n分析：\n聚焦和失焦的时候完成功能，所以我们需要给input标签绑定onfocus和onblur事件；我们要切换大小写，那么我们可定要获取原本输入框的内容，通过查询资料，需要使用input标签对象的value属性，然后进行大小写切换；切换完成我们需要重新填入，所以还是通过value属性来设置input标签输入框的内容\n步骤:\n给input标签的onfocus和onblur事件分别绑定lower()和upper()函数 然后在js中定义lower()和upper()函数 对于lower()函数，先通过id获取输入框对象，然后通过输入框的value属性来设置内容，内容的话可以通过字符串的toLowerCase()函数来进行小写转换 对于upper()函数，先通过id获取输入框对象，然后通过输入框的value属性来设置内容，内容的话可以通过字符串的toupperCase()函数来进行大写转换 代码实现：、\n事件绑定：\n1 \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; value=\u0026#34;ITCAST\u0026#34; onfocus=\u0026#34;lower()\u0026#34; onblur=\u0026#34;upper()\u0026#34;\u0026gt; lower()和upper()函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //2. 输入框聚焦后, 展示小写; 输入框离焦后, 展示大写; -- onfocus , onblur function lower(){//小写 //a. 获取输入框元素对象 var input = document.getElementById(\u0026#34;name\u0026#34;); //b. 将值转为小写 input.value = input.value.toLowerCase(); } function upper(){//大写 //a. 获取输入框元素对象 var input = document.getElementById(\u0026#34;name\u0026#34;); //b. 将值转为大写 input.value = input.value.toUpperCase(); } # 1.6.4.5 需求3 需求：\n点击 “全选”按钮使所有的复选框呈现被选中的状态，点击 “反选”按钮使所有的复选框呈现取消勾选的状态。\n分析：\n点击按钮完成功能，所以我们需要给2个按钮绑定单击事件；我们需要设置所有复选框的状态，通过我们之前的案例，我们知道，我们需要获取所有的复选框，然后遍历，可以通过设置checked属性为true，来设置复选框为选中；那么反之，设置checked属性为false，来设置复选框为未选中。\n步骤：\n给全选和反选按钮绑定单击事件，分别绑定函数checkAll()和reverse() 在js中定义checkAll()和reverse()函数 对于checkAll()函数，首先通过name属性值为hobby来获取所有的复选框，然后遍历复选框，设置每个复选框的checked属性为true即可 对于reverse()函数，首先通过name属性值为hobby来获取所有的复选框，然后遍历复选框，设置每个复选框的checked属性为false即可 代码实现：\n事件绑定：\n1 2 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;全选\u0026#34; onclick=\u0026#34;checkAll()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;反选\u0026#34; onclick=\u0026#34;reverse()\u0026#34;\u0026gt; checkAll()和reverse()函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //3. 点击 \u0026#34;全选\u0026#34; 按钮使所有的复选框呈现选中状态 ; 点击 \u0026#34;反选\u0026#34; 按钮使所有的复选框呈现取消勾选的状态 ; function checkAll(){ //a. 获取所有复选框元素对象 var hobbys = document.getElementsByName(\u0026#34;hobby\u0026#34;); //b. 设置选中状态 for (let i = 0; i \u0026lt; hobbys.length; i++) { const element = hobbys[i]; element.checked = true; } } function reverse(){ //a. 获取所有复选框元素对象 var hobbys = document.getElementsByName(\u0026#34;hobby\u0026#34;); //b. 设置未选中状态 for (let i = 0; i \u0026lt; hobbys.length; i++) { const element = hobbys[i]; element.checked = false; } } # 1.6.4.6 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-事件-案例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;light\u0026#34; src=\u0026#34;img/off.gif\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点亮\u0026#34; onclick=\u0026#34;on()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;熄灭\u0026#34; onclick=\u0026#34;off()\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; value=\u0026#34;ITCAST\u0026#34; onfocus=\u0026#34;lower()\u0026#34; onblur=\u0026#34;upper()\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 电影 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 旅游 \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 游戏 \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;全选\u0026#34; onclick=\u0026#34;checkAll()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;反选\u0026#34; onclick=\u0026#34;reverse()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //1. 点击 \u0026#34;点亮\u0026#34; 按钮, 点亮灯泡; 点击 \u0026#34;熄灭\u0026#34; 按钮, 熄灭灯泡; -- onclick function on(){ //a. 获取img元素对象 var img = document.getElementById(\u0026#34;light\u0026#34;); //b. 设置src属性 img.src = \u0026#34;img/on.gif\u0026#34;; } function off(){ //a. 获取img元素对象 var img = document.getElementById(\u0026#34;light\u0026#34;); //b. 设置src属性 img.src = \u0026#34;img/off.gif\u0026#34;; } //2. 输入框聚焦后, 展示小写; 输入框离焦后, 展示大写; -- onfocus , onblur function lower(){//小写 //a. 获取输入框元素对象 var input = document.getElementById(\u0026#34;name\u0026#34;); //b. 将值转为小写 input.value = input.value.toLowerCase(); } function upper(){//大写 //a. 获取输入框元素对象 var input = document.getElementById(\u0026#34;name\u0026#34;); //b. 将值转为大写 input.value = input.value.toUpperCase(); } //3. 点击 \u0026#34;全选\u0026#34; 按钮使所有的复选框呈现选中状态 ; 点击 \u0026#34;反选\u0026#34; 按钮使所有的复选框呈现取消勾选的状态 ; -- onclick function checkAll(){ //a. 获取所有复选框元素对象 var hobbys = document.getElementsByName(\u0026#34;hobby\u0026#34;); //b. 设置选中状态 for (let i = 0; i \u0026lt; hobbys.length; i++) { const element = hobbys[i]; element.checked = true; } } function reverse(){ //a. 获取所有复选框元素对象 var hobbys = document.getElementsByName(\u0026#34;hobby\u0026#34;); //b. 设置未选中状态 for (let i = 0; i \u0026lt; hobbys.length; i++) { const element = hobbys[i]; element.checked = false; } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 2 Vue # 2.1 Vue概述 通过我们学习的html+css+js已经能够开发美观的页面了，但是开发的效率还有待提高，那么如何提高呢？我们先来分析下页面的组成。一个完整的html页面包括了视图和数据，数据是通过请求 从后台获取的，那么意味着我们需要将后台获取到的数据呈现到页面上，很明显， 这就需要我们使用DOM操作。正因为这种开发流程，所以我们引入了一种叫做MVVM(Model-View-ViewModel)的前端开发思想，即让我们开发者更加关注数据，而非数据绑定到视图这种机械化的操作。感受一下使用js中的DOM操作，将后台获取到的数据呈现到页面上有多麻烦！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;60%\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成绩\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;等级\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34; v-for=\u0026#34;(user,index) in users\u0026#34;\u0026gt; \u0026lt;td id = \u0026#34;1\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td id = \u0026#34;2\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td id = \u0026#34;3\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td id = \u0026#34;4\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td id = \u0026#34;5\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td id = \u0026#34;6\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; var json = \u0026#39;{\u0026#34;stu1\u0026#34;:[1,\u0026#34;张三\u0026#34;,22,\u0026#34;男\u0026#34;,87,\u0026#34;及格\u0026#34;],\u0026#34;stu2\u0026#34;:[2,\u0026#34;李四\u0026#34;,22,\u0026#34;男\u0026#34;,87,\u0026#34;及格\u0026#34;]}\u0026#39;; var obj = JSON.parse(json); document.getElementById(\u0026#34;1\u0026#34;).innerHTML = obj.stu1[0]; document.getElementById(\u0026#34;2\u0026#34;).innerHTML = obj.stu1[1]; document.getElementById(\u0026#34;3\u0026#34;).innerHTML = obj.stu1[2]; document.getElementById(\u0026#34;4\u0026#34;).innerHTML = obj.stu1[3]; document.getElementById(\u0026#34;5\u0026#34;).innerHTML = obj.stu1[4]; document.getElementById(\u0026#34;6\u0026#34;).innerHTML = obj.stu1[5]; \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 运行效果如下：\n简直没法看是吧！\n那么具体什么是MVVM思想呢？\nMVVM:其实是Model-View-ViewModel的缩写，有3个单词，具体释义如下：\nModel: 数据模型，特指前端中通过请求从后台获取的业务数据 View: 视图，用于展示数据的页面（一般在body标签中操作），可以理解成我们的html+css搭建的页面，但是没有数据 ViewModel: 数据绑定到视图，负责将数据（Model）通过JavaScript的DOM技术，将数据展示到视图（View）上，实现双向绑定。 如图所示就是MVVM开发思想的含义：\n基于上述的MVVM思想，其中的Model我们可以通过Ajax来发起请求从后台获取;对于View部分，我们将来会学习一款ElementUI框架来替代HTML+CSS来更加方便的搭建View;而今天我们要学习的就是侧重于ViewModel部分开发的vue前端框架，用来替代JavaScript的DOM操作，让数据展示到视图的代码开发变得更加的简单。可以简单到什么程度呢？可以参考下图对比：\n在更加复杂的dom操作中，vue只会变得更加的简单！在上述的代码中，我们看不到之前的DOM操作，因为vue全部帮我们封装好了。\n接下来我们来介绍一下vue。\nVue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。\n框架即是一个半成品软件，是一套可重用的、通用的、软件基础代码模型。基于框架进行开发，更加快捷、更加高效。\n# 2.2 快速入门 接下来我们通过一个vue的快速入门案例，来体验一下vue。\n第一步：在VS Code中创建名为12. Vue-快速入门.html的文件，并且在html文件同级创建js目录（用以专门存放js文件），将官网下载的vue.js文件拷贝到js目录，如下图所示：\n第二步：然后编写\u0026lt;script\u0026gt;标签来引入vue.js文件，代码如下：\n1 \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 第三步：在js代码区域定义vue对象,代码如下：\n1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ message: \u0026#34;Hello Vue\u0026#34; } }) \u0026lt;/script\u0026gt; 在创建vue对象时，有几个常用的属性：\nel: 用来指定哪儿些标签受 Vue 管理。 #app 有点像id选择器，表示id为 app 的标签受vue管理 data: 用来定义数据模型，可以接收来自后台传过来的数据 methods: 用来定义函数。这个我们在后面就会用到 第四步：在html区域编写视图，其中{{}}是插值表达式，用来将vue对象中定义的model展示到页面上的\n1 2 3 4 5 6 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; {{message}} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 浏览器打开效果如图所示：\n整体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-快速入门\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; {{message}} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ message: \u0026#34;Hello Vue\u0026#34; } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 2.3 Vue指令 在上述的快速入门中，我们发现了html中输入了一个没有学过的属性v-model，这个就是vue的指令。\n**指令：**HTML 标签上带有 v- 前缀的特殊属性，不同指令具有不同含义。例如：v-if，v-for…\n在vue中，通过大量的指令来实现数据绑定到视图的，所以接下来我们需要学习vue的常用指令，如下表所示：\n指令 作用 v-bind 为HTML标签绑定属性值，如设置 href , css样式等属性值 v-bind:href=\u0026ldquo;url\u0026rdquo; v-model 为表单元素绑定内容（双向数据绑定），如设置表单项的内容 v-model=\u0026ldquo;message\u0026rdquo; v-on 为HTML标签绑定事件 v-if 条件性的渲染某元素，判定为true时渲染,否则不渲染 v-else v-else-if v-show 根据条件展示某元素，区别在于v-show都会渲染，且通过切换display属性的值来决定是否展示到页面 v-for 列表渲染，遍历容器的元素或者对象的属性 # 2.3.1 v-bind和v-model 我们首先来学习v-bind指令和v-model指令。\n指令 作用 v-bind 为HTML标签绑定属性值，如设置 href , css样式等 v-model 在表单元素上创建双向数据绑定 v-bind: 为HTML标签绑定属性值，如设置 href , css样式等。当vue对象中的数据模型发生变化时，标签的属性值会随之发生变化。\n接下来我们通过代码来演示。\n首先我们在VS Code中创建名为13. Vue-指令-v-bind和v-model.html的文件，然后准备好如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-v-bind\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;a \u0026gt;链接1\u0026lt;/a\u0026gt; \u0026lt;a \u0026gt;链接2\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ url: \u0026#34;https://www.baidu.com\u0026#34; } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 在上述的代码中，我们需要给\u0026lt;a\u0026gt;标签的href属性赋值，并且值应该来自于vue对象的数据模型中的url变量。所以编写如下代码：\n1 \u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;链接1\u0026lt;/a\u0026gt; 在上述的代码中，v-bind指令是可以省略的，但是:不能省略，所以第二个超链接的代码编写如下：\n1 \u0026lt;a :href=\u0026#34;url\u0026#34;\u0026gt;链接2\u0026lt;/a\u0026gt; 浏览器打开，2个超链接都可以点击，然后跳转到百度去！效果如图所示：\n注意：html属性前面有:表示采用的vue的属性绑定！\nv-model： 在表单元素上创建双向数据绑定。什么是双向？\nvue对象的data属性中的数据变化，视图展示会一起变化 视图数据发生变化，vue对象的data属性中的数据也会随着变化。 data属性中数据变化，我们知道可以通过赋值来改变，但是视图数据为什么会发生变化呢？只有表单项标签！所以双向绑定一定是使用在表单项标签上的。编写如下代码：\n1 \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;url\u0026#34;\u0026gt; 打开浏览器，我们修改表单项标签，发现vue对象data中的数据也发生了变化，如下图所示：\n通过上图我们发现，我们只是改变了表单数据，那么我们之前超链接的绑定的数据值也发生了变化，为什么？\n就是因为我们双向绑定，在视图发生变化时，同时vue的data中的数据模型也会随着变化。那么这个在企业开发的应用场景是什么？\n双向绑定的作用：可以获取表单的数据的值，然后提交给服务器\n整体代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-v-bind\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;链接1\u0026lt;/a\u0026gt; \u0026lt;a :href=\u0026#34;url\u0026#34;\u0026gt;链接2\u0026lt;/a\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;url\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ url: \u0026#34;https://www.baidu.com\u0026#34; } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 2.3.2 v-on 接下来我们学习一下v-on指令。\nv-on: 用来给html标签绑定事件的。需要注意的是如下2点：\nv-on语法给标签的事件绑定的函数，必须是vue对象种声明的函数\nv-on语法绑定事件时，事件名相比较js中的事件名，没有on\n例如：在js中，事件绑定demo函数\n1 \u0026lt;input onclick=\u0026#34;demo()\u0026#34;\u0026gt; vue中，事件绑定demo函数\n1 \u0026lt;input v-on:click=\u0026#34;demo()\u0026#34;\u0026gt; 接下来我们通过代码演示。\n首先在VS Code中创建名为14. Vue-指令-v-on.html的文件，提前准备如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-v-on\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 // {}表示data属性对应的对象 data:{ }, methods: { } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 然后我们需要在vue对象的methods属性中定义事件绑定时需要的handle()函数，代码如下：\n1 2 3 4 5 methods: { handle: function(){ alert(\u0026#34;你点我了一下...\u0026#34;); } } **注意：**与js的函数定义有点不同，js中函数定义是 var handle = function(){}\n然后我们给第一个按钮，通过v-on指令绑定单击事件，代码如下：\n1 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下\u0026#34; v-on:click=\u0026#34;handle()\u0026#34;\u0026gt; 同样，v-on也存在简写方式，即v-on: 可以替换成@，所以第二个按钮绑定单击事件的代码如下：\n1 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下\u0026#34; @click=\u0026#34;handle()\u0026#34;\u0026gt; 完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-v-on\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下\u0026#34; v-on:click=\u0026#34;handle()\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点我一下\u0026#34; @click=\u0026#34;handle()\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ }, methods: { handle: function(){ alert(\u0026#34;你点我了一下...\u0026#34;); } } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 2.3.3 v-if和v-show 指令 描述 v-if 条件性的渲染某元素，判定为true时渲染,否则不渲染 v-if-else v-else v-show 根据条件展示某元素，区别在于他都会渲染，只是它通过切换display属性的值来控制是否展示到页面 我们直接通过代码来演示效果。在VS Code中创建名为15. Vue-指令-v-if和v-show.html的文件，提前准备好如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-v-if与v-show\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 年龄\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;age\u0026#34;\u0026gt;经判定,为: \u0026lt;span\u0026gt;年轻人(35及以下)\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;中年人(35-60)\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;老年人(60及以上)\u0026lt;/span\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ age: 20 }, methods: { } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 其中采用了双向绑定到age属性，意味着我们可以通过表单输入框来改变age的值。\n需求是当我们改变年龄时，需要动态判断年龄的值，呈现对应的年龄的文字描述。年轻人，我们需要使用条件判断age\u0026lt;=35,中年人我们需要使用条件判断age\u0026gt;35 \u0026amp;\u0026amp; age\u0026lt;60,其他情况是老年人。所以通过v-if指令编写如下代码：\n1 2 3 4 年龄\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;age\u0026#34;\u0026gt;经判定,为: \u0026lt;span v-if=\u0026#34;age \u0026lt;= 35\u0026#34;\u0026gt;年轻人(35及以下)\u0026lt;/span\u0026gt; \u0026lt;span v-else-if=\u0026#34;age \u0026gt; 35 \u0026amp;\u0026amp; age \u0026lt; 60\u0026#34;\u0026gt;中年人(35-60)\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;老年人(60及以上)\u0026lt;/span\u0026gt; 浏览器打开测试效果如下图：\nv-show和v-if的作用效果是一样的，只是原理不一样。复制上述html代码，修改v-if指令为v-show指令，代码如下：\n1 2 3 4 年龄\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;age\u0026#34;\u0026gt;经判定,为: \u0026lt;span v-show=\u0026#34;age \u0026lt;= 35\u0026#34;\u0026gt;年轻人(35及以下)\u0026lt;/span\u0026gt; \u0026lt;span v-show=\u0026#34;age \u0026gt; 35 \u0026amp;\u0026amp; age \u0026lt; 60\u0026#34;\u0026gt;中年人(35-60)\u0026lt;/span\u0026gt; \u0026lt;span v-show=\u0026#34;age \u0026gt;= 60\u0026#34;\u0026gt;老年人(60及以上)\u0026lt;/span\u0026gt; 打开浏览器，展示效果如下所示：\n可以发现，浏览器呈现的效果是一样的，但是浏览器中html源码不一样。v-if指令，不满足条件的标签代码直接没了，而v-show指令中，不满足条件的代码依然存在，只是添加了css样式来控制标签不去显示。\n完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-v-if与v-show\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 年龄\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;age\u0026#34;\u0026gt;经判定,为: \u0026lt;span v-if=\u0026#34;age \u0026lt;= 35\u0026#34;\u0026gt;年轻人(35及以下)\u0026lt;/span\u0026gt; \u0026lt;span v-else-if=\u0026#34;age \u0026gt; 35 \u0026amp;\u0026amp; age \u0026lt; 60\u0026#34;\u0026gt;中年人(35-60)\u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt;老年人(60及以上)\u0026lt;/span\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 年龄\u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;age\u0026#34;\u0026gt;经判定,为: \u0026lt;span v-show=\u0026#34;age \u0026lt;= 35\u0026#34;\u0026gt;年轻人(35及以下)\u0026lt;/span\u0026gt; \u0026lt;span v-show=\u0026#34;age \u0026gt; 35 \u0026amp;\u0026amp; age \u0026lt; 60\u0026#34;\u0026gt;中年人(35-60)\u0026lt;/span\u0026gt; \u0026lt;span v-show=\u0026#34;age \u0026gt;= 60\u0026#34;\u0026gt;老年人(60及以上)\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ age: 20 }, methods: { } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 2.3.4 v-for v-for: 从名字我们就能看出，这个指令是用来遍历的。其语法格式如下：\n1 2 3 \u0026lt;标签 v-for=\u0026#34;变量名 in 集合模型数据\u0026#34;\u0026gt; {{变量名}} \u0026lt;/标签\u0026gt; 需要注意的是：需要循环哪个标签，v-for 指令就写在那个标签上。\n有时我们遍历时需要使用索引，那么v-for指令遍历的语法格式如下：\n1 2 3 4 \u0026lt;标签 v-for=\u0026#34;(变量名,索引变量) in 集合模型数据\u0026#34;\u0026gt; \u0026lt;!--索引变量是从0开始，所以要表示序号的话，需要手动的加1--\u0026gt; {{索引变量 + 1}} {{变量名}} \u0026lt;/标签\u0026gt; 接下来，我们再VS Code中创建名为16. Vue-指令-v-for.html的文件编写代码演示，提前准备如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-v-for\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ addrs:[\u0026#34;北京\u0026#34;, \u0026#34;上海\u0026#34;, \u0026#34;西安\u0026#34;, \u0026#34;成都\u0026#34;, \u0026#34;深圳\u0026#34;] }, methods: { } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 然后分别编写2种遍历语法，来遍历数组，展示数据，代码如下：\n1 2 3 4 5 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;addr in addrs\u0026#34;\u0026gt;{{addr}}\u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div v-for=\u0026#34;(addr,index) in addrs\u0026#34;\u0026gt;{{index + 1}} : {{addr}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 浏览器打开，呈现如下效果：\n# 2.3.5 案例 需求：\n如上图所示，我们提供好了数据模型，users是数组集合，提供了多个用户信息。然后我们需要将数据以表格的形式，展示到页面上，其中，性别需要转换成中文男女，等级需要将分数数值转换成对应的等级。\n分析：\n首先我们肯定需要遍历数组的，所以需要使用v-for标签；然后我们每一条数据对应一行，所以v-for需要添加在tr标签上；其次我们需要将编号，所以需要使用索引的遍历语法；然后我们要将数据展示到表格的单元格中，所以我们需要使用{{}}插值表达式；最后，我们需要转换内容，所以我们需要使用v-if指令，进行条件判断和内容的转换\n步骤：\n使用v-for的带索引方式添加到表格的\u0026lt;tr\u0026gt;标签上 使用{{}}插值表达式展示内容到单元格 使用索引+1来作为编号 使用v-if来判断，改变性别和等级这2列的值 代码实现：\n首先创建名为17. Vue-指令-案例.html的文件，提前准备如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-案例\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;60%\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成绩\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;等级\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { users: [{ name: \u0026#34;Tom\u0026#34;, age: 20, gender: 1, score: 78 },{ name: \u0026#34;Rose\u0026#34;, age: 18, gender: 2, score: 86 },{ name: \u0026#34;Jerry\u0026#34;, age: 26, gender: 1, score: 90 },{ name: \u0026#34;Tony\u0026#34;, age: 30, gender: 1, score: 52 }] }, methods: { }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 然后在\u0026lt;tr\u0026gt;上添加v-for进行遍历，以及通过插值表达式{{}}和v-if指令来填充内容和改变内容，其代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;tr align=\u0026#34;center\u0026#34; v-for=\u0026#34;(user,index) in users\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index + 1}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.age}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span v-if=\u0026#34;user.gender == 1\u0026#34;\u0026gt;男\u0026lt;/span\u0026gt; \u0026lt;span v-if=\u0026#34;user.gender == 2\u0026#34;\u0026gt;女\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.score}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span v-if=\u0026#34;user.score \u0026gt;= 85\u0026#34;\u0026gt;优秀\u0026lt;/span\u0026gt; \u0026lt;span v-else-if=\u0026#34;user.score \u0026gt;= 60\u0026#34;\u0026gt;及格\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color: red;\u0026#34; v-else\u0026gt;不及格\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; 其完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-案例\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;60%\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成绩\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;等级\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34; v-for=\u0026#34;(user,index) in users\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index + 1}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.age}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span v-if=\u0026#34;user.gender == 1\u0026#34;\u0026gt;男\u0026lt;/span\u0026gt; \u0026lt;span v-if=\u0026#34;user.gender == 2\u0026#34;\u0026gt;女\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.score}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span v-if=\u0026#34;user.score \u0026gt;= 85\u0026#34;\u0026gt;优秀\u0026lt;/span\u0026gt; \u0026lt;span v-else-if=\u0026#34;user.score \u0026gt;= 60\u0026#34;\u0026gt;及格\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color: red;\u0026#34; v-else\u0026gt;不及格\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { users: [{ name: \u0026#34;Tom\u0026#34;, age: 20, gender: 1, score: 78 },{ name: \u0026#34;Rose\u0026#34;, age: 18, gender: 2, score: 86 },{ name: \u0026#34;Jerry\u0026#34;, age: 26, gender: 1, score: 90 },{ name: \u0026#34;Tony\u0026#34;, age: 30, gender: 1, score: 52 }] }, methods: { }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; # 2.4 生命周期 vue的生命周期：指的是vue对象从创建到销毁的过程。vue的生命周期包含8个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法，这些生命周期方法也被称为钩子方法。其完整的生命周期如下图所示：\n状态 阶段周期 beforeCreate 创建前 created 创建后 beforeMount 挂载前 mounted 挂载完成 beforeUpdate 更新前 updated 更新后 beforeDestroy 销毁前 destroyed 销毁后 下图是 Vue 官网提供的从创建 Vue 到效果 Vue 对象的整个过程及各个阶段对应的钩子函数：\n其中我们需要重点关注的是**mounted,**其他的我们了解即可。\nmounted：挂载完成，Vue初始化成功，HTML页面渲染成功。挂载完成后，会自动执行mounted函数，以后我们一般用于页面初始化自动的ajax请求后台数据\n我们在VS Code中创建名为18. Vue-生命周期.html的文件编写代码来演示效果，提前准备如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue-指令-v-for\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ }, methods: { } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 然后我们编写mounted生命周期的钩子函数，与methods同级，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; //定义Vue对象 new Vue({ el: \u0026#34;#app\u0026#34;, //vue接管区域 data:{ }, methods: { }, mounted () { alert(\u0026#34;vue挂载完成,发送请求到服务端\u0026#34;) } }) \u0026lt;/script\u0026gt; 浏览器打开，运行结果如下：我们发现，自动打印了这句话，因为页面加载完成，vue对象创建并且完成了挂载，此时自动触发mounted所绑定的钩子函数，然后自动执行，弹框。\n","date":"2024-04-27T11:48:27+08:00","permalink":"http://localhost:1313/p/jsvue%E5%9F%BA%E7%A1%80/","title":"Js、vue基础"},{"content":" # 1. 前端开发介绍 我们介绍Web网站工作流程的时候提到，前端开发，主要的职责就是将数据以好看的样式呈现出来。说白了，就是开发网页程序，如下图所示：\n那在讲解web前端开发之前，我们先需要对web前端开发有一个整体的认知。主要明确一下三个问题：\n1). 网页有哪些部分组成 ?\n文字、图片、音频、视频、超链接、表格等等。\n2). 我们看到的网页，背后的本质是什么 ?\n程序员写的前端代码 (备注：在前后端分离的开发模式中，)\n3). 前端的代码是如何转换成用户眼中的网页的 ?\n通过浏览器转化（解析和渲染）成用户看到的网页\n浏览器中对代码进行解析和渲染的部分，称为 浏览器内核\n而市面上的浏览器非常多，比如：IE、火狐Firefox、苹果safari、欧朋、谷歌Chrome、QQ浏览器、360浏览器等等。 而且我们电脑上安装的浏览器可能都不止一个，有很多。\n但是呢，需要大家注意的是，不同的浏览器，内核不同，对于相同的前端代码解析的效果也会存在差异。 那这就会造成一个问题，同一段前端程序，不同浏览器展示出来的效果是不一样的，这个用户体验就很差了。而我们想达到的效果则是，即使用户使用的是不同的浏览器，解析同一段前端代码，最终展示出来的效果都是相同的。\n要想达成这样一个目标，我们就需要定义一个统一的标准，然后让各大浏览器厂商都参照这个标准来实现即可。 而这套标准呢，其实早都已经定义好了，那就是我们接下来，要介绍的web标准。\nWeb标准也称为网页标准，由一系列的标准组成，大部分由W3C（ World Wide Web Consortium，万维网联盟）负责制定。由三个组成部分：\nHTML：负责网页的结构（页面元素和内容）。\nCSS：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。\nJavaScript：负责网页的行为（交互效果）。\n当然了，随着技术的发展，我们为了更加快速的开发，现在也出现了很多前端开发的高级技术。例如：vue、elementui、Axios等等。\n那这些内容呢，也是我们前端三天课程中要讲解的内容。 前端的3天课程安排如下：\nHTML \u0026amp; CSS JavaScript \u0026amp; Vue Ajax \u0026amp; Axios \u0026amp; ElementUI \u0026amp; Nginx # 2. HTML \u0026amp; CSS 1). 什么是HTML ?\n**HTML: **HyperText Markup Language，超文本标记语言。\n超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容。\n标记语言：由标签构成的语言\nHTML标签都是预定义好的。例如：使用 标签展示标题，使用展示超链接，使用展示图片，展示视频。 HTML代码直接在浏览器中运行，HTML标签由浏览器解析。 下面展示的是一段html代码经过浏览器解析，呈现的效果如右图所示：\n​\n2). 什么是CSS ?\nCSS: Cascading Style Sheet，层叠样式表，用于控制页面的样式（表现）。\n下面展示的是一段 html代码 及 CSS样式 经过浏览器解析，呈现的效果如右图所示：\n​\n# 2.1 HTML快速入门 # 2.1.1 HTML页面的基础结构 HTML页面的基础结构标签\n1 2 3 4 5 6 7 8 9 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;HTML 快速入门\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello HTML\u0026lt;/h1\u0026gt; \u0026lt;img src=\u0026#34;1.jpg\u0026#34;/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 其中\u0026lt;html\u0026gt;是根标签，\u0026lt;head\u0026gt;和\u0026lt;body\u0026gt;是子标签，\u0026lt;head\u0026gt;中的字标签\u0026lt;title\u0026gt;是用来定义网页的标题的，里面定义的内容会显示在浏览器网页的标题位置。\n而 \u0026lt;body\u0026gt; 中编写的内容，就网页中显示的核心内容。\n# 2.1.2 HTML中的标签特点 HTML标签不区分大小写 HTML标签的属性值，采用单引号、双引号都可以 HTML语法相对比较松散 (建议大家编写HTML标签的时候尽量严谨一些) # 2.2 开发工具 我们通过快速入门案例，发现由记事本文件开发html是非常不方便的，所以接下来我们需要学习一款前端专业的开发工具VS Code。\nVisual Studio Code（简称 VS Code ）是 Microsoft 于2015年4月发布的一款代码编辑器。VS Code 对前端代码有非常强大的支持，同时也其他编程语言（例如：C++、Java、Python、PHP、Go等）。VS Code 提供了非常强大的插件库，大大提高了开发效率。\n官网： https://code.visualstudio.com\n注意：需要注意的是，我们作为一名开发者，不应该将软件软装在包含中文名的路径中 。\n# 2.3 基础标签 \u0026amp; 样式 那我们在讲解HTML的常见基础标签 及 CSS的基本样式时，我们就以 新浪新闻页面 为例，来进行讲解，这样大家不仅能够知道 常见标签及样式的作用，还能够知道具体的应用场景。\n新浪新闻的具体页面效果如下：\n原始页面网址：https://news.sina.com.cn/gov/xlxw/2023-03-03/doc-imyipzuy7321600.shtml\n而对于这个新浪新闻的页面来说，核心内容分为两个部分，如下：\n新浪新闻-标题部分 新浪新闻-正文部分 # 2.3.1 新浪新闻-标题实现 # 2.3.1.1 标题排版 # 2.3.1.1.1 分析 1). 第一部分，是一张图片，需要用到HTML中的图片标签 来实现。\n2). 第二部分，是一个标题，需要用到HTML中的标题标签 \u0026hellip; 来实现。\n3). 第三部分，有两条水平分割线，需要用到HTML中的 标签来定义水平分割线。\n# 2.3.1.1.2 标签 1). 图片标签 img\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 A. 图片标签: \u0026lt;img\u0026gt; B. 常见属性: src: 指定图像的url (可以指定 绝对路径 , 也可以指定 相对路径) width: 图像的宽度 (像素 / 百分比 , 相对于父元素的百分比) height: 图像的高度 (像素 / 百分比 , 相对于父元素的百分比) 备注: 一般width 和 height 我们只会指定一个，另外一个会自动的等比例缩放。 C. 路径书写方式: 绝对路径: 1. 绝对磁盘路径: C:\\Users\\Administrator\\Desktop\\HTML\\img\\news_logo.png \u0026lt;img src=\u0026#34;C:\\Users\\Administrator\\Desktop\\HTML\\img\\news_logo.png\u0026#34;\u0026gt; 2. 绝对网络路径: https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png \u0026lt;img src=\u0026#34;https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png\u0026#34;\u0026gt; 相对路径: ./ : 当前目录 , ./ 可以省略的 ../: 上一级目录 2). 标题标签 h 系列\n1 2 3 4 5 6 7 8 9 10 A. 标题标签: \u0026lt;h1\u0026gt; - \u0026lt;h6\u0026gt; \u0026lt;h1\u0026gt;111111111111\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;111111111111\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;111111111111\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;111111111111\u0026lt;/h4\u0026gt; \u0026lt;h5\u0026gt;111111111111\u0026lt;/h5\u0026gt; \u0026lt;h6\u0026gt;111111111111\u0026lt;/h6\u0026gt; B. 效果 : h1为一级标题，字体也是最大的 ； h6为六级标题，字体是最小的。 3). 水平分页线标签 # 2.3.1.1.2 实现 1). 打开VsCode，选择左侧最底部的 \u0026ldquo;资源管理器\u0026rdquo;，然后选择打开文件夹，选择打开桌面的 HTML 文件夹\n2). 将资料中提供的 图片、音频、视频 文件夹的这三个文件夹（里面是图片、音视频素材），复制到 HTML 文件夹中。\n3). 在VsCode中创建一个新的 html 文件，文件的后缀名设置为 .html\n4). html 文件创建好之后，在其中输入 ！，然后直接回车，就可以生成 HTML 的基础结构标签\n5). 编写标题排版的核心代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!-- 文档类型为HTML --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- 字符集为UTF-8 --\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;!-- 设置浏览器兼容性 --\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- img标签: src: 图片资源路径 width: 宽度(px, 像素 ; % , 相对于父元素的百分比) height: 高度(px, 像素 ; % , 相对于父元素的百分比) \u0026lt;img src=\u0026#34;img/news_logo.png\u0026#34; width=\u0026#34;80%\u0026#34; \u0026gt; 路径书写方式: 绝对路径: 1. 绝对磁盘路径: C:\\Users\\Administrator\\Desktop\\HTML\\img\\news_logo.png \u0026lt;img src=\u0026#34;C:\\Users\\Administrator\\Desktop\\HTML\\img\\news_logo.png\u0026#34;\u0026gt; 2. 绝对网络路径: https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png \u0026lt;img src=\u0026#34;https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png\u0026#34;\u0026gt; 相对路径: ./ : 当前目录 , ./ 可以省略的 ../: 上一级目录 --\u0026gt; \u0026lt;img src=\u0026#34;img/news_logo.png\u0026#34;\u0026gt; 新浪政务 \u0026gt; 正文 \u0026lt;h1\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; 2023年03月02日 21:50 央视网 \u0026lt;hr\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; # 2.3.1.2 标题样式 新浪新闻的标题部分的基本排版，我们已经完成了，然后大家会看到，我们编写的一级标题，默认字体颜色为纯黑色。 而原始的新浪新闻页面的新闻标题字体，并不是纯黑色，而是灰黑色， 那接下来，我们就要来设置这个字体的颜色。 而要设置这个字体的颜色，我们就需要通过CSS样式来控制 。\n那在HTML的文件中，我们如何来编写CSS样式呢，此时就涉及到CSS的三种引入方式。\n# 2.3.1.2.1 CSS引入方式 具体有3种引入方式，语法如下表格所示：\n名称 语法描述 示例 行内样式 在标签内使用style属性，属性值是css属性键值对 \u0026lt;h1 style=\u0026ldquo;xxx:xxx;\u0026quot;\u0026gt;中国新闻网\u0026lt;/h1\u0026gt; 内嵌样式 定义\u0026lt;style\u0026gt;标签，在标签内部定义css样式 \u0026lt;style\u0026gt; h1 {\u0026hellip;} \u0026lt;/style\u0026gt; 外联样式 定义\u0026lt;link\u0026gt;标签，通过href属性引入外部css文件 \u0026lt;link rel=\u0026ldquo;stylesheet\u0026rdquo; href=\u0026ldquo;css/news.css\u0026rdquo;\u0026gt; 对于上述3种引入方式，企业开发的使用情况如下：\n内联样式会出现大量的代码冗余，不方便后期的维护，所以不常用。 内部样式，通过定义css选择器，让样式作用于当前页面的指定的标签上。 外部样式，html和css实现了完全的分离，企业开发常用方式。 # 2.3.1.2.2 颜色表示 在前端程序开发中，颜色的表示方式常见的有如下三种：\n表示方式 表示含义 取值 关键字 预定义的颜色名 red、green、blue\u0026hellip; rgb表示法 红绿蓝三原色，每项取值范围：0-255 rgb(0,0,0)、rgb(255,255,255)、rgb(255,0,0) 十六进制表示法 #开头，将数字转换成十六进制表示 #000000、#ff0000、#cccccc，简写：#000、#ccc # 2.3.1.2.3 标题字体颜色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/title\u0026gt; \u0026lt;!-- 方式二: 内嵌样式 --\u0026gt; \u0026lt;style\u0026gt; h1 { /* color: red; */ /* color: rgb(0, 0, 255); */ color: #4D4F53; } \u0026lt;/style\u0026gt; \u0026lt;!-- 方式三: 外联样式 --\u0026gt; \u0026lt;!-- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/news.css\u0026#34;\u0026gt; --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;img/news_logo.png\u0026#34;\u0026gt; 新浪政务 \u0026gt; 正文 \u0026lt;!-- 方式一: 行内样式 --\u0026gt; \u0026lt;!-- \u0026lt;h1 style=\u0026#34;color: red;\u0026#34;\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/h1\u0026gt; --\u0026gt; \u0026lt;h1\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; 2023年03月02日 21:50 央视网 \u0026lt;hr\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 备注: 要想拾取某一个网页中的颜色，我们可以借助于浏览器的拾色器插件来完成。【拾色器插件的安装，参照资料中提供的文档即可】\n# 2.3.1.2.4 CSS选择器 顾名思义：选择器是选取需设置样式的元素（标签），但是我们根据业务场景不同，选择的标签的需求也是多种多样的，所以选择器有很多种，因为我们是做后台开发的，所以对于css选择器，我们只学习最基本的3种。\n选择器通用语法如下：\n1 2 3 4 选择器名 { css样式名：css样式值; css样式名：css样式值; } 我们需要学习的3种选择器是元素选择器，id选择器，class选择器，语法以及作用如下：\n1.元素（标签）选择器：\n选择器的名字必须是标签的名字 作用：选择器中的样式会作用于所有同名的标签上 1 2 3 元素名称 { css样式名:css样式值； } 例子如下：\n1 2 3 div{ color: red; } 2.id选择器:\n选择器的名字前面需要加上# 作用：选择器中的样式会作用于指定id的标签上，而且有且只有一个标签（由于id是唯一的） 1 2 3 #id属性值 { css样式名:css样式值； } 例子如下：\n1 2 3 #did { color: blue; } 3.类选择器：\n选择器的名字前面需要加上 . 作用：选择器中的样式会作用于所有class的属性值和该名字一样的标签上，可以是多个 1 2 3 .class属性值 { css样式名:css样式值； } 例子如下：\n1 2 3 .cls{ color: green; } # 2.3.1.2.5 发布时间字体颜色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h1 { color: #4D4F53; } /* 元素选择器 */ /* span { color: red; } */ /* 类选择器 */ /* .cls { color: green; } */ /* ID选择器 */ #time { color: #968D92; font-size: 13px; /* 设置字体大小 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;img/news_logo.png\u0026#34;\u0026gt; 新浪政务 \u0026gt; 正文 \u0026lt;h1\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;span class=\u0026#34;cls\u0026#34; id=\u0026#34;time\u0026#34;\u0026gt;2023年03月02日 21:50\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;cls\u0026#34;\u0026gt;央视网\u0026lt;/span\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上述我们还使用了一个css的属性 font-size , 用来设置字体的大小。 但是需要注意，在设置字体的大小时，单位px不能省略，否则不生效。\n# 2.3.1.3 超链接 在新浪新闻的标题部分，当我们点击顶部的 \u0026ldquo;新浪政务\u0026rdquo;，浏览器将自动在当前窗口访问新浪政务首页这个资源（http://gov.sina.com.cn/）\n当我们点击新闻发布时间之后的 \u0026ldquo;央视网\u0026rdquo;，浏览器将会自动打开一个新的标签页，然后在新的标签页中访问央视网中的该新闻资源 （https://news.cctv.com/2023/03/02/ARTIUCKFf9kE9eXgYE46ugx3230302.shtml）\n那接下来，我们就来完善新闻标题部分的这个功能，那此时呢，我们就需要用到HTML中的超链接的标签 。\n# 2.3.1.3.1 介绍 标签: \u0026lt;a href=\u0026rdquo;\u0026hellip;\u0026quot; target=\u0026quot;\u0026hellip;\u0026quot;\u0026gt;央视网 属性: href: 指定资源访问的url target: 指定在何处打开资源链接 _self: 默认值，在当前页面打开 _blank: 在空白页面打开 # 2.3.1.3.2 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h1 { color: #4D4F53; } #time { color: #968D92; font-size: 13px; /* 设置字体大小 */ } a { color: black; text-decoration: none; /* 设置文本为一个标准的文本 , 去除掉 超链接 下面默认的下划线 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;img/news_logo.png\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;http://gov.sina.com.cn/\u0026#34; target=\u0026#34;_self\u0026#34;\u0026gt;新浪政务\u0026lt;/a\u0026gt; \u0026gt; 正文 \u0026lt;h1\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;span id=\u0026#34;time\u0026#34;\u0026gt;2023年03月02日 21:50\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt; \u0026lt;a href=\u0026#34;https://news.cctv.com/2023/03/02/ARTIUCKFf9kE9eXgYE46ugx3230302.shtml\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;央视网\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 浏览器打开此页面，我们可以看到最终效果（超链接的字体，以及默认的下划线，通过css样式已经调整好了）：\n# 2.3.2 新浪新闻-正文实现 # 2.3.2.1 正文排版 # 2.3.2.1.1 分析 整个正文部分的排版，主要分为这么四个部分：\n1). 视频 (当前这种新闻页面,可能也会存在音频)\n2). 文字段落\n3). 字体加粗\n4). 图片\n# 2.3.2.1.2 标签 1). 视频、音频标签\n视频标签: \u0026lt;video\u0026gt;\n属性: src: 规定视频的url controls: 显示播放控件 width: 播放器的宽度 height: 播放器的高度 音频标签: \u0026lt;audio\u0026gt;\n属性: src: 规定音频的url controls: 显示播放控件 2). 段落标签\n换行标签: \u0026lt;br\u0026gt; 注意: 在HTML页面中,我们在编辑器中通过回车实现的换行, 仅仅在文本编辑器中会看到换行效果, 浏览器是不会解析的, HTML中换行需要通过br标签 ​\n段落标签: \u0026lt;p\u0026gt; 如: \u0026lt;p\u0026gt; 这是一个段落 \u0026lt;/p\u0026gt; 3). 文本格式标签\n效果 标签 标签(强调) 加粗 b strong 倾斜 i em 下划线 u ins 删除线 s del 前面的标签 b、i、u、s 就仅仅是实现加粗、倾斜、下划线、删除线的效果，是没有强调语义的。 而后面的strong、em、ins、del在实现加粗、倾斜、下划线、删除线的效果的同时，还带有强调语义。\n# 2.3.2.1.3 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h1 { color: #4D4F53; } #time { color: #968D92; font-size: 13px; /* 设置字体大小 */ } a { color: black; text-decoration: none; /* 设置文本为一个标准的文本 */ } p { text-indent: 35px; /* 设置首行缩进 */ line-height: 40px; /* 设置行高 */ } #plast { text-align: right; /* 对齐方式 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 标题 --\u0026gt; \u0026lt;img src=\u0026#34;img/news_logo.png\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;http://gov.sina.com.cn/\u0026#34; target=\u0026#34;_self\u0026#34;\u0026gt;新浪政务\u0026lt;/a\u0026gt; \u0026gt; 正文 \u0026lt;h1\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;span id=\u0026#34;time\u0026#34;\u0026gt;2023年03月02日 21:50\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;\u0026lt;a href=\u0026#34;https://news.cctv.com/2023/03/02/ARTIUCKFf9kE9eXgYE46ugx3230302.shtml\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;央视网\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;!-- 正文 --\u0026gt; \u0026lt;!-- 视频 --\u0026gt; \u0026lt;video src=\u0026#34;video/1.mp4\u0026#34; controls width=\u0026#34;950px\u0026#34;\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- 音频 --\u0026gt; \u0026lt;!-- \u0026lt;audio src=\u0026#34;audio/1.mp3\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; --\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;央视网消息\u0026lt;/strong\u0026gt; （焦点访谈）：党的十八大以来，以习近平同志为核心的党中央始终把解决粮食安全问题作为治国理政的头等大事，重农抓粮一系列政策举措有力有效，我国粮食产量站稳1.3万亿斤台阶，实现谷物基本自给、口粮绝对安全。我们把饭碗牢牢端在自己手中，为保障经济社会发展提供了坚实支撑，为应对各种风险挑战赢得了主动。连续八年1.3万亿斤，这个沉甸甸的数据是如何取得的呢？ \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 人勤春来早，春耕农事忙。立春之后，由南到北，我国春耕春管工作陆续展开，春天的田野处处生机盎然。 \u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;img/1.jpg\u0026#34;\u0026gt; \u0026lt;p\u0026gt; 今年，我国启动了新一轮千亿斤粮食产能提升行动，这是一个新的起点。2015年以来，我国粮食产量连续8年稳定在1.3万亿斤以上，人均粮食占有量始终稳稳高于国际公认的400公斤粮食安全线。从十年前的约12200亿斤到2022年的约13700亿斤，粮食产量提高了1500亿斤。 \u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;img/2.jpg\u0026#34;\u0026gt; \u0026lt;p\u0026gt; 中国式现代化一个重要的中国特色是人口规模巨大的现代化。我们粮食生产的发展，意味着我们要立足国内，解决14亿多人吃饭的问题。仓廪实，天下安。保障粮食安全是一个永恒的课题，任何时候都不能放松。在以习近平同志为核心的党中央坚强领导下，亿万中国人民辛勤耕耘、不懈奋斗，我们就一定能够牢牢守住粮食安全这一“国之大者”，把中国人的饭碗牢牢端在自己手中，夯实中国式现代化基础。 \u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;plast\u0026#34;\u0026gt; 责任编辑：王树淼 SN242 \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在上述的正文排版实现中，还用到了几个CSS属性：\ntext-indent: 设置段落的首行缩进 line-height: 设置行高 text-align: 设置对齐方式, 可取值为 left / center / right 注意事项:\n在HTML页面中无论输入了多少个空格, 最多只会显示一个。 可以使用空格占位符（\u0026amp;nbsp；）来生成空格，如果需要多个空格，就使用多次占位符。\n那在HTML中，除了空格占位符以外，还有一些其他的占位符(了解, 只需要知道空格的占位符写法即可)，如下：\n显示结果 描述 占位符 空格 \u0026amp;nbsp; \u0026lt; 小于号 \u0026amp;lt; \u0026gt; 大于号 \u0026amp;gt; \u0026amp; 和号 \u0026amp;amp; \u0026quot; 引号 \u0026amp;quot; ' 撇号 \u0026amp;apos; # 2.3.2.2 页面布局 目前，新闻页面的基本排版，我们都已经完成了，但是，大家会看到，无论是标题部分，还是正文部分，都是铺满了整个浏览器。 而我们再来看看新浪新闻的原始页面，我们会看到新闻网页内容都是居中展示的，左边、右边都是一定的边距的。\n那接下来呢，我们就需要按照这个效果，来完成页面布局。 而要想完成这样一个页面布局，我们就需要介绍一下CSS中的盒子模型 。\n# 2.3.2.2.1 盒子模型 盒子：页面中所有的元素（标签），都可以看做是一个 盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局\n盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）\nCSS盒子模型，其实和日常生活中的包装盒是非常类似的，就比如：\n盒子的大小，其实就包括三个部分： border、padding、content，而margin外边距是不包括在盒子之内的。\n# 2.3.2.2.2 布局标签 布局标签：实际开发网页中，会大量频繁的使用 div 和 span 这两个没有语义的布局标签。\n标签： 特点：\ndiv标签：\n一行只显示一个（独占一行）\n宽度默认是父元素的宽度，高度默认由内容撑开\n可以设置宽高（width、height）\nspan标签：\n一行可以显示多个\n宽度和高度默认由内容撑开\n不可以设置宽高（width、height）\n测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A \u0026lt;/div\u0026gt; \u0026lt;span\u0026gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A \u0026lt;/span\u0026gt; \u0026lt;span\u0026gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A \u0026lt;/span\u0026gt; \u0026lt;/body\u0026gt; 浏览器打开后的效果:\n1). div会独占一行，默认宽度为父元素 body 的宽度\n2). span一行会显示多个，用来组合行内元素，默认宽度为内容撑开的宽度\n# 2.3.2.2.3 盒子模型代码 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;盒子模型\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 200px; /* 宽度 */ height: 200px; /* 高度 */ box-sizing: border-box; /* 指定width height为盒子的高宽 */ background-color: aquamarine; /* 背景色 */ padding: 20px 20px 20px 20px; /* 内边距, 上 右 下 左 , 边距都一行, 可以简写: padding: 20px;*/ border: 10px solid red; /* 边框, 宽度 线条类型 颜色 */ margin: 30px 30px 30px 30px; /* 外边距, 上 右 下 左 , 边距都一行, 可以简写: margin: 30px; */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt; A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 代码编写好了, 可以通过浏览器打开该页面, 通过开发者工具,我们就可以看到盒子的大小, 以及盒子各个组成部分(内容、内边距、边框、外边距)：\n我们也可以，通过浏览器的开发者工具，清晰的看到这个盒子，以及每一个部分的大小：\n# 2.3.2.2.3 布局实现 在实现新闻页面的布局时，我们需要做两部操作：\n第一步：需要将body中的新闻标题部分、正文部分使用一个 div 布局标签将其包裹起来，方便通过css设置内容占用的宽度，比如：65%。 第二步：通过css为该div设置外边距，左右的外边距分别为：17.5%，上下外边距靠边展示即可，为：0%。 具体的代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; h1 { color: #4D4F53; } #time { color: #968D92; font-size: 13px; /* 设置字体大小 */ } a { color: black; text-decoration: none; /* 设置文本为一个标准的文本 */ } p { text-indent: 35px; /* 设置首行缩进 */ line-height: 40px; /* 设置行高 */ } #plast { text-align: right; /* 对齐方式 */ } #center { width: 65%; /* margin: 0% 17.5% 0% 17.5% ; */ /* 外边距, 上 右 下 左 */ margin: 0 auto; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;!-- 标题 --\u0026gt; \u0026lt;img src=\u0026#34;img/news_logo.png\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;http://gov.sina.com.cn/\u0026#34; target=\u0026#34;_self\u0026#34;\u0026gt;新浪政务\u0026lt;/a\u0026gt; \u0026gt; 正文 \u0026lt;h1\u0026gt;焦点访谈：中国底气 新思想夯实大国粮仓\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;span id=\u0026#34;time\u0026#34;\u0026gt;2023年03月02日 21:50\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;\u0026lt;a href=\u0026#34;https://news.cctv.com/2023/03/02/ARTIUCKFf9kE9eXgYE46ugx3230302.shtml\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;央视网\u0026lt;/a\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;!-- 正文 --\u0026gt; \u0026lt;!-- 视频 --\u0026gt; \u0026lt;video src=\u0026#34;video/1.mp4\u0026#34; controls width=\u0026#34;950px\u0026#34;\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;!-- 音频 --\u0026gt; \u0026lt;!-- \u0026lt;audio src=\u0026#34;audio/1.mp3\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; --\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;央视网消息\u0026lt;/strong\u0026gt; （焦点访谈）：党的十八大以来，以习近平同志为核心的党中央始终把解决粮食安全问题作为治国理政的头等大事，重农抓粮一系列政策举措有力有效，我国粮食产量站稳1.3万亿斤台阶，实现谷物基本自给、口粮绝对安全。我们把饭碗牢牢端在自己手中，为保障经济社会发展提供了坚实支撑，为应对各种风险挑战赢得了主动。连续八年1.3万亿斤，这个沉甸甸的数据是如何取得的呢？ \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; 人勤春来早，春耕农事忙。立春之后，由南到北，我国春耕春管工作陆续展开，春天的田野处处生机盎然。 \u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;img/1.jpg\u0026#34;\u0026gt; \u0026lt;p\u0026gt; 今年，我国启动了新一轮千亿斤粮食产能提升行动，这是一个新的起点。2015年以来，我国粮食产量连续8年稳定在1.3万亿斤以上，人均粮食占有量始终稳稳高于国际公认的400公斤粮食安全线。从十年前的约12200亿斤到2022年的约13700亿斤，粮食产量提高了1500亿斤。 \u0026lt;/p\u0026gt; \u0026lt;img src=\u0026#34;img/2.jpg\u0026#34;\u0026gt; \u0026lt;p\u0026gt; 中国式现代化一个重要的中国特色是人口规模巨大的现代化。我们粮食生产的发展，意味着我们要立足国内，解决14亿多人吃饭的问题。仓廪实，天下安。保障粮食安全是一个永恒的课题，任何时候都不能放松。在以习近平同志为核心的党中央坚强领导下，亿万中国人民辛勤耕耘、不懈奋斗，我们就一定能够牢牢守住粮食安全这一“国之大者”，把中国人的饭碗牢牢端在自己手中，夯实中国式现代化基础。 \u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;plast\u0026#34;\u0026gt; 责任编辑：王树淼 SN242 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 浏览器打开此页面，最终效果如下：\n# 2.4 表格标签 **场景：**在网页中以表格（行、列）形式整齐展示数据，我们在一些管理类的系统中，会看到数据通常都是以表格的形式呈现出来的，比如：班级表、学生表、课程表、成绩表等等。\n标签：\n\u0026lt;table\u0026gt; : 用于定义整个表格, 可以包裹多个 \u0026lt;tr\u0026gt;， 常用属性如下：\nborder：规定表格边框的宽度 width：规定表格的宽度 cellspacing: 规定单元之间的空间 \u0026lt;tr\u0026gt; : 表格的行，可以包裹多个 \u0026lt;td\u0026gt;\n\u0026lt;td\u0026gt; : 表格单元格(普通)，可以包裹内容 , 如果是表头单元格，可以替换为 \u0026lt;th\u0026gt;\n演示：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML-表格\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; td { text-align: center; /* 单元格内容居中展示 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table border=\u0026#34;1px\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;600px\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;序号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;品牌Logo\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;品牌名称\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;企业名称\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img src=\u0026#34;img/huawei.jpg\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;华为\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;华为技术有限公司\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img src=\u0026#34;img/alibaba.jpg\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;阿里\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;阿里巴巴集团控股有限公司\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打开浏览器，效果如下图所示：\n整合表格使用 table 标签包裹 , 其中的每一行数据都是一个 tr , 每一行中的每一个单元格都是一个 td , 而如果是表头单元格, 可以使用 th (具有加粗居中展示的效果)。\n# 2.5 表单标签 # 2.5.1 表单 # 2.5.1.1 介绍 那表单呢,在我们日常的上网的过程中,基本上每天都会遇到。比如，我们经常在访问网站时，出现的登录页面、注册页面、个人信息提交页面，其实都是一个一个的表单 。 当我们在这些表单中录入数据之后，一点击 \u0026ldquo;提交\u0026rdquo;，就会将表单中我们填写的数据采集到，并提交， 那其实这个数据呢，一般会提交到服务端，最终保存在数据库中 （后面的课程中会讲到）。\n那其实，上述的整个窗口是一个表单，而表单是一项一项的，这个我们称为表单项 或 表单元素。\n表单场景: 表单就是在网页中负责数据采集功能的，如：注册、登录的表单。\n表单标签: \u0026lt;form\u0026gt;\n表单属性:\naction: 规定表单提交时，向何处发送表单数据，表单提交的URL。 method: 规定用于发送表单数据的方式，常见为： GET、POST。 GET：表单数据是拼接在url后面的， 如： xxxxxxxxxxx?username=Tom\u0026amp;age=12，url中能携带的表单数据大小是有限制的。 POST： 表单数据是在请求体（消息体）中携带的，大小没有限制。 表单项标签: 不同类型的input元素、下拉列表、文本域等。\ninput: 定义表单项，通过type属性控制输入形式 select: 定义下拉列表 textarea: 定义文本域 # 2.5.1.2 通过GET/POST提交表单 1). GET方式提交的表单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML-表单\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- form表单属性: action: 表单提交的url, 往何处提交数据 . 如果不指定, 默认提交到当前页面 method: 表单的提交方式 . get: 在url后面拼接表单数据, 比如: ?username=Tom\u0026amp;age=12 , url长度有限制 . 默认值 post: 在消息体(请求体)中传递的, 参数大小无限制的. --\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; 用户名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; 年龄: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表单编写完毕之后，通过浏览器打开此表单，然后再表单项中录入值之后，点击提交，我们会看到表单的数据在url后面提交到服务端，格式为：?username=Tom\u0026amp;age=12。\n2). POST方式提交表单\n将上述的表单提交方式由get，改为post\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML-表单\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- form表单属性: action: 表单提交的url, 往何处提交数据 . 如果不指定, 默认提交到当前页面 method: 表单的提交方式 . get: 在url后面拼接表单数据, 比如: ?username=Tom\u0026amp;age=12 , url长度有限制 . 默认值 post: 在消息体(请求体)中传递的, 参数大小无限制的. --\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 用户名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; 年龄: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表单编写完毕之后，通过浏览器打开此表单，然后再表单项中录入值之后，点击提交，我们会看到表单的数据在url后面提交到服务端，格式为：?username=Tom\u0026amp;age=12。\n# 2.5.1.3 注意事项 表单中的所有表单项，要想能够正常的采集数据，在提交的时候能提交到服务端，表单项必须指定name属性。 否则，无法提交该表单项。\n1 用户名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; # 2.5.2 表单项 # 2.5.2.1 介绍 在一个表单中，可以存在很多的表单项，而虽然表单项的形式各式各样，但是表单项的标签其实就只有三个，分别是：\n\u0026lt;input\u0026gt;: 表单项 , 通过type属性控制输入形式。\ntype取值 描述 text 默认值，定义单行的输入字段 password 定义密码字段 radio 定义单选按钮 checkbox 定义复选框 file 定义文件上传按钮 date/time/datetime-local 定义日期/时间/日期时间 number 定义数字输入框 email 定义邮件输入框 hidden 定义隐藏域（不会在界面上显示，可以用来提交默认值） submit / reset / button 定义提交按钮 / 重置按钮 / 可点击按钮 \u0026lt;select\u0026gt;: 定义下拉列表, \u0026lt;option\u0026gt; 定义列表项\n\u0026lt;textarea\u0026gt;: 文本域\n# 2.5.2.2 演示 创建一个新的表单项的html文件，具体内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML-表单项标签\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- value: 表单项提交的值 --\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 姓名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 密码: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 性别: \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; 男 \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt; 女 \u0026lt;/label\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 爱好: \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;java\u0026#34;\u0026gt; java \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;game\u0026#34;\u0026gt; game \u0026lt;/label\u0026gt; \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34; value=\u0026#34;sing\u0026#34;\u0026gt; sing \u0026lt;/label\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 图像: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;image\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 生日: \u0026lt;input type=\u0026#34;date\u0026#34; name=\u0026#34;birthday\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 时间: \u0026lt;input type=\u0026#34;time\u0026#34; name=\u0026#34;time\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 日期时间: \u0026lt;input type=\u0026#34;datetime-local\u0026#34; name=\u0026#34;datetime\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 邮箱: \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 年龄: \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 学历: \u0026lt;select name=\u0026#34;degree\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34;\u0026gt;----------- 请选择 -----------\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;大专\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;本科\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;3\u0026#34;\u0026gt;硕士\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;4\u0026#34;\u0026gt;博士\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; 描述: \u0026lt;textarea name=\u0026#34;description\u0026#34; cols=\u0026#34;30\u0026#34; rows=\u0026#34;10\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;id\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;!-- 表单常见按钮 --\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;按钮\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;reset\u0026#34; value=\u0026#34;重置\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 通过浏览器打开上述的表单项html文件，最终展示出的表单信息如下：\n而对于input type=\u0026ldquo;hidden\u0026rdquo;，是一个隐藏域，在表单中并不会显示出来，但是在提交表单的时候，是会提交到服务端的。 接下来，我们就点击提交按钮，来提交当前表单，看看提交的数据：\n# 3. 文档查阅 文档地址: https://www.w3school.com.cn/index.html\n# 3.1 HTML文档查阅 以video标签为例:\n# 3.2 CSS文档查阅 以padding属性为例:\n","date":"2024-04-27T11:47:14+08:00","permalink":"http://localhost:1313/p/htmlcss%E5%9F%BA%E7%A1%80/","title":"Html、css基础"},{"content":" # Web开发介绍 # 1 什么是web开发 Web：全球广域网，也称为万维网(www World Wide Web)，能够通过浏览器访问的网站。\n所以Web开发说白了，就是开发网站的，例如下图所示的网站：淘宝，京东等等\n那么我们知道了web开发是开发网站的，那么我们需要学习哪些知识呢？以及这些知识在我们整个网站开发中占据什么位置呢？对于这些问题，我们就必须知道网站整体的工作流程。\n# 2 网站的工作流程 接下来我们先来看看网站的工作流程，这样才能在我们的脑海中构建初步的知识架构体系。\n1.首先我们需要通过浏览器访问发布到前端服务器中的前端程序，这时候前端程序会将前端代码返回给浏览器。如下图所示：\n2.浏览器得到前端代码，此时浏览器会将前端代码进行解析，然后展示到浏览器的窗口中，这时候我们就看到了网站的页面，如下图所示：\n3.但是此时这个页面是没有数据的，因为数据在我们的数据库中，所以我们浏览器需要根据前端代码中指定的后台服务器的地址 向 我们的后台服务器（内部有java程序）发起请求，后台服务器再去从数据库中获取数据，然后返回给浏览器。\n4.浏览器拿到后台返回的数据后，然后将数据展示在前端资源也就是网页上，然后我们就看到了如下图所示的完整的内容\n整个流程如下：\n1.浏览器先向前端服务器请求前端资源，也就是我们所说的网页\n2.浏览器再向后台服务器发起请求，获取数据\n3.浏览器将得到的后台数据填充到网页上，然后展示给用户去看\n# 3 网站的开发模式 接下来我们来聊聊网站的开发模式，主要有2种：前端台分离和混合开发\n前后台分离：（**目前企业开发的主流，**市场占有率70%以上）这种开发模式的特点如下\n前端人员开发前端程序，前端程序单独部署到前端服务器上\n后端人员开开发后端程序，后端程序单独部署到后端服务器上\n混合开发：（早期的开发技术，目前慢慢退出市场），这种开发模式的特点是：前端人员开发的代码和后端人员开发的代码在同一个项目中，一起打包部署。\n# 4 网站的开发技术 最后我们来看看web阶段需要学习哪些技术呢？如下图我们列举了课程中需要学习的知识点\n以下是图表的方式整理了我们web阶段要学习的技术和其对应的作用\n前端web开发：\n技术 描述 HTML 用于构建网站的基础结构的 css 用于美化页面的，作用和化妆或者整容作用一样 JavaScript 实现网页和用户的交互 Vue 主要用于将数据填充到html页面上的 Element 主要提供了一些非常美观的组件 Nginx 一款web服务器软件，可以用于部署我们的前端工程 后端web开发：\n技术 描述 Maven 一款java中用于管理项目的软件 Mysql 最常用的一款数据库软件之一 SpringBoot spring家族的产品，当前最为主流的项目开发技术。 Mybatis 用于操作数据库的框架 所以只有我们学完上述的技术，我们才能开发出一个麻雀虽小，五脏俱全的网站。\n​\n","date":"2024-04-27T11:46:06+08:00","permalink":"http://localhost:1313/p/web%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/","title":"Web开发概述"},{"content":" # Java网络编程 # 一、网络编程概述 同学们，今天我们学习的课程内容叫网络编程。意思就是编写的应用程序可以与网络上其他设备中的应用程序进行数据交互。\n网络编程有什么用呢？这个就不言而喻了，比如我们经常用的微信收发消息就需要用到网络通信的技术、在比如我们打开浏览器可以浏览各种网络、视频等也需要用到网络编程的技术。\n我们知道什么是网络编程、也知道网络编程能干什么后了，那Java给我们提供了哪些网络编程的解决方案呢？\nJava提供的网络编程的解决方案都是在java.net包下。在正式学习Java网络编程技术之前，我们还需要学习一些网络通信的前置知识理论知识，只有这些前置知识做基础，我们学习网络编程代码编写才起来才能继续下去。\n首先和同学们聊聊网络通信的基本架构。通信的基本架构主要有两种形式：一种是CS架构（Client 客户端/Server服务端）、一种是BS架构（Brower 浏览器/Server服务端）。\n**CS架构的特点：**CS架构需要用户在自己的电脑或者手机上安装客户端软件，然后由客户端软件通过网络连接服务器程序，由服务器把数据发给客户端，客户端就可以在页面上看到各种数据了。 **BS架构的特点：**BS架构不需要开发客户端软件，用户只需要通过浏览器输入网址就可以直接从服务器获取数据，并由服务器将数据返回给浏览器，用户在页面上就可以看到各种数据了。\n这两种结构不管是CS、还是BS都是需要用到网络编程的相关技术。我们学习Java的程序员，以后从事的工作方向主要还是BS架构的。\n# 二、网络编程三要素 各位小伙伴，我们前面已经知道什么是网络编程了。接下来我们还需要学习一些网络编程的基本概念，才能去编写网络编程的应用程序。\n有哪三要素呢？分别是IP地址、端口号、通信协议\nIP地址：表示设备在网络中的地址，是网络中设备的唯一标识\n端口号：应用程序在设备中唯一的标识\n协议：连接和数据在网络中传输的规则。\n如下图所示：假设现在要从一台电脑中的微信上，发一句“你愁啥？”到其他电脑的微信上，流程如下\n1 2 3 1.先通过ip地址找到对方的电脑 2.再通过端口号找到对方的电脑上的应用程序 3.按照双方约定好的规则发送、接收数据 # 2.1 IP地址 接下来，我们详细介绍一下IP地址。**IP（Ineternet Protocol）全称互联网协议地址，是分配给网络设备的唯一表示。**IP地址分为：IPV4地址、IPV6地址\nIPV4地址由32个比特位（4个字节）组成，如果下图所示，但是由于采用二进制太不容易阅读了，于是就将每8位看成一组，把每一组用十进制表示（叫做点分十进制表示法）。所以就有了我们经常看到的IP地址形式，如：192.168.1.66\n如果想查看本机的IP地址，可以在命令行窗口，输入ipconfig命令查看，如下图所示\n经过不断的发展，现在越来越多的设备需要联网，IPV4地址已经不够用了，所以扩展出来了IPV6地址。\nIPV6采用128位二进制数据来表示（16个字节），号称可以为地球上的每一粒沙子编一个IP地址，\nIPV6比较长，为了方便阅读，每16位编成一组，每组采用十六进制数据表示，然后用冒号隔开（称为冒分十六进制表示法），如下图所示\n我们在命令行窗口输入ipconfig命令，同样可以看到ipv6地址，如下图所示\n现在的网络设备，一般IPV4和IPV6地址都是支持的。\n聊完什么是IP地址和IP地址分类之后，接下来再给大家介绍一下和IP地址相关的一个东西，叫做域名。\n我们在浏览器上访问某一个网站是，就需要在浏览器的地址栏输入网址，这个网址的专业说法叫做域名。比如：传智播客的域名是http://www.itcast.cn。\n域名和IP其实是一一对应的，由运营商来管理域名和IP的对应关系。我们在浏览器上敲一个域名时，首先由运营商的域名解析服务，把域名转换为ip地址，再通过IP地址去访问对应的服务器设备。\n关于IP地址，还有一个特殊的地址需要我们记住一下。就是我们在学习阶段进行测试时，经常会自己给自己消息，需要用到一个本地回送地址：127.0.0.1\n最后给同学们介绍，两个和IP地址相关的命令\n1 2 ipconfig: 查看本机的ip地址 ping 域名/ip 检测当前电脑与指定的ip是否连通 ping命令出现以下的提示，说明网络是通过的\n# 2.2 InetAddress类 各位小伙伴，在上一节课我们学习了网络编程的三要素之一，IP地址。按照面向对象的设计思想，Java中也有一个类用来表IP地址，这个类是InetAddress类。我们在开发网络通信程序的时候，可能有时候会获取本机的IP地址，以及测试与其他地址是否连通，这个时候就可以使用InetAddress类来完成。下面学习几个InetAddress的方法。\n演示上面几个方法的效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class InetAddressTest { public static void main(String[] args) throws Exception { // 1、获取本机IP地址对象的 InetAddress ip1 = InetAddress.getLocalHost(); System.out.println(ip1.getHostName()); System.out.println(ip1.getHostAddress()); // 2、获取指定IP或者域名的IP地址对象。 InetAddress ip2 = InetAddress.getByName(\u0026#34;www.baidu.com\u0026#34;); System.out.println(ip2.getHostName()); System.out.println(ip2.getHostAddress()); // ping www.baidu.com System.out.println(ip2.isReachable(6000)); } } # 2.3 端口号 端口号：指的是计算机设备上运行的应用程序的标识，被规定为一个16位的二进制数据，范围（0~65535）\n端口号分为一下几类（了解一下）\n周知端口：0~1023，被预先定义的知名应用程序占用（如：HTTP占用80，FTP占用21） 注册端口：1024~49151，分配给用户经常或者某些应用程序 动态端口：49152~65536，之所以称为动态端口，是因为它一般不固定分配给某进程，而是动态分配的。 需要我们注意的是，同一个计算机设备中，不能出现两个应用程序，用同一个端口号\n# 2.4 协议 各位同学，前面我们已经学习了IP地址和端口号，但是想要完成数据通信还需要有通信协议。\n网络上通信的设备，事先规定的连接规则，以及传输数据的规则被称为网络通信协议。\n为了让世界上各种上网设备能够互联互通，肯定需要有一个组织出来，指定一个规则，大家都遵守这个规则，才能进行数据通信。\n只要按照OSI网络参考模型制造的设备，就可以在国际互联网上互联互通。其中传输层有两个协议，是我们今天会接触到的（UDP协议、TCP协议）\nUDP协议特点 TPC协议特点 三次握手如下图所示**：目的是确认通信双方，收法消息都是正常没问题的**\n四次挥手如下图所示：目的是确保双方数据的收发已经完成，没有数据丢失\n# 三、UDP通信代码（入门案例） 有了网络编程的三要素基础知识之后，我们就可以开始学习编写网络通信的程序了。首先学习基于UDP协议通信的代码编写。\nUDP是面向无连接的、不需要确认双方是否存在，所以它是不可靠的协议。Java提供了一个类叫DatagramSocket来完成基于UDP协议的收发数据。使用DatagramSocket收发数据时，数据要以数据包的形式体现，一个数据包限制在64KB以内\n具体流程如下图所示：假设我们把DatagramSocket看做是街道两边的人，现在左边的人要扔一盘韭菜到右边，这里的韭菜就是数据，但是数据需要用一个盘子装起来，这里的盘子就是DatagramPacket数据包的意思。通信双方都需要有DatagramSocket(扔、接韭菜人)，还需要有DatagramPacket(装韭菜的盘子)\n下面我们看一个案例，需要有两个程序，一个表示客户端程序，一个表示服务端程序。\n需求：客户端程序发一个字符串数据给服务端，服务端程序接收数据并打印。\n# 3.1 客户端程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 目标：完成UDP通信快速入门：实现1发1收。 */ public class Client { public static void main(String[] args) throws Exception { // 1、创建客户端对象（发韭菜出去的人） DatagramSocket socket = new DatagramSocket(7777); // 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子） /* public DatagramPacket(byte buf[], int length, InetAddress address, int port) 参数一：封装要发出去的数据。 参数二：发送出去的数据大小（字节个数） 参数三：服务端的IP地址（找到服务端主机） 参数四：服务端程序的端口。 */ byte[] bytes = \u0026#34;我是快乐的客户端，我爱你abc\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(bytes, bytes.length , InetAddress.getLocalHost(), 6666); // 3、开始正式发送这个数据包的数据出去了 socket.send(packet); System.out.println(\u0026#34;客户端数据发送完毕~~~\u0026#34;); socket.close(); // 释放资源！ } } # 3.2 服务端程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Server { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;----服务端启动----\u0026#34;); // 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口 DatagramSocket socket = new DatagramSocket(6666); // 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子） byte[] buffer = new byte[1024 * 64]; // 64KB. DatagramPacket packet = new DatagramPacket(buffer, buffer.length); // 3、开始正式使用数据包来接收客户端发来的数据 socket.receive(packet); // 4、从字节数组中，把接收到的数据直接打印出来 // 接收多少就倒出多少 // 获取本次数据包接收了多少数据。 int len = packet.getLength(); String rs = new String(buffer, 0 , len); System.out.println(rs); System.out.println(packet.getAddress().getHostAddress()); System.out.println(packet.getPort()); socket.close(); // 释放资源 } } # 四、UDP通信代码（多发多收） 刚才的案例，我们只能客户端发一次，服务端接收一次就结束了。下面我们想把这个代码改进一下，\n需求：实现客户端不断的发数据，而服务端能不断的接收数据，客户端发送exit时客户端程序退出。\n# 4.1 客户端程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * 目标：完成UDP通信快速入门：实现客户端反复的发。 */ public class Client { public static void main(String[] args) throws Exception { // 1、创建客户端对象（发韭菜出去的人） DatagramSocket socket = new DatagramSocket(); // 2、创建数据包对象封装要发出去的数据（创建一个韭菜盘子） /* public DatagramPacket(byte buf[], int length, InetAddress address, int port) 参数一：封装要发出去的数据。 参数二：发送出去的数据大小（字节个数） 参数三：服务端的IP地址（找到服务端主机） 参数四：服务端程序的端口。 */ Scanner sc = new Scanner(System.in); while (true) { System.out.println(\u0026#34;请说：\u0026#34;); String msg = sc.nextLine(); // 一旦发现用户输入的exit命令，就退出客户端 if(\u0026#34;exit\u0026#34;.equals(msg)){ System.out.println(\u0026#34;欢迎下次光临！退出成功！\u0026#34;); socket.close(); // 释放资源 break; // 跳出死循环 } byte[] bytes = msg.getBytes(); DatagramPacket packet = new DatagramPacket(bytes, bytes.length , InetAddress.getLocalHost(), 6666); // 3、开始正式发送这个数据包的数据出去了 socket.send(packet); } } } # 4.2 服务端程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 目标：完成UDP通信快速入门-服务端反复的收 */ public class Server { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;----服务端启动----\u0026#34;); // 1、创建一个服务端对象（创建一个接韭菜的人） 注册端口 DatagramSocket socket = new DatagramSocket(6666); // 2、创建一个数据包对象，用于接收数据的（创建一个韭菜盘子） byte[] buffer = new byte[1024 * 64]; // 64KB. DatagramPacket packet = new DatagramPacket(buffer, buffer.length); while (true) { // 3、开始正式使用数据包来接收客户端发来的数据 socket.receive(packet); // 4、从字节数组中，把接收到的数据直接打印出来 // 接收多少就倒出多少 // 获取本次数据包接收了多少数据。 int len = packet.getLength(); String rs = new String(buffer, 0 , len); System.out.println(rs); System.out.println(packet.getAddress().getHostAddress()); System.out.println(packet.getPort()); System.out.println(\u0026#34;--------------------------------------\u0026#34;); } } } # 五、TCP通信（一发一收） 学习完UDP通信的代码编写之后，接下来我们学习TCP通信的代码如何编写。Java提供了一个java.net.Socket类来完成TCP通信。\n我们先讲一下Socket完成TCP通信的流程，再讲代码怎么编写就很好理解了。如下图所示\n当创建Socket对象时，就会在客户端和服务端创建一个数据通信的管道，在客户端和服务端两边都会有一个Socket对象来访问这个通信管道。 现在假设客户端要发送一个“在一起”给服务端，客户端这边先需要通过Socket对象获取到一个字节输出流，通过字节输出流写数据到服务端 然后服务端这边通过Socket对象可以获取字节输入流，通过字节输入流就可以读取客户端写过来的数据，并对数据进行处理。 服务端处理完数据之后，假设需要把“没感觉”发给客户端端，那么服务端这边再通过Socket获取到一个字节输出流，将数据写给客户端 客户端这边再获取输入流，通过字节输入流来读取服务端写过来的数据。 # 5.1 TCP客户端 下面我们写一个客户端，用来往服务端发数据。由于原始的字节流不是很好用，这里根据我的经验，我原始的OutputStream包装为DataOutputStream是比较好用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 目标：完成TCP通信快速入门-客户端开发：实现1发1收。 */ public class Client { public static void main(String[] args) throws Exception { // 1、创建Socket对象，并同时请求与服务端程序的连接。 Socket socket = new Socket(\u0026#34;127.0.0.1\u0026#34;, 8888); // 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。 OutputStream os = socket.getOutputStream(); // 3、把低级的字节输出流包装成数据输出流 DataOutputStream dos = new DataOutputStream(os); // 4、开始写数据出去了 dos.writeUTF(\u0026#34;在一起，好吗？\u0026#34;); dos.close(); socket.close(); // 释放连接资源 } } # 5.2 TCP服务端 上面我们只是写了TCP客户端，还没有服务端，接下来我们把服务端写一下。这里的服务端用来接收客户端发过来的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * 目标：完成TCP通信快速入门-服务端开发：实现1发1收。 */ public class Server { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;-----服务端启动成功-------\u0026#34;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8888); // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3、从socket通信管道中得到一个字节输入流。 InputStream is = socket.getInputStream(); // 4、把原始的字节输入流包装成数据输入流 DataInputStream dis = new DataInputStream(is); // 5、使用数据输入流读取客户端发送过来的消息 String rs = dis.readUTF(); System.out.println(rs); // 其实我们也可以获取客户端的IP地址 System.out.println(socket.getRemoteSocketAddress()); dis.close(); socket.close(); } } # 六、TCP通信（多发多收） 到目前为止，我们已经完成了客户端发送消息、服务端接收消息，但是客户端只能发一次，服务端只能接收一次。现在我想要客户端能过一直发消息，服务端能够一直接收消息。\n下面我们把客户端代码改写一下，采用键盘录入的方式发消息，为了让客户端能够一直发，我们只需要将发送消息的代码套一层循环就可以了，当用户输入exit时，客户端退出循环并结束客户端。\n# 6.1 TCP客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 目标：完成TCP通信快速入门-客户端开发：实现客户端可以反复的发消息出去 */ public class Client { public static void main(String[] args) throws Exception { // 1、创建Socket对象，并同时请求与服务端程序的连接。 Socket socket = new Socket(\u0026#34;127.0.0.1\u0026#34;, 8888); // 2、从socket通信管道中得到一个字节输出流，用来发数据给服务端程序。 OutputStream os = socket.getOutputStream(); // 3、把低级的字节输出流包装成数据输出流 DataOutputStream dos = new DataOutputStream(os); Scanner sc = new Scanner(System.in); while (true) { System.out.println(\u0026#34;请说：\u0026#34;); String msg = sc.nextLine(); // 一旦用户输入了exit，就退出客户端程序 if(\u0026#34;exit\u0026#34;.equals(msg)){ System.out.println(\u0026#34;欢迎您下次光临！退出成功！\u0026#34;); dos.close(); socket.close(); break; } // 4、开始写数据出去了 dos.writeUTF(msg); dos.flush(); } } } # 6.2 TCP服务端 为了让服务端能够一直接收客户端发过来的消息，服务端代码也得改写一下。我们只需要将读取数据的代码加一个循环就可以了。\n但是需要我们注意的时，如果客户端Socket退出之后，就表示连接客户端与服务端的数据通道被关闭了，这时服务端就会出现异常。服务端可以通过出异常来判断客户端下线了，所以可以用try\u0026hellip;catch把读取客户端数据的代码套一起来，catch捕获到异常后，打印客户端下线。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * 目标：完成TCP通信快速入门-服务端开发：实现服务端反复发消息 */ public class Server { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;-----服务端启动成功-------\u0026#34;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8888); // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3、从socket通信管道中得到一个字节输入流。 InputStream is = socket.getInputStream(); // 4、把原始的字节输入流包装成数据输入流 DataInputStream dis = new DataInputStream(is); while (true) { try { // 5、使用数据输入流读取客户端发送过来的消息 String rs = dis.readUTF(); System.out.println(rs); } catch (Exception e) { System.out.println(socket.getRemoteSocketAddress() + \u0026#34;离线了！\u0026#34;); dis.close(); socket.close(); break; } } } } # 七、TCP通信（多线程改进） 上一个案例中我们写的服务端程序只能和一个客户端通信，如果有多个客户端连接服务端，此时服务端是不支持的。\n为了让服务端能够支持多个客户端通信，就需要用到多线程技术。具体的实现思路如下图所示：每当有一个客户端连接服务端，在服务端这边就为Socket开启一条线程取执行读取数据的操作，来多少个客户端，就有多少条线程。按照这样的设计，服务端就可以支持多个客户端连接了。\n按照上面的思路，改写服务端代码。\n# 7.1 多线程改进 首先，我们需要写一个服务端的读取数据的线程类，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class ServerReaderThread extends Thread{ private Socket socket; public ServerReaderThread(Socket socket){ this.socket = socket; } @Override public void run() { try { InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true){ try { String msg = dis.readUTF(); System.out.println(msg); } catch (Exception e) { System.out.println(\u0026#34;有人下线了：\u0026#34; + socket.getRemoteSocketAddress()); dis.close(); socket.close(); break; } } } catch (Exception e) { e.printStackTrace(); } } } 接下来，再改写服务端的主程序代码，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。 */ public class Server { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;-----服务端启动成功-------\u0026#34;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8888); while (true) { // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); System.out.println(\u0026#34;有人上线了：\u0026#34; + socket.getRemoteSocketAddress()); // 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。 new ServerReaderThread(socket).start(); } } } # 7.2 案例拓展（群聊） 接着前面的案例，下面我们案例再次拓展一下，这个并不需要同学们必须掌握，主要是为了锻炼同学们的编程能力、和编程思维。\n我们想把刚才的案例，改进成全能够实现群聊的效果，就是一个客户端发的消息，其他的每一个客户端都可以收到。\n刚才我们写的多个客户端可以往服务端发现消息，但是客户端和客户端是不能直接通信的。想要试下全群聊的效果，我们还是必须要有服务端在中间做中转。 具体实现方案如下图所示：\n我们可以在服务端创建一个存储Socket的集合，每当一个客户端连接服务端，就可以把客户端Socket存储起来；当一个客户端给服务端发消息时，再遍历集合通过每个Socket将消息再转发给其他客户端。\n下面我们改造服务端代码，由于服务端读取数据是在线程类中完成的，所以我们改SerReaderThread类就可以了。服务端的主程序不用改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class ServerReaderThread extends Thread{ private Socket socket; public ServerReaderThread(Socket socket){ this.socket = socket; } @Override public void run() { try { InputStream is = socket.getInputStream(); DataInputStream dis = new DataInputStream(is); while (true){ try { String msg = dis.readUTF(); System.out.println(msg); // 把这个消息分发给全部客户端进行接收。 sendMsgToAll(msg); } catch (Exception e) { System.out.println(\u0026#34;有人下线了：\u0026#34; + socket.getRemoteSocketAddress()); Server.onLineSockets.remove(socket); dis.close(); socket.close(); break; } } } catch (Exception e) { e.printStackTrace(); } } private void sendMsgToAll(String msg) throws IOException { // 发送给全部在线的socket管道接收。 for (Socket onLineSocket : Server.onLineSockets) { OutputStream os = onLineSocket.getOutputStream(); DataOutputStream dos = new DataOutputStream(os); dos.writeUTF(msg); dos.flush(); } } } # 八、BS架构程序（简易版） 前面我们所写的代码都是基于CS架构的。我们说网络编程还可以编写BS架构的程序，为了让同学们体验一下BS架构通信，这里我们写一个简易版的程序。仅仅只是体验下一，后期我们会详细学习BS架构的程序如何编写。\nBS架构程序的实现原理，如下图所示：不需要开发客户端程序，此时浏览器就相当于是客户端，此时我们只需要写服务端程序就可以了。\n在BS结构的程序中，浏览器和服务器通信是基于HTTP协议来完成的，浏览器给客户端发送数据需要按照HTTP协议规定好的数据格式发给服务端，服务端返回数据时也需要按照HTTP协议规定好的数据给是发给浏览器，只有这两双方才能完成一次数据交互。\n客户端程序不需要我们编写（浏览器就是），所以我们只需要写服务端就可以了。\n服务端给客户端响应数据的数据格式（HTTP协议规定数据格式）如下图所示：左图是数据格式，右图是示例。\n接下来，我们写一个服务端程序按照右图示例的样子，给浏览器返回数据。注意：数据是由多行组成的，必须按照规定的格式来写。\n# 8.1 服务端程序 先写一个线程类，用于按照HTTP协议的格式返回数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ServerReaderThread extends Thread{ private Socket socket; public ServerReaderThread(Socket socket){ this.socket = socket; } @Override public void run() { // 立即响应一个网页内容：“黑马程序员”给浏览器展示。 try { OutputStream os = socket.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(\u0026#34;HTTP/1.1 200 OK\u0026#34;); ps.println(\u0026#34;Content-Type:text/html;charset=UTF-8\u0026#34;); ps.println(); // 必须换行 ps.println(\u0026#34;\u0026lt;div style=\u0026#39;color:red;font-size:120px;text-align:center\u0026#39;\u0026gt;黑马程序员666\u0026lt;div\u0026gt;\u0026#34;); ps.close(); socket.close(); } catch (Exception e) { e.printStackTrace(); } } } 再写服务端的主程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * 目标：完成TCP通信快速入门-服务端开发：要求实现与多个客户端同时通信。 */ public class Server { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;-----服务端启动成功-------\u0026#34;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8080); while (true) { // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); System.out.println(\u0026#34;有人上线了：\u0026#34; + socket.getRemoteSocketAddress()); // 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。 new ServerReaderThread(socket).start(); } } } # 8.2 服务端主程序用线程池改进 每次请求都开一个新线程到底好不好呢？\u0026ndash;高并发时，容易宕机！（内存资源用完了）\n为了避免服务端创建太多的线程，可以把服务端用线程池改进，提高服务端的性能。\n先写一个给浏览器响应数据的线程任务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ServerReaderRunnable implements Runnable{ private Socket socket; public ServerReaderRunnable(Socket socket){ this.socket = socket; } @Override public void run() { // 立即响应一个网页内容：“黑马程序员”给浏览器展示。 try { OutputStream os = socket.getOutputStream(); PrintStream ps = new PrintStream(os); ps.println(\u0026#34;HTTP/1.1 200 OK\u0026#34;); ps.println(\u0026#34;Content-Type:text/html;charset=UTF-8\u0026#34;); ps.println(); // 必须换行 ps.println(\u0026#34;\u0026lt;div style=\u0026#39;color:red;font-size:120px;text-align:center\u0026#39;\u0026gt;黑马程序员666\u0026lt;div\u0026gt;\u0026#34;); ps.close(); socket.close(); } catch (Exception e) { e.printStackTrace(); } } } 再改写服务端的主程序，使用ThreadPoolExecutor创建一个线程池，每次接收到一个Socket就往线程池中提交任务就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Server { public static void main(String[] args) throws Exception { System.out.println(\u0026#34;-----服务端启动成功-------\u0026#34;); // 1、创建ServerSocket的对象，同时为服务端注册端口。 ServerSocket serverSocket = new ServerSocket(8080); // 创建出一个线程池，负责处理通信管道的任务。 ThreadPoolExecutor pool = new ThreadPoolExecutor(16 * 2, 16 * 2, 0, TimeUnit.SECONDS, new ArrayBlockingQueue\u0026lt;\u0026gt;(8) , Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy()); while (true) { // 2、使用serverSocket对象，调用一个accept方法，等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3、把这个客户端对应的socket通信管道，交给一个独立的线程负责处理。 pool.execute(new ServerReaderRunnable(socket)); } } } ","date":"2024-04-24T08:30:57+08:00","permalink":"http://localhost:1313/p/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","title":"Java网络编程"},{"content":" # lambda、方法引用、正则表达式、Arrays # 一、Arrays类 接下来我们学习的类叫做Arrays，其实Arrays并不是重点，但是我们通过Arrays这个类的学习有助于我们理解下一个知识点Lambda的学习。所以我们这里先学习Arrays，再通过Arrays来学习Lamdba这样学习会更丝滑一些^_^.\n# 1.1 Arrays基本使用 我们先认识一下Arrays是干什么用的，Arrays是操作数组的工具类，它可以很方便的对数组中的元素进行遍历、拷贝、排序等操作。\n下面我们用代码来演示一下：遍历、拷贝、排序等操作。需要用到的方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 目标：掌握Arrays类的常用方法。 */ public class ArraysTest1 { public static void main(String[] args) { // 1、public static String toString(类型[] arr): 返回数组的内容 int[] arr = {10, 20, 30, 40, 50, 60}; System.out.println(Arrays.toString(arr)); // 2、public static 类型[] copyOfRange(类型[] arr, 起始索引, 结束索引) ：拷贝数组（指定范围，包前不包后） int[] arr2 = Arrays.copyOfRange(arr, 1, 4); System.out.println(Arrays.toString(arr2)); // 3、public static copyOf(类型[] arr, int newLength)：拷贝数组，可以指定新数组的长度。 int[] arr3 = Arrays.copyOf(arr, 10); System.out.println(Arrays.toString(arr3)); // 4、public static setAll(double[] array, IntToDoubleFunction generator)：把数组中的原数据改为新数据又存进去。 double[] prices = {99.8, 128, 100}; // 0 1 2 // 把所有的价格都打八折，然后又存进去。 Arrays.setAll(prices, new IntToDoubleFunction() { @Override public double applyAsDouble(int value) { // value = 0 1 2 return prices[value] * 0.8; } }); System.out.println(Arrays.toString(prices)); // 5、public static void sort(类型[] arr)：对数组进行排序(默认是升序排序) Arrays.sort(prices); System.out.println(Arrays.toString(prices)); } } # 1.2 Arrays操作对象数组 刚才我们使用Arrays操作数组时，数组中存储存储的元素是int类型、double类型，是可以直接排序的，而且默认是升序排列。\n如果数组中存储的元素类型是自定义的对象，如何排序呢？接下来，我们就学习一下Arrays如何对对象数组进行排序。\n首先我们要准备一个Student类，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Student implements Comparable\u0026lt;Student\u0026gt;{ private String name; private double height; private int age; public Student(String name, double height, int age) { this.name = name; this.height = height; this.age = age; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, height=\u0026#34; + height + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 然后再写一个测试类，往数组中存储4个学生对象，代码如下。此时，运行代码你会发现是会报错的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ArraysTest2 { public static void main(String[] args) { // 目标：掌握如何对数组中的对象进行排序。 Student[] students = new Student[4]; students[0] = new Student(\u0026#34;蜘蛛精\u0026#34;, 169.5, 23); students[1] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[2] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[3] = new Student(\u0026#34;至尊宝\u0026#34;, 167.5, 24); // 1、public static void sort(类型[] arr)：对数组进行排序。 Arrays.sort(students); System.out.println(Arrays.toString(students)); } } 上面的代码为什么会报错呢？因为Arrays根本就不知道按照什么规则进行排序。为了让Arrays知道按照什么规则排序，我们有如下的两种办法。\n**排序方式1：**让Student类实现Comparable接口，同时重写compareTo方法。Arrays的sort方法底层会根据compareTo方法的返回值是正数、负数、还是0来确定谁大、谁小、谁相等。代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class Student implements Comparable\u0026lt;Student\u0026gt;{ private String name; private double height; private int age; //...get、set、空参数构造方法、有参数构造方法...自己补全 // 指定比较规则 // this o @Override public int compareTo(Student o) { // 约定1：认为左边对象 大于 右边对象 请您返回正整数 // 约定2：认为左边对象 小于 右边对象 请您返回负整数 // 约定3：认为左边对象 等于 右边对象 请您一定返回0 /* if(this.age \u0026gt; o.age){ return 1; }else if(this.age \u0026lt; o.age){ return -1; } return 0;*/ //上面的if语句，也可以简化为下面的一行代码 return this.age - o.age; // 按照年龄升序排列 // return o.age - this.age; // 按照年龄降序排列 } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, height=\u0026#34; + height + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } **排序方式2：**在调用Arrays.sort(数组,Comparator比较器);时，除了传递数组之外，传递一个Comparator比较器对象。Arrays的sort方法底层会根据Comparator比较器对象的compare方法方法的返回值是正数、负数、还是0来确定谁大、谁小、谁相等。代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 public class ArraysTest2 { public static void main(String[] args) { // 目标：掌握如何对数组中的对象进行排序。 Student[] students = new Student[4]; students[0] = new Student(\u0026#34;蜘蛛精\u0026#34;, 169.5, 23); students[1] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[2] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[3] = new Student(\u0026#34;至尊宝\u0026#34;, 167.5, 24); // 2、public static \u0026lt;T\u0026gt; void sort(T[] arr, Comparator\u0026lt;? super T\u0026gt; c) // 参数一：需要排序的数组 // 参数二：Comparator比较器对象（用来制定对象的比较规则） Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { // 制定比较规则了：左边对象 o1 右边对象 o2 // 约定1：认为左边对象 大于 右边对象 请您返回正整数 // 约定2：认为左边对象 小于 右边对象 请您返回负整数 // 约定3：认为左边对象 等于 右边对象 请您一定返回0 // if(o1.getHeight() \u0026gt; o2.getHeight()){ // return 1; // }else if(o1.getHeight() \u0026lt; o2.getHeight()){ // return -1; // } // return 0; // 升序 return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 // return Double.compare(o2.getHeight(), o1.getHeight()); // 降序 } }); System.out.println(Arrays.toString(students)); } } # 二、Lambda表达式 接下来，我们学习一个JDK8新增的一种语法形式，叫做Lambda表达式。作用：用于简化匿名内部类代码的书写。\n# 2.1 Lambda表达式基本使用 怎么去简化呢？Lamdba是有特有的格式的，按照下面的格式来编写Lamdba。\n1 2 3 (被重写方法的形参列表) -\u0026gt; { 被重写方法的方法体代码; } 需要给说明一下的是，在使用Lambda表达式之前，必须先有一个接口，而且接口中只能有一个抽象方法。（注意：不能是抽象类，只能是接口）\n像这样的接口，我们称之为函数式接口，只有基于函数式接口的匿名内部类才能被Lambda表达式简化。\n1 2 3 public interface Swimming{ void swim(); } 有了以上的Swimming接口之后，接下来才能再演示，使用Lambda表达式，简化匿名内部类书写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class LambdaTest1 { public static void main(String[] args) { // 目标：认识Lambda表达式. //1.创建一个Swimming接口的匿名内部类对象 Swimming s = new Swimming(){ @Override public void swim() { System.out.println(\u0026#34;学生快乐的游泳~~~~\u0026#34;); } }; s.swim(); //2.使用Lambda表达式对Swimming接口的匿名内部类进行简化 Swimming s1 = () -\u0026gt; { System.out.println(\u0026#34;学生快乐的游泳~~~~\u0026#34;); }; s1.swim(); } } 好的，我们现在已经知道Lamdba表达式可以简化基于函数式接口的匿名内部类的书写。接下来，我们可以把刚才使用Arrays方法时的代码，使用Lambda表达式简化一下了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class LambdaTest2 { public static void main(String[] args) { // 目标：使用Lambda简化函数式接口。 double[] prices = {99.8, 128, 100}; //1.把所有元素*0.8: 先用匿名内部类写法 Arrays.setAll(prices, new IntToDoubleFunction() { @Override public double applyAsDouble(int value) { // value = 0 1 2 return prices[value] * 0.8; } }); //2.把所有元素*0.8: 改用Lamdba表达式写法 Arrays.setAll(prices, (int value) -\u0026gt; { return prices[value] * 0.8; }); System.out.println(Arrays.toString(prices)); System.out.println(\u0026#34;-----------------------------------------------\u0026#34;); Student[] students = new Student[4]; students[0] = new Student(\u0026#34;蜘蛛精\u0026#34;, 169.5, 23); students[1] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[2] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[3] = new Student(\u0026#34;至尊宝\u0026#34;, 167.5, 24); //3.对数组中的元素按照年龄升序排列: 先用匿名内部类写法 Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 } }); //4.对数组中的元素按照年龄升序排列: 改用Lambda写法 Arrays.sort(students, (Student o1, Student o2) -\u0026gt; { return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 }); System.out.println(Arrays.toString(students)); } } 好的，各位同学，恭喜大家！到这里，你已经学会了Lambda表达式的基本使用了。\n# 2.2 Lambda表达式省略规则 刚才我们学习了Lambda表达式的基本使用。Java觉得代码还不够简单，于是还提供了Lamdba表达式的几种简化写法。具体的简化规则如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1.Lambda的标准格式 (参数类型1 参数名1, 参数类型2 参数名2)-\u0026gt;{ ...方法体的代码... return 返回值; } 2.在标准格式的基础上()中的参数类型可以直接省略 (参数名1, 参数名2)-\u0026gt;{ ...方法体的代码... return 返回值; } 3.如果{}总的语句只有一条语句，则{}可以省略、return关键字、以及最后的“;”都可以省略 (参数名1, 参数名2)-\u0026gt; 结果 4.如果()里面只有一个参数，则()可以省略 (参数名)-\u0026gt;结果 接下来从匿名内部类开始、到Lambda标准格式、再到Lambda简化格式，一步一步来简化一下。同学们体会一下简化的过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class LambdaTest2 { public static void main(String[] args) { // 目标：使用Lambda简化函数式接口。 double[] prices = {99.8, 128, 100}; //1.对数组中的每一个元素*0.8: 匿名内部类写法 Arrays.setAll(prices, new IntToDoubleFunction() { @Override public double applyAsDouble(int value) { // value = 0 1 2 return prices[value] * 0.8; } }); //2.需求：对数组中的每一个元素*0.8,使用Lambda表达式标准写法 Arrays.setAll(prices, (int value) -\u0026gt; { return prices[value] * 0.8; }); //3.使用Lambda表达式简化格式1——省略参数类型 Arrays.setAll(prices, (value) -\u0026gt; { return prices[value] * 0.8; }); //4.使用Lambda表达式简化格式2——省略() Arrays.setAll(prices, value -\u0026gt; { return prices[value] * 0.8; }); //5.使用Lambda表达式简化格式3——省略{} Arrays.setAll(prices, value -\u0026gt; prices[value] * 0.8 ); System.out.println(Arrays.toString(prices)); System.out.println(\u0026#34;------------------------------------ Student[] students = new Student[4]; students[0] = new Student(\u0026#34;蜘蛛精\u0026#34;, 169.5, 23); students[1] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[2] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[3] = new Student(\u0026#34;至尊宝\u0026#34;, 167.5, 24); //1.使用匿名内部类 Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 } }); //2.使用Lambda表达式表达式——标准格式 Arrays.sort(students, (Student o1, Student o2) -\u0026gt; { return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 }); //3.使用Lambda表达式表达式——省略参数类型 Arrays.sort(students, ( o1, o2) -\u0026gt; { return Double.compare(o1.getHeight(), o2.getHeight()); // 升序 }); //4.使用Lambda表达式表达式——省略{} Arrays.sort(students, ( o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); System.out.println(Arrays.toString(students)); } } 到这里，恭喜你，对Lamdba表达式的所有写法，就学习完毕了。\n# 三、JDK8新特性（方法引用） 各位小伙伴，接下来我们学习JDK8的另一个新特性，叫做方法引用。我们知道Lambda是用来简化匿名代码的书写格式的，而方法引用是用来进一步简化Lambda表达式的，它简化的更加过分。\n到这里有小伙伴可能就想慰问Java爸爸了：“之前的代码挺好的呀！好不容易学会，你又来搞这些，把我都搞晕了。“ 说句大实话，确实有这样的问题，学习新的东西肯定会增加我们的学习成本，从心理上来说多少是有写抗拒的。但是从另一个角度想，一旦我们学会了，会大大简化我们的代码书写，提高我们编写代码的效率，而且这些新的语法都是有前提条件的，遇到的时候就简化得了。再退一步想，就算你没有学会，还是用以前的办法一点问题也没有。\n给大家交代清楚了，学习方法引用可能存在的一些心理特点之后，接下来我们再正式学习方法引用的代码怎么编写。\n# 3.1 静态方法引用 我们先学习静态方法的引用，还是用之前Arrays代码来做演示。现在准备好下面的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Test1 { public static void main(String[] args) { Student[] students = new Student[4]; students[0] = new Student(\u0026#34;蜘蛛精\u0026#34;, 169.5, 23); students[1] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[2] = new Student(\u0026#34;紫霞\u0026#34;, 163.8, 26); students[3] = new Student(\u0026#34;至尊宝\u0026#34;, 167.5, 24); // 原始写法：对数组中的学生对象，按照年龄升序排序 Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { return o1.getAge() - o2.getAge(); // 按照年龄升序排序 } }); // 使用Lambda简化后的形式 Arrays.sort(students, (o1, o2) -\u0026gt; o1.getAge() - o2.getAge()); } } 现在，我想要把下图中Lambda表达式的方法体，用一个静态方法代替\n准备另外一个类CompareByData类，用于封装Lambda表达式的方法体代码；\n1 2 3 4 5 public class CompareByData { public static int compareByAge(Student o1, Student o2){ return o1.getAge() - o2.getAge(); // 升序排序的规则 } } 现在我们就可以把Lambda表达式的方法体代码，改为下面的样子\n1 Arrays.sort(students, (o1, o2) -\u0026gt; CompareByData.compareByAge(o1, o2)); Java为了简化上面Lambda表达式的写法，利用方法引用可以改进为下面的样子。**实际上就是用类名调用方法，但是把参数给省略了。**这就是静态方法引用\n1 2 //静态方法引用：类名::方法名 Arrays.sort(students, CompareByData::compareByAge); # 3.2 实例方法引用 还是基于上面的案例，我们现在来学习一下实例方法的引用。现在，我想要把下图中Lambda表达式的方法体，用一个实例方法代替。\n在CompareByData类中，再添加一个实例方法，用于封装Lambda表达式的方法体\n接下来，我们把Lambda表达式的方法体，改用对象调用方法\n1 2 CompareByData compare = new CompareByData(); Arrays.sort(students, (o1, o2) -\u0026gt; compare.compareByAgeDesc(o1, o2)); // 降序 最后，再将Lambda表达式的方法体，直接改成方法引用写法。实际上就是用类名调用方法，但是省略的参数。这就是实例方法引用\n1 2 CompareByData compare = new CompareByData(); Arrays.sort(students, compare::compareByAgeDesc); // 降序 给小伙伴的寄语：一定要按照老师写的步骤，一步一步来做，你一定能学会的！！！\n# 3.3 特定类型的方法引用 各位小伙伴，我们继续学习特定类型的方法引用。在学习之前还是需要给大家说明一下，这种特定类型的方法引用是没有什么道理的，只是语法的一种约定，遇到这种场景，就可以这样用。\n1 2 3 4 Java约定： 如果某个Lambda表达式里只是调用一个实例方法，并且前面参数列表中的第一个参数作为方法的主调，\t后面的所有参数都是作为该实例方法的入参时，则就可以使用特定类型的方法引用。 格式： 类型::方法名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Test2 { public static void main(String[] args) { String[] names = {\u0026#34;boby\u0026#34;, \u0026#34;angela\u0026#34;, \u0026#34;Andy\u0026#34; ,\u0026#34;dlei\u0026#34;, \u0026#34;caocao\u0026#34;, \u0026#34;Babo\u0026#34;, \u0026#34;jack\u0026#34;, \u0026#34;Cici\u0026#34;}; // 要求忽略首字符大小写进行排序。 Arrays.sort(names, new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String o1, String o2) { // 制定比较规则。o1 = \u0026#34;Andy\u0026#34; o2 = \u0026#34;angela\u0026#34; return o1.compareToIgnoreCase(o2); } }); //lambda表达式写法 Arrays.sort(names, ( o1, o2) -\u0026gt; o1.compareToIgnoreCase(o2) ); //特定类型的方法引用！ Arrays.sort(names, String::compareToIgnoreCase); System.out.println(Arrays.toString(names)); } } # 3.4 构造器引用（很少见） 各位小伙伴，我们学习最后一种方法引用的形式，叫做构造器引用。还是先说明一下，构造器引用在实际开发中应用的并不多，目前还没有找到构造器的应用场景。所以大家在学习的时候，也只是关注语法就可以了。\n现在，我们准备一个JavaBean类，Car类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Car { private String name; private double price; public Car() { } public Car(String name, double price) { this.name = name; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return \u0026#34;Car{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } 因为方法引用是基于Lamdba表达式简化的，所以也要按照Lamdba表达式的使用前提来用，需要一个函数式接口，接口中代码的返回值类型是Car类型\n1 2 3 interface CreateCar{ Car create(String name, double price); } 最后，再准备一个测试类，在测试类中创建CreateCar接口的实现类对象，先用匿名内部类创建、再用Lambda表达式创建，最后改用方法引用创建。同学们只关注格式就可以，不要去想为什么（语法就是这么设计的）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Test3 { public static void main(String[] args) { // 1、创建这个接口的匿名内部类对象。 CreateCar cc1 = new CreateCar(){ @Override public Car create(String name, double price) { return new Car(name, price); } }; //2、使用匿名内部类改进 CreateCar cc2 = (name, price) -\u0026gt; new Car(name, price); //3、使用方法引用改进：构造器引用 CreateCar cc3 = Car::new; //注意：以上是创建CreateCar接口实现类对象的几种形式而已，语法一步一步简化。 //4、对象调用方法 Car car = cc3.create(\u0026#34;奔驰\u0026#34;, 49.9); System.out.println(car); } } # 四、正则表达式 接下来，我们学习一个全新的知识，叫做正则表达式。正则表达式其实是由一些特殊的符号组成的，它代表的是某种规则。\n正则表达式的作用1：用来校验字符串数据是否合法\n正则表达式的作用2：可以从一段文本中查找满足要求的内容\n# 4.1 正则表达式初体验 现在，我们就以QQ号码为例，来体验一下正则表达式的用法。注意：现在仅仅只是体验而已，我们还没有讲正则表达式的具体写法。\n不使用正则表达式，校验QQ号码代码是这样的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static boolean checkQQ(String qq){ // 1、判断qq号码是否为null if(qq == null || qq.startsWith(\u0026#34;0\u0026#34;) || qq.length() \u0026lt; 6 || qq.length() \u0026gt; 20){ return false; } // 2、qq至少是不是null,不是以0开头的，满足6-20之间的长度。 // 判断qq号码中是否都是数字。 // qq = 2514ghd234 for (int i = 0; i \u0026lt; qq.length(); i++) { // 根据索引提取当前位置处的字符。 char ch = qq.charAt(i); // 判断ch记住的字符，如果不是数字，qq号码不合法。 if(ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;){ return false; } } // 3、说明qq号码肯定是合法 return true; } 用正则表达式代码是这样的 1 2 3 public static boolean checkQQ1(String qq){ return qq != null \u0026amp;\u0026amp; qq.matches(\u0026#34;[1-9]\\\\d{5,19}\u0026#34;); } 我们发现，使用正则表达式，大大简化的了代码的写法。这个代码现在不用写，体验到正则表达式的优势就可以了。\n# 4.2 正则表达式书写规则 前面我们已经体验到了正则表达式，可以简化校验数据的代码书写。这里需要用到一个方法叫matches(String regex)。这个方法时属于String类的方法。\n这个方法是用来匹配一个字符串是否匹配正则表达式的规则，参数需要调用者传递一个正则表达式。但是正则表达式不能乱写，是有特定的规则的。\n下面我们就学习一下，正则表达式的规则。从哪里学呢？在API中有一个类叫做Pattern，我们可以到API文档中搜索，关于正则表达式的规则，这个类都告诉我们了。我这里把常用的已经给大家整理好了。\n我们将这些规则，在代码中演示一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 /** * 目标：掌握正则表达式的书写规则 */ public class RegexTest2 { public static void main(String[] args) { // 1、字符类(只能匹配单个字符) System.out.println(\u0026#34;a\u0026#34;.matches(\u0026#34;[abc]\u0026#34;)); // [abc]只能匹配a、b、c System.out.println(\u0026#34;e\u0026#34;.matches(\u0026#34;[abcd]\u0026#34;)); // false System.out.println(\u0026#34;d\u0026#34;.matches(\u0026#34;[^abc]\u0026#34;)); // [^abc] 不能是abc System.out.println(\u0026#34;a\u0026#34;.matches(\u0026#34;[^abc]\u0026#34;)); // false System.out.println(\u0026#34;b\u0026#34;.matches(\u0026#34;[a-zA-Z]\u0026#34;)); // [a-zA-Z] 只能是a-z A-Z的字符 System.out.println(\u0026#34;2\u0026#34;.matches(\u0026#34;[a-zA-Z]\u0026#34;)); // false System.out.println(\u0026#34;k\u0026#34;.matches(\u0026#34;[a-z\u0026amp;\u0026amp;[^bc]]\u0026#34;)); // ： a到z，除了b和c System.out.println(\u0026#34;b\u0026#34;.matches(\u0026#34;[a-z\u0026amp;\u0026amp;[^bc]]\u0026#34;)); // false System.out.println(\u0026#34;ab\u0026#34;.matches(\u0026#34;[a-zA-Z0-9]\u0026#34;)); // false 注意：以上带 [内容] 的规则都只能用于匹配单个字符 // 2、预定义字符(只能匹配单个字符) . \\d \\D \\s \\S \\w \\W System.out.println(\u0026#34;徐\u0026#34;.matches(\u0026#34;.\u0026#34;)); // .可以匹配任意字符 System.out.println(\u0026#34;徐徐\u0026#34;.matches(\u0026#34;.\u0026#34;)); // false // \\转义 System.out.println(\u0026#34;\\\u0026#34;\u0026#34;); // \\n \\t System.out.println(\u0026#34;3\u0026#34;.matches(\u0026#34;\\\\d\u0026#34;)); // \\d: 0-9 System.out.println(\u0026#34;a\u0026#34;.matches(\u0026#34;\\\\d\u0026#34;)); //false System.out.println(\u0026#34; \u0026#34;.matches(\u0026#34;\\\\s\u0026#34;)); // \\s: 代表一个空白字符 System.out.println(\u0026#34;a\u0026#34;.matches(\u0026#34;\\s\u0026#34;)); // false System.out.println(\u0026#34;a\u0026#34;.matches(\u0026#34;\\\\S\u0026#34;)); // \\S: 代表一个非空白字符 System.out.println(\u0026#34; \u0026#34;.matches(\u0026#34;\\\\S\u0026#34;)); // false System.out.println(\u0026#34;a\u0026#34;.matches(\u0026#34;\\\\w\u0026#34;)); // \\w: [a-zA-Z_0-9] System.out.println(\u0026#34;_\u0026#34;.matches(\u0026#34;\\\\w\u0026#34;)); // true System.out.println(\u0026#34;徐\u0026#34;.matches(\u0026#34;\\\\w\u0026#34;)); // false System.out.println(\u0026#34;徐\u0026#34;.matches(\u0026#34;\\\\W\u0026#34;)); // [^\\w]不能是a-zA-Z_0-9 System.out.println(\u0026#34;a\u0026#34;.matches(\u0026#34;\\\\W\u0026#34;)); // false System.out.println(\u0026#34;23232\u0026#34;.matches(\u0026#34;\\\\d\u0026#34;)); // false 注意：以上预定义字符都只能匹配单个字符。 // 3、数量词： ? * + {n} {n, } {n, m} System.out.println(\u0026#34;a\u0026#34;.matches(\u0026#34;\\\\w?\u0026#34;)); // ? 代表0次或1次 System.out.println(\u0026#34;\u0026#34;.matches(\u0026#34;\\\\w?\u0026#34;)); // true System.out.println(\u0026#34;abc\u0026#34;.matches(\u0026#34;\\\\w?\u0026#34;)); // false System.out.println(\u0026#34;abc12\u0026#34;.matches(\u0026#34;\\\\w*\u0026#34;)); // * 代表0次或多次 System.out.println(\u0026#34;\u0026#34;.matches(\u0026#34;\\\\w*\u0026#34;)); // true System.out.println(\u0026#34;abc12张\u0026#34;.matches(\u0026#34;\\\\w*\u0026#34;)); // false System.out.println(\u0026#34;abc12\u0026#34;.matches(\u0026#34;\\\\w+\u0026#34;)); // + 代表1次或多次 System.out.println(\u0026#34;\u0026#34;.matches(\u0026#34;\\\\w+\u0026#34;)); // false System.out.println(\u0026#34;abc12张\u0026#34;.matches(\u0026#34;\\\\w+\u0026#34;)); // false System.out.println(\u0026#34;a3c\u0026#34;.matches(\u0026#34;\\\\w{3}\u0026#34;)); // {3} 代表要正好是n次 System.out.println(\u0026#34;abcd\u0026#34;.matches(\u0026#34;\\\\w{3}\u0026#34;)); // false System.out.println(\u0026#34;abcd\u0026#34;.matches(\u0026#34;\\\\w{3,}\u0026#34;)); // {3,} 代表是\u0026gt;=3次 System.out.println(\u0026#34;ab\u0026#34;.matches(\u0026#34;\\\\w{3,}\u0026#34;)); // false System.out.println(\u0026#34;abcde徐\u0026#34;.matches(\u0026#34;\\\\w{3,}\u0026#34;)); // false System.out.println(\u0026#34;abc232d\u0026#34;.matches(\u0026#34;\\\\w{3,9}\u0026#34;)); // {3, 9} 代表是 大于等于3次，小于等于9次 // 4、其他几个常用的符号：(?i)忽略大小写 、 或：| 、 分组：() System.out.println(\u0026#34;abc\u0026#34;.matches(\u0026#34;(?i)abc\u0026#34;)); // true System.out.println(\u0026#34;ABC\u0026#34;.matches(\u0026#34;(?i)abc\u0026#34;)); // true System.out.println(\u0026#34;aBc\u0026#34;.matches(\u0026#34;a((?i)b)c\u0026#34;)); // true System.out.println(\u0026#34;ABc\u0026#34;.matches(\u0026#34;a((?i)b)c\u0026#34;)); // false // 需求1：要求要么是3个小写字母，要么是3个数字。 System.out.println(\u0026#34;abc\u0026#34;.matches(\u0026#34;[a-z]{3}|\\\\d{3}\u0026#34;)); // true System.out.println(\u0026#34;ABC\u0026#34;.matches(\u0026#34;[a-z]{3}|\\\\d{3}\u0026#34;)); // false System.out.println(\u0026#34;123\u0026#34;.matches(\u0026#34;[a-z]{3}|\\\\d{3}\u0026#34;)); // true System.out.println(\u0026#34;A12\u0026#34;.matches(\u0026#34;[a-z]{3}|\\\\d{3}\u0026#34;)); // false // 需求2：必须是”我爱“开头，中间可以是至少一个”编程“，最后至少是1个”666“ System.out.println(\u0026#34;我爱编程编程666666\u0026#34;.matches(\u0026#34;我爱(编程)+(666)+\u0026#34;)); System.out.println(\u0026#34;我爱编程编程66666\u0026#34;.matches(\u0026#34;我爱(编程)+(666)+\u0026#34;)); } } # 4.3 正则表达式应用案例 学习完正则表达式的规则之后，接下来我们再利用正则表达式，去校验几个实际案例。\n正则表达式校验手机号码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * 目标：校验用户输入的电话、邮箱、时间是否合法。 */ public class RegexTest3 { public static void main(String[] args) { checkPhone(); } public static void checkPhone(){ while (true) { System.out.println(\u0026#34;请您输入您的电话号码(手机|座机): \u0026#34;); Scanner sc = new Scanner(System.in); String phone = sc.nextLine(); // 18676769999 010-3424242424 0104644535 if(phone.matches(\u0026#34;(1[3-9]\\\\d{9})|(0\\\\d{2,7}-?[1-9]\\\\d{4,19})\u0026#34;)){ System.out.println(\u0026#34;您输入的号码格式正确~~~\u0026#34;); break; }else { System.out.println(\u0026#34;您输入的号码格式不正确~~~\u0026#34;); } } } } 使用正则表达式校验邮箱是否正确 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class RegexTest3 { public static void main(String[] args) { checkEmail(); } public static void checkEmail(){ while (true) { System.out.println(\u0026#34;请您输入您的邮箱： \u0026#34;); Scanner sc = new Scanner(System.in); String email = sc.nextLine(); /** * dlei0009@163.com * 25143242@qq.com * itheima@itcast.com.cn */ if(email.matches(\u0026#34;\\\\w{2,}@\\\\w{2,20}(\\\\.\\\\w{2,10}){1,2}\u0026#34;)){ System.out.println(\u0026#34;您输入的邮箱格式正确~~~\u0026#34;); break; }else { System.out.println(\u0026#34;您输入的邮箱格式不正确~~~\u0026#34;); } } } } # 4.4 正则表达式信息爬取 各位小伙伴，在前面的课程中，我们学习了正则表达式的作用之一，用来校验数据格式的正确性。接下来我们学习正则表达式的第二个作用：在一段文本中查找满足要求的内容\n我们还是通过一个案例给大家做演示：案例需求如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 目标：掌握使用正则表达式查找内容。 */ public class RegexTest4 { public static void main(String[] args) { method1(); } // 需求1：从以下内容中爬取出，手机，邮箱，座机、400电话等信息。 public static void method1(){ String data = \u0026#34; 来黑马程序员学习Java，\\n\u0026#34; + \u0026#34; 电话：1866668888，18699997777\\n\u0026#34; + \u0026#34; 或者联系邮箱：boniu@itcast.cn，\\n\u0026#34; + \u0026#34; 座机电话：01036517895，010-98951256\\n\u0026#34; + \u0026#34; 邮箱：bozai@itcast.cn，\\n\u0026#34; + \u0026#34; 邮箱：dlei0009@163.com，\\n\u0026#34; + \u0026#34; 热线电话：400-618-9090 ，400-618-4000，4006184000，4006189090\u0026#34;; // 1、定义爬取规则 String regex = \u0026#34;(1[3-9]\\\\d{9})|(0\\\\d{2,7}-?[1-9]\\\\d{4,19})|(\\\\w{2,}@\\\\w{2,20}(\\\\.\\\\w{2,10}){1,2})\u0026#34; + \u0026#34;|(400-?\\\\d{3,7}-?\\\\d{3,7})\u0026#34;; // 2、把正则表达式封装成一个Pattern对象 Pattern pattern = Pattern.compile(regex); // 3、通过pattern对象去获取查找内容的匹配器对象。 Matcher matcher = pattern.matcher(data); // 4、定义一个循环开始爬取信息 while (matcher.find()){ String rs = matcher.group(); // 获取到了找到的内容了。 System.out.println(rs); } } } # 4.5 正则表达式搜索、替换 接下来，我们学习一下正则表达式的另外两个功能，替换、分割的功能。需要注意的是这几个功能需要用到Stirng类中的方法。这两个方法其实我们之前学过，只是当时没有学正则表达式而已。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 目标：掌握使用正则表达式做搜索替换，内容分割。 */ public class RegexTest5 { public static void main(String[] args) { // 1、public String replaceAll(String regex , String newStr)：按照正则表达式匹配的内容进行替换 // 需求1：请把下面字符串中的不是汉字的部分替换为 “-” String s1 = \u0026#34;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴\u0026#34;; System.out.println(s1.replaceAll(\u0026#34;\\\\w+\u0026#34;, \u0026#34;-\u0026#34;)); // 需求2(拓展)：某语音系统，收到一个口吃的人说的“我我我喜欢编编编编编编编编编编编编程程程！”，需要优化成“我喜欢编程！”。 String s2 = \u0026#34;我我我喜欢编编编编编编编编编编编编程程程\u0026#34;; System.out.println(s2.replaceAll(\u0026#34;(.)\\\\1+\u0026#34;, \u0026#34;$1\u0026#34;)); // 2、public String[] split(String regex)：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组。 // 需求1：请把下面字符串中的人名取出来，使用切割来做 String s3 = \u0026#34;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴\u0026#34;; String[] names = s3.split(\u0026#34;\\\\w+\u0026#34;); System.out.println(Arrays.toString(names)); } } ","date":"2024-04-23T17:16:27+08:00","permalink":"http://localhost:1313/p/arrayslambda%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"Arrays、lambda、方法引用、正则表达式"},{"content":" # Java面向对象高级3 各位同学，前面两天我们已经把面向对象最主要的内容学习完了，剩下的这些语法知识学完，那么Java语法知识就算全齐活了。\n今天学习的内容同学们学习起来会更轻松一些，有一些语法知识只需要了解一下就可以了，因为实际工作用得并不多。\n我们先来了解第一个语法知识，内部类。\n# 一、内部类 内部类是类中的五大成分之一（成员变量、方法、构造器、内部类、代码块），如果一个类定义在另一个类的内部，这个类就是内部类。\n当一个类的内部，包含一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。\n比如：汽车、的内部有发动机，发动机是包含在汽车内部的一个完整事物，可以把发动机设计成内部类。\n1 2 3 4 5 6 public class Car{ //内部类 public class Engine{ } } 内部类有四种形式，分别是成员内部类、静态内部类、局部内部类、匿名内部类。\n我们先来学习成员内部类\n# 1.1 成员内部类 成员内部类就是类中的一个普通成员，类似于成员变量、成员方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class Outer { private int age = 99; public static String a=\u0026#34;黑马\u0026#34;; // 成员内部类 public class Inner{ private String name; private int age = 88; //在内部类中既可以访问自己类的成员，也可以访问外部类的成员 public void test(){ System.out.println(age); //88 System.out.println(a); //黑马 int age = 77; System.out.println(age); //77 System.out.println(this.age); //88 System.out.println(Outer.this.age); //99 } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } } 成员内部类如何创建对象，格式如下\n1 2 3 4 //外部类.内部类 变量名 = new 外部类().new 内部类(); Outer.Inner in = new Outer().new Inner(); //调用内部类的方法 in.test(); 总结一下内部类访问成员的特点\n既可以访问内部类成员、也可以访问外部类成员 如果内部类成员和外部类成员同名，可以使用**类名.this.成员**区分 # 1.2 静态内部类 静态内部类，其实就是在成员内部类的前面加了一个static关键字。静态内部类属于外部类自己持有。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Outer { private int age = 99; public static String schoolName=\u0026#34;黑马\u0026#34;; // 静态内部类 public static class Inner{ //静态内部类访问外部类的静态变量，是可以的； //静态内部类访问外部类的实例变量，是不行的 public void test(){ System.out.println(schoolName); //99 //System.out.println(age); //报错 } } } 静态内部类创建对象时，需要使用外部类的类名调用。\n1 2 3 //格式：外部类.内部类 变量名 = new 外部类.内部类(); Outer.Inner in = new Outer.Inner(); in.test(); # 1.3 局部内部类 局部内部类是定义在方法中的类，和局部变量一样，只能在方法中有效。所以局部内部类的局限性很强，一般在开发中是不会使用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Outer{ public void test(){ //局部内部类 class Inner{ public void show(){ System.out.println(\u0026#34;Inner...show\u0026#34;); } } //局部内部类只能在方法中创建对象，并使用 Inner in = new Inner(); in.show(); } } # 1.4 匿名内部类 1.4.1 认识匿名内部类，基本使用\n各位同学，接下来学习一种再实际开发中用得最多的一种内部类，叫匿名内部类。相比于前面几种内部类，匿名内部类就比较重要的。\n我们还是先认识一下什么是匿名内部类？\n匿名内部类是一种特殊的局部内部类；所谓匿名，指的是程序员不需要为这个类声明名字。\n下面就是匿名内部类的格式：\n1 2 3 4 new 父类/接口(参数值){ @Override 重写父类/接口的方法; } 匿名内部类本质上是一个没有名字的子类对象、或者接口的实现类对象。\n比如，先定义一个Animal抽象类，里面定义一个cry()方法，表示所有的动物有叫的行为，但是因为动物还不具体，cry()这个行为并不能具体化，所以写成抽象方法。\n1 2 3 public abstract class Animal{ public abstract void cry(); } 接下来，我想要在不定义子类的情况下创建Animal的子类对象，就可以使用匿名内部类\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test{ public static void main(String[] args){ //这里后面new 的部分，其实就是一个Animal的子类对象 //这里隐含的有多态的特性： Animal a = Animal子类对象; Animal a = new Animal(){ @Override public void cry(){ System.out.println(\u0026#34;猫喵喵喵的叫~~~\u0026#34;); } } a.eat(); //直线上面重写的cry()方法 } } 需要注意的是，匿名内部类在编写代码时没有名字，编译后系统会为自动为匿名内部类生产字节码，字节码的名称会以外部类$1.class的方法命名\n匿名内部类的作用：简化了创建子类对象、实现类对象的书写格式。\n1.4.2 匿名内部类的应用场景\n学习完匿名内部类的基本使用之后，我们再来看一下匿名内部类在实际中的应用场景。其实一般我们会主动的使用匿名内部类。\n**只有在调用方法时，当方法的形参是一个接口或者抽象类，为了简化代码书写，而直接传递匿名内部类对象给方法。**这样就可以少写一个类。比如，看下面代码\n1 2 3 public interface Swimming{ public void swim(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Test{ public static void main(String[] args){ Swimming s1 = new Swimming(){ public void swim(){ System.out.println(\u0026#34;狗刨飞快\u0026#34;); } }; go(s1); Swimming s1 = new Swimming(){ public void swim(){ System.out.println(\u0026#34;猴子游泳也还行\u0026#34;); } }; go(s1); } //形参是Swimming接口，实参可以接收任意Swimming接口的实现类对象 public static void go(Swimming s){ System.out.println(\u0026#34;开始~~~~~~~~\u0026#34;); s.swim(); System.out.println(\u0026#34;结束~~~~~~~~\u0026#34;); } } # 二、枚举 # 2.1 认识枚举 2.1.1 认识枚举、枚举的原理\n同学们，接下来我们学习一个新的知识点，枚举。枚举是我们以后在项目开发中偶尔会用到的知识。话不多说，我们还是先来认识一下枚举。\n枚举是一种特殊的类，它的格式是：\n1 2 3 public enum 枚举类名{ 枚举项1,枚举项2,枚举项3; } 其实枚举项就表示枚举类的对象，只是这些对象在定义枚举类时就预先写好了，以后就只能用这几个固定的对象。\n我们用代码演示一下，定义一个枚举类A，在枚举类中定义三个枚举项X, Y, Z\n1 2 3 public enum A{ X,Y,Z; } 想要获取枚举类中的枚举项，只需要用类名调用就可以了\n1 2 3 4 5 6 7 8 public class Test{ public static void main(String[] args){ //获取枚举A类的，枚举项 A a1 = A.X; A a2 = A.Y; A a3 = A.Z; } } 刚才说，枚举项实际上是枚举类的对象，这一点其实可以通过反编译的形式来验证（需要用到反编译的命令，这里不能直接将字节码拖进idea反编译）\n我们会看到，枚举类A是用class定义的，说明枚举确实是一个类，而且X，Y，Z都是A类的对象；而且每一个枚举项都是被public static final 修饰，所以被可以类名调用，而且不能更改。\n2.1.2 枚举深入\n既然枚举是一个类的话，我们能不能在枚举类中定义构造器、成员变量、成员方法呢？答案是可以的。来看一下代码吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public enum A{ //定义枚举项 X,Y,Z(\u0026#34;张三\u0026#34;); //枚举项后面加括号，就是在执行枚举类的带参数构造方法。 //定义空构造器 public A(){ } //成员变量 private String name; //定义带参数构造器 public A(String name){ this.name=name; } //成员方法 public String getName(){ return name; } ... } 虽然枚举类中可以像类一样，写一些类的其他成员，但是一般不会这么写，如果你真要这么干的话，到不如直接写普通类来的直接。\n# 2.2 枚举的应用场景 刚才我们认识了一下什么是枚举，接下来我们看一下枚举在实际中的运用，枚举的应用场景是这样的：枚举一般表示一组信息，然后作为参数进行传输。\n我们来看一个案例。比如我们现在有这么一个应用，用户进入应用时，需要让用户选择是女生、还是男生，然后系统会根据用户选择的是男生，还是女生推荐不同的信息给用户观看。\n这里我们就可以先定义一个枚举类，用来表示男生、或者女生\n1 2 3 public class Constant{ BOY,GRIL } 再定义一个测试类，完成用户进入系统后的选择\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test{ public static void main(String[] args){ //调用方法，传递男生 provideInfo(Constant.BOY); } public static void provideInfo(Constant c){ switch(c){ case BOY: System.out.println(\u0026#34;展示一些信息给男生看\u0026#34;); break; case GRIL: System.out.println(\u0026#34;展示一些信息给女生看\u0026#34;); break; } } } 最终再总结一下枚举的应用场景：枚举一般表示几个固定的值，然后作为参数进行传输。\n# 三、泛型 # 3.1 认识泛型 所谓泛型指的是，在定义类、接口、方法时，同时声明了一个或者多个类型变量（如：），称为泛型类、泛型接口、泛型方法、它们统称为泛型。\n比如我们前面学过的ArrayList类就是一个泛型类，我们可以打开API文档看一下ArrayList类的声明。\nArrayList集合的设计者在定义ArrayList集合时，就已经明确ArrayList集合时给别人装数据用的，但是别人用ArrayList集合时候，装什么类型的数据他不知道，所以就用一个\u0026lt;E\u0026gt;表示元素的数据类型。\n当别人使用ArrayList集合创建对象时，new ArrayList\u0026lt;String\u0026gt; 就表示元素为String类型，new ArrayList\u0026lt;Integer\u0026gt;表示元素为Integer类型。\n我们总结一下泛型的作用、本质：\n泛型的好处：在编译阶段可以避免出现一些非法的数据。\n泛型的本质：把具体的数据类型传递给类型变量。\n# 3.2 自定义泛型类 接下来我们学习一下自定义泛型类，但是有一些话需要给大家提前交代一下：泛型类，在实际工作中一般都是源代码中写好，我们直接用的，就是ArrayList这样的，自己定义泛型类是非常少的。\n自定义泛型类的格式如下\n1 2 3 4 //这里的\u0026lt;T,W\u0026gt;其实指的就是类型变量，可以是一个，也可以是多个。 public class 类名\u0026lt;T,W\u0026gt;{ } 接下来，我们自己定义一个MyArrayList泛型类，模拟一下自定义泛型类的使用。注意这里重点仅仅只是模拟泛型类的使用，所以方法中的一些逻辑是次要的，也不会写得太严谨。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //定义一个泛型类，用来表示一个容器 //容器中存储的数据，它的类型用\u0026lt;E\u0026gt;先代替用着，等调用者来确认\u0026lt;E\u0026gt;的具体类型。 public class MyArrayList\u0026lt;E\u0026gt;{ private Object[] array = new Object[10]; //定一个索引，方便对数组进行操作 private int index; //添加元素 public void add(E e){ array[index]=e; index++; } //获取元素 public E get(int index){ return (E)array[index]; } } 接下来，我们写一个测试类，来测试自定义的泛型类MyArrayList是否能够正常使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Test{ public static void main(String[] args){ //1.确定MyArrayList集合中，元素类型为String类型 MyArrayList\u0026lt;String\u0026gt; list = new MyArrayList\u0026lt;\u0026gt;(); //此时添加元素时，只能添加String类型 list.add(\u0026#34;张三\u0026#34;); list.add(\u0026#34;李四\u0026#34;); //2.确定MyArrayList集合中，元素类型为Integer类型 MyArrayList\u0026lt;Integer\u0026gt; list1 = new MyArrayList\u0026lt;\u0026gt;(); //此时添加元素时，只能添加String类型 list.add(100); list.add(200); } } 关于自定义泛型类，你们把这个案例理解，对于初学者来说，就已经非常好了。\n# 3.3 自定义泛型接口 在上一节中，我们已经学习了自定义泛型类，接下来我们学习一下泛型接口。泛型接口其实指的是在接口中把不确定的数据类型用\u0026lt;类型变量\u0026gt;表示。定义格式如下：\n1 2 3 4 //这里的类型变量，一般是一个字母，比如\u0026lt;E\u0026gt; public interface 接口名\u0026lt;类型变量\u0026gt;{ } 比如，我们现在要做一个系统要处理学生和老师的数据，需要提供2个功能，保存对象数据、根据名称查询数据，要求：这两个功能处理的数据既能是老师对象，也能是学生对象。\n首先我们得有一个学生类和老师类\n1 2 3 public class Teacher{ } 1 2 3 public class Student{ } 我们定义一个Data\u0026lt;T\u0026gt;泛型接口，T表示接口中要处理数据的类型。\n1 2 3 4 5 public interface Data\u0026lt;T\u0026gt;{ public void add(T t); public ArrayList\u0026lt;T\u0026gt; getByName(String name); } 接下来，我们写一个处理Teacher对象的接口实现类\n1 2 3 4 5 6 7 8 9 10 11 //此时确定Data\u0026lt;E\u0026gt;中的E为Teacher类型， //接口中add和getByName方法上的T也都会变成Teacher类型 public class TeacherData implements Data\u0026lt;Teacher\u0026gt;{ public void add(Teacher t){ } public ArrayList\u0026lt;Teacher\u0026gt; getByName(String name){ } } 接下来，我们写一个处理Student对象的接口实现类\n1 2 3 4 5 6 7 8 9 10 11 //此时确定Data\u0026lt;E\u0026gt;中的E为Student类型， //接口中add和getByName方法上的T也都会变成Student类型 public class StudentData implements Data\u0026lt;Student\u0026gt;{ public void add(Student t){ } public ArrayList\u0026lt;Student\u0026gt; getByName(String name){ } } 再啰嗦几句，在实际工作中，一般也都是框架底层源代码把泛型接口写好，我们实现泛型接口就可以了。\n# 3.4 泛型方法 同学们，接下来我们学习一下泛型方法。下面就是泛型方法的格式\n1 2 3 public \u0026lt;泛型变量,泛型变量\u0026gt; 返回值类型 方法名(形参列表){ } 下图中在返回值类型和修饰符之间有定义的才是泛型方法。\n接下我们看一个泛型方法的案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Test{ public static void main(String[] args){ //调用test方法，传递字符串数据，那么test方法的泛型就是String类型 String rs = test(\u0026#34;test\u0026#34;); //调用test方法，传递Dog对象，那么test方法的泛型就是Dog类型 Dog d = test(new Dog()); } //这是一个泛型方法\u0026lt;T\u0026gt;表示一个不确定的数据类型，由调用者确定 public static \u0026lt;T\u0026gt; test(T t){ return t; } } # 3.5 泛型限定 接着，我们来学习一个泛型的特殊用法，叫做泛型限定。泛型限定的意思是对泛型的数据类型进行范围的限制。有如下的三种格式\n\u003c?\u003e 表示任意类型。\"?\"就是通配符，可以在“使用泛型”时表示一切类型；E T K V等是在定义泛型时使用 \u003c? extends 数据类型\u003e 表示指定类型或者指定类型的子类，即泛型上限 \u003c? super 数据类型\u003e 表示指定类型或者指定类型的父类，即泛型下限 下面我们演示一下，假设有Car作为父类，BENZ，BWM两个类作为Car的子类，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Car{} class BENZ extends Car{} class BWN extends Car{} public class Test{ public static void main(String[] args){ //1.集合中的元素不管是什么类型，test1方法都能接收 ArrayList\u0026lt;BWM\u0026gt; list1 = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;Benz\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;String\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(); test1(list1); test1(list2); test1(list3); //2.集合中的元素只能是Car或者Car的子类类型，才能被test2方法接收 ArrayList\u0026lt;Car\u0026gt; list4 = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;BWM\u0026gt; list5 = new ArrayList\u0026lt;\u0026gt;(); test2(list4); test2(list5); //3.集合中的元素只能是Car或者Car的父类类型，才能被test3方法接收 ArrayList\u0026lt;Car\u0026gt; list6 = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;Object\u0026gt; list7 = new ArrayList\u0026lt;\u0026gt;(); test3(list6); test3(list7); } // 等价于 public static \u0026lt;E\u0026gt; void test1(ArrayList\u0026lt;E\u0026gt; list){} public static void test1(ArrayList\u0026lt;?\u0026gt; list){ } // 等价于 public static \u0026lt;E extends Car\u0026gt; void test2(ArrayList\u0026lt;E\u0026gt; list){} public static void test2(ArrayList\u0026lt;? extends Car\u0026gt; list){ } public static void test3(ArrayList\u0026lt;? super Car\u0026gt; list){ } } # 3.6 泛型擦除 最后，关于泛型还有一个特点需要给同学们介绍一下，就是泛型擦除。什么意思呢？也就是说泛型只能编译阶段有效，一旦编译成字节码，字节码中是不包含泛型的。而且泛型只支持引用数据类型，不支持基本数据类型。\n把下面的代码的字节码进行反编译\n下面是反编译之后的代码，我们发现ArrayList后面没有泛型\n# 四、常用API 各位同学，恭喜大家，到目前位置我们关于面向对象的语法知识就全部学习完了。接下来我们就可以拿着这些语法知识，去学习一个一个的API方法，掌握的API方法越多，那么Java的编程能力就越强。\nAPI（Application Programming interface）意思是应用程序编程接口，说人话就是Java帮我们写好的一些程序，如：类、方法等，我们直接拿过来用就可以解决一些问题。\n我们要学习那些API呢？把下面一种图中的所有类的常用方法学会了，那我们JavaSE进阶的课程就算你全学会了。\n很多初学者给我反应的问题是，这些API一听就会，但是就是记住不！送同学们一句话**，**\n“千里之行始于足下，多记、多查、多些代码、孰能生巧！”\n# 4.1 Object类 各位小伙伴，我们要学习的第一个API就是Object类。Object类是Java中所有类的祖宗类，因此，Java中所有类的对象都可以直接使用Object类中提供的一些方法。\n按照下图的提示，可以搜索到你想要找的类\n我们找到Object类的下面两个方法\n4.1.1 toString()方法 我们先来学习toString()方法。\n1 2 3 public String toString() 调用toString()方法可以返回对象的字符串表示形式。 默认的格式是：“包名.类名@哈希值16进制” 假设有一个学生类如下\n1 2 3 4 5 6 7 8 9 public class Student{ private String name; private int age; public Student(String name, int age){ this.name=name; this.age=age; } } 再定义一个测试类\n1 2 3 4 5 6 public class Test{ public static void main(String[] args){ Student s1 = new Student(\u0026#34;赵敏\u0026#34;,23); System.out.println(s1.toString()); } } 打印结果如下\n如果，在Student类重写toString()方法，那么我们可以返回对象的属性值，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Student{ private String name; private int age; public Student(String name, int age){ this.name=name; this.age=age; } @Override public String toString(){ return \u0026#34;Student{name=‘\u0026#34;+name+\u0026#34;’, age=\u0026#34;+age+\u0026#34;}\u0026#34;; } } 运行测试类，结果如下\n4.1.2 equals(Object o)方法\n接下来，我们学习一下Object类的equals方法\n1 2 public boolean equals(Object o) 判断此对象与参数对象是否\u0026#34;相等\u0026#34; 我们写一个测试类，测试一下\n1 2 3 4 5 6 7 8 9 10 11 public class Test{ public static void main(String[] args){ Student s1 = new Student(\u0026#34;赵薇\u0026#34;,23); Student s2 = new Student(\u0026#34;赵薇\u0026#34;,23); //equals本身也是比较对象的地址，和\u0026#34;==\u0026#34;没有区别 System.out.println(s1.equals(s2)); //false //\u0026#34;==\u0026#34;比较对象的地址 System.out.println(s1==s2); //false } } 但是如果我们在Student类中，把equals方法重写了，就按照对象的属性值进行比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Student{ private String name; private int age; public Student(String name, int age){ this.name=name; this.age=age; } @Override public String toString(){ return \u0026#34;Student{name=‘\u0026#34;+name+\u0026#34;’, age=\u0026#34;+age+\u0026#34;}\u0026#34;; } //重写equals方法，按照对象的属性值进行比较 @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } } 再运行测试类，效果如下\n总结一下Object的toString方法和equals方法\n1 2 3 4 5 6 7 public String toString() 返回对象的字符串表示形式。默认的格式是：“包名.类名@哈希值16进制” 【子类重写后，返回对象的属性值】 public boolean equals(Object o) 判断此对象与参数对象是否\u0026#34;相等\u0026#34;。默认比较对象的地址值，和\u0026#34;==\u0026#34;没有区别 【子类重写后，比较对象的属性值】 4.1.3 clone() 方法\n接下来，我们学习Object类的clone()方法，克隆。意思就是某一个对象调用这个方法，这个方法会复制一个一模一样的新对象，并返回。\n1 2 public Object clone() 克隆当前对象，返回一个新对象 想要调用clone()方法，必须让被克隆的类实现Cloneable接口。如我们准备克隆User类的对象，代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class User implements Cloneable{ private String id; //编号 private String username; //用户名 private String password; //密码 private double[] scores; //分数 public User() { } public User(String id, String username, String password, double[] scores) { this.id = id; this.username = username; this.password = password; this.scores = scores; } //...get和set...方法自己加上 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } 接着，我们写一个测试类，克隆User类的对象。并观察打印的结果\n1 2 3 4 5 6 7 8 9 10 11 public class Test { public static void main(String[] args) throws CloneNotSupportedException { User u1 = new User(1,\u0026#34;zhangsan\u0026#34;,\u0026#34;wo666\u0026#34;,new double[]{99.0,99.5}); //调用方法克隆得到一个新对象 User u2 = (User) u1.clone(); System.out.println(u2.getId()); System.out.println(u2.getUsername()); System.out.println(u2.getPassword()); System.out.println(u2.getScores()); } } 我们发现，克隆得到的对象u2它的属性值和原来u1对象的属性值是一样的。\n上面演示的克隆方式，是一种浅克隆的方法，浅克隆的意思：拷贝出来的对象封装的数据与原对象封装的数据一模一样（引用类型拷贝的是地址值）。如下图所示\n还有一种拷贝方式，称之为深拷贝，拷贝原理如下图所示\n下面演示一下深拷贝User对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class User implements Cloneable{ private String id; //编号 private String username; //用户名 private String password; //密码 private double[] scores; //分数 public User() { } public User(String id, String username, String password, double[] scores) { this.id = id; this.username = username; this.password = password; this.scores = scores; } //...get和set...方法自己加上 @Override protected Object clone() throws CloneNotSupportedException { //先克隆得到一个新对象 User u = (User) super.clone(); //再将新对象中的引用类型数据，再次克隆 u.scores = u.scores.clone(); return u; } } # 4.2 Objects类 Objects是一个工具类，提供了一些方法可以对任意对象进行操作。主要方法如下\n下面写代码演示一下这几个方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Test{ public static void main(String[] args){ String s1 = null; String s2 = \u0026#34;itheima\u0026#34;; //这里会出现NullPointerException异常，调用者不能为null System.out.println(s1.equals(s2)); //此时不会有NullPointerException异常，底层会自动先判断空 System.out.println(Objects.equals(s1,s2)); //判断对象是否为null，等价于== System.out.println(Objects.isNull(s1)); //true System.out.println(s1==null); //true //判断对象是否不为null，等价于!= System.out.println(Objects.nonNull(s2)); //true System.out.println(s2!=null); //true } } # 4.3 基本类型包装类 同学们，接下来我们学习一下包装类。为什么要学习包装类呢？因为在Java中有一句很经典的话，万物皆对象。Java中的8种基本数据类型还不是对象，所以要把它们变成对象，变成对象之后，可以提供一些方法对数据进行操作。\nJava中8种基本数据类型都用一个包装类与之对一个，如下图所示\n我们学习包装类，主要学习两点：\n创建包装类的对象方式、自动装箱和拆箱的特性； 利用包装类提供的方法对字符串和基本类型数据进行相互转换 4.2.1 创建包装类对象\n我们先来学习，创建包装类对象的方法，以及包装类的一个特性叫自动装箱和自动拆箱。我们以Integer为例，其他的可以自己学，都是类似的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //1.创建Integer对象，封装基本类型数据10（过时了） Integer a = new Integer(10); //2.使用Integer类的静态方法valueOf(数据) Integer b = Integer.valueOf(10); //3.还有一种自动装箱的写法（意思就是自动将基本类型转换为引用类型） Integer c = 10; //4.有装箱肯定还有拆箱（意思就是自动将引用类型转换为基本类型） int d = c; //5.装箱和拆箱在使用集合时就有体现 ArrayList\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); //添加的元素是基本类型，实际上会自动装箱为Integer类型 list.add(100); //获取元素时，会将Integer类型自动拆箱为int类型 int e = list.get(0); 4.2.2 包装类数据类型转换\n在开发中，经常使用包装类对字符串和基本类型数据进行相互转换。\n把字符串转换为数值型数据： 1）包装类.parseXxx(字符串)\n1 2 public static int parseInt(String s) 把字符串转换为基本数据类型 2）包装类.valueOf(字符串)\n1 2 public static Integer valueOf(String s) 把字符串转换为基本数据类型 将基本数据类型数据转换为字符串： 1）包装类.toString(数据);\n1 2 public static String toString(int a) 把基本类型数据转换为 2）对象.toString()：object类提供的\n1 2 public String toString() 把基本类型数据转换为 3）String.valueOf(数据)：String类提供的\n1 2 public static String valueOf(Object obj) 把基本类型数据转换为 写一个测试类演示一下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //1.字符串数值转换为数值型数据 String ageStr = \u0026#34;29\u0026#34;; int age1 = Integer.parseInt(ageStr);// 不推荐 int age1 = Integer.valueOf(ageStr); String scoreStr = 3.14; double score = Double.prarseDouble(scoreStr); //2.整数转换为字符串，以下几种方式都可以（挑中你喜欢的记一下） Integer a = 23; String s1 = Integer.toString(a); String s2 = a.toString(); String s3 = a+\u0026#34;\u0026#34;; String s4 = String.valueOf(a); ","date":"2024-04-22T23:01:46+08:00","permalink":"http://localhost:1313/p/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A73/","title":"Java面向对象高级3"},{"content":" # Java面向对象高级2 今天我们继续学习面向对象的语法知识，我们今天学习的主要内容是：多态、抽象、接口。\n学会这些语法知识，可以让我们编写代码更灵活，代码的复用性更高。\n# 一、多态 接下来，我们学习面向对象三大特征的的最后一个特征——多态。\n# 1.1 多态概述 什么是多态？\n多态是在继承、实现情况下的一种现象，表现为：对象多态、行为多态。\n比如：Teacher和Student都是People的子类，代码可以写成下面的样子\n# 1.2 多态的好处 各位同学，刚才我们认识了什么是多态。那么多态的写法有什么好处呢？\n在多态形式下，右边的代码是解耦合的，更便于扩展和维护。\n怎么理解这句话呢？比如刚开始p1指向Student对象，run方法执行的就是Student对象的业务；假如p1指向Student对象 ，run方法执行的自然是Student对象的业务。 定义方法时，使用父类类型作为形参，可以接收一切子类对象，扩展行更强，更便利。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Test2 { public static void main(String[] args) { // 目标：掌握使用多态的好处 Teacher t = new Teacher(); go(t); Student s = new Student(); go(s); } //参数People p既可以接收Student对象，也能接收Teacher对象。 public static void go(People p){ System.out.println(\u0026#34;开始------------------------\u0026#34;); p.run(); System.out.println(\u0026#34;结束------------------------\u0026#34;); } } # 1.3 类型转换 虽然多态形式下有一些好处，但是也有一些弊端。在多态形式下，不能调用子类特有的方法，比如在Teacher类中多了一个teach方法，在Student类中多了一个study方法，这两个方法在多态形式下是不能直接调用的。\n多态形式下不能直接调用子类特有方法，但是转型后是可以调用的。这里所说的转型就是把父类变量转换为子类类型。格式如下：\n1 2 3 4 5 //如果p接收的是子类对象 if(父类变量 instance 子类){ //则可以将p转换为子类类型 子类 变量名 = (子类)父类变量; } 如果类型转换错了，就会出现类型转换异常ClassCastException，比如把Teacher类型转换成了Student类型.\n关于多态转型问题，我们最终记住一句话：原本是什么类型，才能还原成什么类型\n# 二、final关键字 各位同学，接下来我们学习一个在面向对象编程中偶尔会用到的一个关键字叫final，也是为后面学习抽象类和接口做准备的。\n# 2.1 final修饰符的特点 我们先来认识一下final的特点，final关键字是最终的意思，可以修饰类、修饰方法、修饰变量。\n1 2 3 - final修饰类：该类称为最终类，特点是不能被继承 - final修饰方法：该方法称之为最终方法，特点是不能被重写。 - final修饰变量：该变量只能被赋值一次。 接下来我们分别演示一下，先看final修饰类的特点 再来演示一下final修饰方法的特点\n再演示一下final修饰变量的特点\n情况一 情况二 情况三 # 2.2 补充知识：常量 刚刚我们学习了final修饰符的特点，在实际运用当中经常使用final来定义常量。先说一下什么是Java中的常量？\n被 static final 修饰的成员变量，称之为常量。 通常用于记录系统的配置信息 接下来我们用代码来演示一下\n1 2 3 4 5 6 public class Constant { //常量: 定义一个常量表示学校名称 //为了方便在其他类中被访问所以一般还会加上public修饰符 //常量命名规范：建议都采用大写字母命名，多个单词之前有_隔开 public static final String SCHOOL_NAME = \u0026#34;传智教育\u0026#34;; } 1 2 3 4 5 6 7 8 9 10 11 12 public class FinalDemo2 { public static void main(String[] args) { //由于常量是static的所以，在使用时直接用类名就可以调用 System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); System.out.println(Constant.SCHOOL_NAME); } } 关于常量的原理，同学们也可以了解一下：在程序编译后，常量会“宏替换”，出现常量的地方，全都会被替换为其记住的字面量。把代码反编译后，其实代码是下面的样子 1 2 3 4 5 6 7 8 9 10 11 public class FinalDemo2 { public static void main(String[] args) { System.out.println(\u0026#34;传智教育\u0026#34;); System.out.println(\u0026#34;传智教育\u0026#34;E); System.out.println(\u0026#34;传智教育\u0026#34;); System.out.println(\u0026#34;传智教育\u0026#34;); System.out.println(\u0026#34;传智教育\u0026#34;); System.out.println(\u0026#34;传智教育\u0026#34;); System.out.println(\u0026#34;传智教育\u0026#34;); } } # 三、抽象 同学们，接下来我们学习Java中一种特殊的类，叫抽象类。为了让同学们掌握抽象类，会先让同学们认识一下什么是抽象类以及抽象类的特点，再学习一个抽象类的常见应用场景。\n# 3.1 认识抽象类 我们先来认识一下什么是抽象类，以及抽象类有什么特点。\n在Java中有一个关键字叫abstract，它就是抽象的意思，它可以修饰类也可以修饰方法。 1 2 - 被abstract修饰的类，就是抽象类 - 被abstract修饰的方法，就是抽象方法（不允许有方法体） 接下来用代码来演示一下抽象类和抽象方法\n1 2 3 4 5 //abstract修饰类，这个类就是抽象类 public abstract class A{ //abstract修饰方法，这个方法就是抽象方法 public abstract void test(); } 类的成员（成员变量、成员方法、构造器），类的成员都可以有。如下面代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 抽象类 public abstract class A { //成员变量 private String name; static String schoolName; //构造方法 public A(){ } //抽象方法 public abstract void test(); //实例方法 public String getName() { return name; } public void setName(String name) { this.name = name; } } 抽象类是不能创建对象的，如果抽象类的对象就会报错 抽象类虽然不能创建对象，但是它可以作为父类让子类继承。而且子类继承父类必须重写父类的所有抽象方法。 1 2 3 4 5 6 7 //B类继承A类，必须复写test方法 public class B extends A { @Override public void test() { } } 子类继承父类如果不复写父类的抽象方法，要想不出错，这个子类也必须是抽象类 1 2 3 4 //B类基础A类，此时B类也是抽象类，这个时候就可以不重写A类的抽象方法 public abstract class B extends A { } # 3.2 抽象类的好处 接下来我们用一个案例来说一下抽象类的应用场景和好处。需求如下图所示\n分析需求发现，该案例中猫和狗都有名字这个属性，也都有叫这个行为，所以我们可以将共性的内容抽取成一个父类，Animal类，但是由于猫和狗叫的声音不一样，于是我们在Animal类中将叫的行为写成抽象的。代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class Animal { private String name; //动物叫的行为：不具体，是抽象的 public abstract void cry(); public String getName() { return name; } public void setName(String name) { this.name = name; } } 接着写一个Animal的子类，Dog类。代码如下\n1 2 3 4 5 public class Dog extends Animal{ public void cry(){ System.out.println(getName() + \u0026#34;汪汪汪的叫~~\u0026#34;); } } 然后，再写一个Animal的子类，Cat类。代码如下\n1 2 3 4 5 public class Cat extends Animal{ public void cry(){ System.out.println(getName() + \u0026#34;喵喵喵的叫~~\u0026#34;); } } 最后，再写一个测试类，Test类。\n1 2 3 4 5 6 7 public class Test2 { public static void main(String[] args) { // 目标：掌握抽象类的使用场景和好处. Animal a = new Dog(); a.cry();\t//这时执行的是Dog类的cry方法 } } 再学一招，假设现在系统有需要加一个Pig类，也有叫的行为，这时候也很容易原有功能扩展。只需要让Pig类继承Animal，复写cry方法就行。\n1 2 3 4 5 6 public class Pig extends Animal{ @Override public void cry() { System.out.println(getName() + \u0026#34;嚯嚯嚯~~~\u0026#34;); } } 此时，创建对象时，让Animal接收Pig，就可以执行Pig的cry方法\n1 2 3 4 5 6 7 public class Test2 { public static void main(String[] args) { // 目标：掌握抽象类的使用场景和好处. Animal a = new Pig(); a.cry();\t//这时执行的是Pig类的cry方法 } } 综上所述，我们总结一下抽象类的使用场景和好处\n1 2 3 1.用抽象类可以把父类中相同的代码，包括方法声明都抽取到父类，这样能更好的支持多态，一提高代码的灵活性。 2.反过来用，我们不知道系统未来具体的业务实现时，我们可以先定义抽象类，将来让子类去实现，以方便系统的扩展。 # 3.3 模板方法模式 学习完抽象类的语法之后，接下来，我们学习一种利用抽象类实现的一种设计模式。先解释下一什么是设计模式？设计模式是解决某一类问题的最优方案。\n设计模式在一些源码中经常会出现，还有以后面试的时候偶尔也会被问到，所以在合适的机会，就会给同学们介绍一下设计模式的知识。\n那模板方法设计模式解决什么问题呢？模板方法模式主要解决方法中存在重复代码的问题\n比如A类和B类都有sing()方法，sing()方法的开头和结尾都是一样的，只是中间一段内容不一样。此时A类和B类的sing()方法中就存在一些相同的代码。\n怎么解决上面的重复代码问题呢？ 我们可以写一个抽象类C类，在C类中写一个doSing()的抽象方法。再写一个sing()方法，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 模板方法设计模式 public abstract class C { // 模板方法 public final void sing(){ System.out.println(\u0026#34;唱一首你喜欢的歌：\u0026#34;); doSing(); System.out.println(\u0026#34;唱完了!\u0026#34;); } public abstract void doSing(); } 然后，写一个A类继承C类，复写doSing()方法，代码如下\n1 2 3 4 5 6 public class A extends C{ @Override public void doSing() { System.out.println(\u0026#34;我是一只小小小小鸟，想要飞就能飞的高~~~\u0026#34;); } } 接着，再写一个B类继承C类，也复写doSing()方法，代码如下\n1 2 3 4 5 6 public class B extends C{ @Override public void doSing() { System.out.println(\u0026#34;我们一起学猫叫，喵喵喵喵喵喵喵~~\u0026#34;); } } 最后，再写一个测试类Test\n1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { // 目标：搞清楚模板方法设计模式能解决什么问题，以及怎么写。 B b = new B(); b.sing(); } } 综上所述：模板方法模式解决了多个子类中有相同代码的问题。具体实现步骤如下\n1 2 3 第1步：定义一个抽象类，把子类中相同的代码写成一个模板方法。 第2步：把模板方法中不能确定的代码写成抽象方法，并在模板方法中调用。 第3步：子类继承抽象类，只需要父类抽象方法就可以了。 # 四、接口 同学们，接下来我们学习一个比抽象类抽象得更加彻底的一种特殊结构，叫做接口。在学习接口是什么之前，有一些事情需要给大家交代一下：Java已经发展了20多年了，在发展的过程中不同JDK版本的接口也有一些变化，所以我们在学习接口时，先以老版本为基础，学习完老版本接口的特性之后，再顺带着了解一些新版本接口的特性就可以了。\n# 4.1 认识接口 我们先来认识一下接口？Java提供了一个关键字interface，用这个关键字来定义接口这种特殊结构。格式如下\n1 2 3 4 public interface 接口名{ //成员变量（常量） //成员方法（抽象方法） } 按照接口的格式，我们定义一个接口看看\n1 2 3 4 5 6 7 public interface A{ //这里public static final可以加，可以不加。 public static final String SCHOOL_NAME = \u0026#34;黑马程序员\u0026#34;; //这里的public abstract可以加，可以不加。 public abstract void test(); } 写好A接口之后，在写一个测试类，用一下\n1 2 3 4 5 6 7 8 9 public class Test{ public static void main(String[] args){ //打印A接口中的常量 System.out.println(A.SCHOOL_NAME); //接口是不能创建对象的 A a = new A(); } } 我们发现定义好接口之后，是不能创建对象的。那接口到底什么使用呢？需要我注意下面两点\n接口是用来被类实现（implements）的，我们称之为实现类。 一个类是可以实现多个接口的（接口可以理解成干爹），类实现接口必须重写所有接口的全部抽象方法，否则这个类也必须是抽象类 比如，再定义一个B接口，里面有两个方法testb1()，testb2()\n1 2 3 4 public interface B { void testb1(); void testb2(); } 接着，再定义一个C接口，里面有两个方法testc1(), testc2()\n1 2 3 4 public interface C { void testc1(); void testc2(); } 然后，再写一个实现类D，同时实现B接口和C接口，此时就需要复写四个方法，如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 实现类 public class D implements B, C{ @Override public void testb1() { } @Override public void testb2() { } @Override public void testc1() { } @Override public void testc2() { } } 最后，定义一个测试类Test\n1 2 3 4 5 6 7 8 9 public class Test { public static void main(String[] args) { // 目标：认识接口。 System.out.println(A.SCHOOL_NAME); // A a = new A(); D d = new D(); } } # 4.2 接口的好处 同学们，刚刚上面我们学习了什么是接口，以及接口的基本特点。那使用接口到底有什么好处呢？主要有下面的两点\n弥补了类单继承的不足，一个类同时可以实现多个接口。 让程序可以面向接口编程，这样程序员可以灵活方便的切换各种业务实现。 我们看一个案例演示，假设有一个Studnet学生类，还有一个Driver司机的接口，还有一个Singer歌手的接口。\n现在要写一个A类，想让他既是学生，偶然也是司机能够开车，偶尔也是歌手能够唱歌。那我们代码就可以这样设计，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Student{ } interface Driver{ void drive(); } interface Singer{ void sing(); } //A类是Student的子类，同时也实现了Dirver接口和Singer接口 class A extends Student implements Driver, Singer{ @Override public void drive() { } @Override public void sing() { } } public class Test { public static void main(String[] args) { //想唱歌的时候，A类对象就表现为Singer类型 Singer s = new A(); s.sing(); //想开车的时候，A类对象就表现为Driver类型 Driver d = new A(); d.drive(); } } 综上所述：接口弥补了单继承的不足，同时可以轻松实现在多种业务场景之间的切换。\n# 4.3 接口的案例 各位同学，关于接口的特点以及接口的好处我们都已经学习完了。接下来我们做一个案例，先来看一下案例需求.\n首先我们写一个学生类，用来描述学生的相关信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class Student { private String name; private char sex; private double score; public Student() { } public Student(String name, char sex, double score) { this.name = name; this.sex = sex; this.score = score; } public String getName() { return name; } public void setName(String name) { this.name = name; } public char getSex() { return sex; } public void setSex(char sex) { this.sex = sex; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } } 接着，写一个StudentOperator接口，表示学生信息管理系统的两个功能。\n1 2 3 4 public interface StudentOperator { void printAllInfo(ArrayList\u0026lt;Student\u0026gt; students); void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students); } 然后，写一个StudentOperator接口的实现类StudentOperatorImpl1，采用第1套方案对业务进行实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class StudentOperatorImpl1 implements StudentOperator{ @Override public void printAllInfo(ArrayList\u0026lt;Student\u0026gt; students) { System.out.println(\u0026#34;----------全班全部学生信息如下--------------\u0026#34;); for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); System.out.println(\u0026#34;姓名：\u0026#34; + s.getName() + \u0026#34;, 性别：\u0026#34; + s.getSex() + \u0026#34;, 成绩：\u0026#34; + s.getScore()); } System.out.println(\u0026#34;-----------------------------------------\u0026#34;); } @Override public void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students) { double allScore = 0.0; for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); allScore += s.getScore(); } System.out.println(\u0026#34;平均分：\u0026#34; + (allScore) / students.size()); } } 接着，再写一个StudentOperator接口的实现类StudentOperatorImpl2，采用第2套方案对业务进行实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class StudentOperatorImpl2 implements StudentOperator{ @Override public void printAllInfo(ArrayList\u0026lt;Student\u0026gt; students) { System.out.println(\u0026#34;----------全班全部学生信息如下--------------\u0026#34;); int count1 = 0; int count2 = 0; for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); System.out.println(\u0026#34;姓名：\u0026#34; + s.getName() + \u0026#34;, 性别：\u0026#34; + s.getSex() + \u0026#34;, 成绩：\u0026#34; + s.getScore()); if(s.getSex() == \u0026#39;男\u0026#39;){ count1++; }else { count2 ++; } } System.out.println(\u0026#34;男生人数是：\u0026#34; + count1 + \u0026#34;, 女士人数是：\u0026#34; + count2); System.out.println(\u0026#34;班级总人数是：\u0026#34; + students.size()); System.out.println(\u0026#34;-----------------------------------------\u0026#34;); } @Override public void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students) { double allScore = 0.0; double max = students.get(0).getScore(); double min = students.get(0).getScore(); for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); if(s.getScore() \u0026gt; max) max = s.getScore(); if(s.getScore() \u0026lt; min) min = s.getScore(); allScore += s.getScore(); } System.out.println(\u0026#34;学生的最高分是：\u0026#34; + max); System.out.println(\u0026#34;学生的最低分是：\u0026#34; + min); System.out.println(\u0026#34;平均分：\u0026#34; + (allScore - max - min) / (students.size() - 2)); } } 再写一个班级管理类ClassManager，在班级管理类中使用StudentOperator的实现类StudentOperatorImpl1对学生进行操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class ClassManager { private ArrayList\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); private StudentOperator studentOperator = new StudentOperatorImpl1(); public ClassManager(){ students.add(new Student(\u0026#34;迪丽热巴\u0026#34;, \u0026#39;女\u0026#39;, 99)); students.add(new Student(\u0026#34;古力娜扎\u0026#34;, \u0026#39;女\u0026#39;, 100)); students.add(new Student(\u0026#34;马尔扎哈\u0026#34;, \u0026#39;男\u0026#39;, 80)); students.add(new Student(\u0026#34;卡尔扎巴\u0026#34;, \u0026#39;男\u0026#39;, 60)); } // 打印全班全部学生的信息 public void printInfo(){ studentOperator.printAllInfo(students); } // 打印全班全部学生的平均分 public void printScore(){ studentOperator.printAverageScore(students); } } 最后，再写一个测试类Test，在测试类中使用ClassMananger完成班级学生信息的管理。\n1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { // 目标：完成班级学生信息管理的案例。 ClassManager clazz = new ClassManager(); clazz.printInfo(); clazz.printScore(); } } 注意：如果想切换班级管理系统的业务功能，随时可以将StudentOperatorImpl1切换为StudentOperatorImpl2。自己试试\n# 4.4 接口JDK8的新特性 各位同学，对于接口最常见的特性我们都学习完了。随着JDK版本的升级，在JDK8版本以后接口中能够定义的成员也做了一些更新，从JDK8开始，接口中新增的三种方法形式。\n我们看一下这三种方法分别有什么特点？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface A { /** * 1、默认方法：必须使用default修饰，默认会被public修饰 * 实例方法：对象的方法，必须使用实现类的对象来访问。 */ default void test1(){ System.out.println(\u0026#34;===默认方法==\u0026#34;); test2(); } /** * 2、私有方法：必须使用private修饰。(JDK 9开始才支持的) * 实例方法：对象的方法。 */ private void test2(){ System.out.println(\u0026#34;===私有方法==\u0026#34;); } /** * 3、静态方法：必须使用static修饰，默认会被public修饰 */ static void test3(){ System.out.println(\u0026#34;==静态方法==\u0026#34;); } void test4(); void test5(); default void test6(){ } } 接下来我们写一个B类，实现A接口。B类作为A接口的实现类，只需要重写抽象方法就尅了，对于默认方法不需要子类重写。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 public class B implements A{ @Override public void test4() { } @Override public void test5() { } } 最后，写一个测试类，观察接口中的三种方法，是如何调用的\n1 2 3 4 5 6 7 8 9 public class Test { public static void main(String[] args) { // 目标：掌握接口新增的三种方法形式 B b = new B(); b.test1();\t//默认方法使用对象调用 // b.test2();\t//A接口中的私有方法，B类调用不了 A.test3();\t//静态方法，使用接口名调用 } } 综上所述：JDK8对接口新增的特性，有利于对程序进行扩展。\n# 4.5 接口的其他细节 最后，给同学们介绍一下使用接口的其他细节，或者说注意事项：\n一个接口可以继承多个接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Test { public static void main(String[] args) { // 目标：理解接口的多继承。 } } interface A{ void test1(); } interface B{ void test2(); } interface C{} //比如：D接口继承C、B、A interface D extends C, B, A{ } //E类在实现D接口时，必须重写D接口、以及其父类中的所有抽象方法。 class E implements D{ @Override public void test1() { } @Override public void test2() { } } 接口除了上面的多继承特点之外，在多实现、继承和实现并存时，有可能出现方法名冲突的问题，需要了解怎么解决（仅仅只是了解一下，实际上工作中几乎不会出现这种情况）\n1 2 3 4 1.一个接口继承多个接口，如果多个接口中存在相同的方法声明，则此时不支持多继承 2.一个类实现多个接口，如果多个接口中存在相同的方法声明，则此时不支持多实现 3.一个类继承了父类，又同时实现了接口，父类中和接口中有同名的默认方法，实现类会有限使用父类的方法 4.一个类实现类多个接口，多个接口中有同名的默认方法，则这个类必须重写该方法。 综上所述：一个接口可以继承多个接口，接口同时也可以被类实现。\n","date":"2024-04-22T22:57:42+08:00","permalink":"http://localhost:1313/p/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A72/","title":"Java面向对象高级2"},{"content":" # Java面向对象高级1 面向对象是写Java程序的核心套路，如何你不懂面向对象，那就相当于Java你白学了。前面我们说过面向对象最核心的套路是：设计对象来处理数据，解决问题。 如果你把面向对象高级这一部分课程学好，你设计出来的对象将更加好用。\n在正式学习面向对象高级课程之前，我给大家提一些学习上的建议。目前我们学习的面向对象高级部分的知识点，就像一个一个的螺丝钉，在学习过程中你可能并不知道这些螺丝钉是用在哪里的，解决的什么问题。必须等这些内容都学习完之后，才能知道用这些螺丝钉可以用来搞飞机、造航母、造火箭。\n所以，现阶段我们在学习过程中，主要关注下面几点就可以了。等整个基础课程学习完之后，再慢慢感在到哪里用。\n# 一、静态 接下来，我们学习一下面向对象编程中很常见的一个关键字static.\nstatic读作静态，可以用来修饰成员变量，也能修饰成员方法。我们先来学习static修饰成员变量。\n# 1.1 static修饰成员变量 Java中的成员变量按照有无static修饰分为两种：类变量、实例变量。它们的区别如下图所示：\n由于静态变量是属于类的，只需要通过类名就可以调用：类名.静态变量\n实例变量是属于对象的，需要通过对象才能调用：对象.实例变量\n下面是代码演示（注意静态变量，和实例变量是如何调用的） 为了让大家对于这两种成员变量的执行过程理解更清楚一点，在这里给大家在啰嗦几句，我们来看一下上面代码的内存原理。\n最后总结一下 1 2 - 1.类变量：属于类，在内存中只有一份，用类名调用 - 2.实例变量：属于对象，每一个对象都有一份，用对象调用 # 1.2 static修饰成员变量的应用场景 学习完static修饰成员变量的基本使用之后，接下来我们学习一下static修饰成员变量在实际工作中的应用。\n在实际开发中，如果某个数据只需要一份，且希望能够被共享（访问、修改），则该数据可以定义成类变量来记住。\n我们看一个案例**\n需求：系统启动后，要求用于类可以记住自己创建了多少个用户对象。**\n第一步：先定义一个User类，在用户类中定义一个static修饰的变量，用来表示在线人数； 1 2 3 4 5 6 7 public class User{ public static int number; //每次创建对象时，number自增一下 public User(){ User.number++; } } 第二步：再写一个测试类，再测试类中创建4个User对象，再打印number的值，观察number的值是否再自增。 1 2 3 4 5 6 7 8 9 10 11 12 public class Test{ public static void main(String[] args){ //创建4个对象 new User(); new User(); new User(); new User(); //查看系统创建了多少个User对象 System.out.println(\u0026#34;系统创建的User对象个数：\u0026#34;+User.number); } } 运行上面的代码，查看执行结果是：系统创建的User对象个数：4\n# 1.3 static修饰成员方法 各位同学，学习完static修饰成员变量之后，接下来我们学习static修饰成员方法。成员方法根据有无static也分为两类：类方法、实例方法\n有static修饰的方法，是属于类的，称为类方法；调用时直接用类名调用即可。\n无static修饰的方法，是属于对象的，称为实例方法；调用时，需要使用对象调用。\n我们看一个案例，演示类方法、实例方法的基本使用\n先定义一个Student类，在类中定义一个类方法、定义一个实例方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Student{ double score; //类方法： public static void printHelloWorld{ System.out.println(\u0026#34;Hello World!\u0026#34;); System.out.println(\u0026#34;Hello World!\u0026#34;); } //实例方法（对象的方法） public void printPass(){ //打印成绩是否合格 System.out.println(score\u0026gt;=60?\u0026#34;成绩合格\u0026#34;:\u0026#34;成绩不合格\u0026#34;); } } 在定义一个测试类，注意类方法、对象方法调用的区别 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test2{ public static void main(String[] args){ //1.调用Student类中的类方法 Student.printHelloWorld(); //2.调用Student类中的实例方法 Student s = new Student(); s.printPass(); //使用对象也能调用类方法【不推荐，IDEA连提示都不给你，你就别这么用了】 s.printHelloWorld(); } } 搞清楚类方法和实例方法如何调用之后，接下来再啰嗦几句，和同学们聊一聊static修饰成员方法的内存原理。\n1 2 3 4 5 1.类方法：static修饰的方法，可以被类名调用，是因为它是随着类的加载而加载的； 所以类名直接就可以找到static修饰的方法 2.实例方法：非static修饰的方法，需要创建对象后才能调用，是因为实例方法中可能会访问实\t例变量，而实例变量需要创建对象后才存在。 所以实例方法，必须创建对象后才能调用。 关于static修饰成员变量、和静态修饰成员方法这两种用法，到这里就学习完了。\n# 1.4 工具类 学习完static修饰方法之后，我们讲一个有关类方法的应用知识，叫做工具类。\n如果一个类中的方法全都是静态的，那么这个类中的方法就全都可以被类名直接调用，由于调用起来非常方便，就像一个工具一下，所以把这样的类就叫做工具类。\n我们写一个生成验证码的工具类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class MyUtils{ public static String createCode(int n){ //1.定义一个字符串，用来记录产生的验证码 String code = \u0026#34;\u0026#34;; //2.验证码是由所有的大写字母、小写字母或者数字字符组成 //这里先把所有的字符写成一个字符串，一会从字符串中随机找字符 String data = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKMNOPQRSTUVWXYZ\u0026#34;; //3.循环n次，产生n个索引,再通过索引获取字符 Random r = new Random(); for(int i=0; i\u0026lt;n; i++){ int index = r.nextInt(data.length()); char ch = data.charAt(index); //4.把获取到的字符，拼接到code验证码字符串上。 code+=ch; } //最后返回code,code的值就是验证码 return code; } } 接着可以在任何位置调用MyUtils的createCOde()方法产生任意个数的验证码 1 2 3 4 5 6 //比如这是一个登录界面 public class LoginDemo{ public static void main(String[] args){ System.out.println(MyUtils.createCode()); } } 1 2 3 4 5 6 //比如这是一个注册界面 public class registerDemo{ public static void main(String[] args){ System.out.println(MyUtils.createCode()); } } 工具类的使用就是这样子的，学会了吗？\n在补充一点，工具类里的方法全都是静态的，推荐用类名调用为了防止使用者用对象调用。我们可以把工具类的构造方法私有化。\n1 2 3 4 5 6 7 8 9 10 11 public class MyUtils{ //私有化构造方法：这样别人就不能使用构造方法new对象了 private MyUtils(){ } //类方法 public static String createCode(int n){ ... } } # 1.5 static的注意事项 各位同学，到现在在我们已经学会了static修饰的变量、方法如何调用了。但是有一些注意事项还是需要给大家说明一下，目的是让大家知道，使用static写代码时，如果出错了，要知道为什么错、如何改正。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Student { static String schoolName; // 类变量 double score; // 实例变量 // 1、类方法中可以直接访问类的成员，不可以直接访问实例成员。 public static void printHelloWorld(){ // 注意：同一个类中，访问类成员，可以省略类名不写。 schoolName = \u0026#34;黑马\u0026#34;; printHelloWorld2(); System.out.println(score); // 报错的 printPass(); // 报错的 ystem.out.println(this); // 报错的 } // 类方法 public static void printHelloWorld2(){ } // 实例方法 public void printPass2(){ } // 实例方法 // 2、实例方法中既可以直接访问类成员，也可以直接访问实例成员。 // 3、实例方法中可以出现this关键字，类方法中不可以出现this关键字的 public void printPass(){ schoolName = \u0026#34;黑马2\u0026#34;; //对的 printHelloWorld2(); //对的 System.out.println(score); //对的 printPass2(); //对的 System.out.println(this); //对的 } } # 1.6 static应用（代码块） 各位同学，接下来我们再补充讲解一个知识点，叫代码块；代码块根据有无static修饰分为两种：静态代码块、实例代码块\n我们先类学习静态代码块：\n1 2 3 4 5 6 7 8 9 public class Student { static int number = 80; static String schoolName = \u0026#34;黑马\u0026#34;; // 静态代码块 static { System.out.println(\u0026#34;静态代码块执行了~~\u0026#34;); schoolName = \u0026#34;黑马\u0026#34;; } } 静态代码块不需要创建对象就能够执行\n1 2 3 4 5 6 7 8 9 10 public class Test { public static void main(String[] args) { // 目标：认识两种代码块，了解他们的特点和基本作用。 System.out.println(Student.number); System.out.println(Student.number); System.out.println(Student.number); System.out.println(Student.schoolName); // 黑马 } } 执行上面代码时，发现没有创建对象，静态代码块就已经执行了。\n关于静态代码块重点注意：静态代码块，随着类的加载而执行，而且只执行一次。\n再来学习一下实例代码块\n实例代码块的作用和构造器的作用是一样的，用来给对象初始化值；而且每次创建对象之前都会先执行实例代码块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Student{ //实例变量 int age; //实例代码块：实例代码块会执行在每一个构造方法之前 { System.out.println(\u0026#34;实例代码块执行了~~\u0026#34;); age = 18; System.out.println(\u0026#34;有人创建了对象：\u0026#34; + this); } public Student(){ System.out.println(\u0026#34;无参数构造器执行了~~\u0026#34;); } public Student(String name){ System.out.println(\u0026#34;有参数构造器执行了~~\u0026#34;); } } 接下来在测试类中进行测试，观察创建对象时，实例代码块是否先执行了。\n1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { Student s1 = new Student(); Student s2 = new Student(\u0026#34;张三\u0026#34;); System.out.println(s1.age); System.out.println(s2.age); } } 对于实例代码块重点注意：实例代码块每次创建对象之前都会执行一次\n# 1.7 static应用（单例设计模式） 各位同学，关于static的应用我们再补充一个使用的技巧，叫做单例设计模式。\n所谓设计模式指的是，一类问题可能会有多种解决方案，而设计模式是在编程实践中，多种方案中的一种最优方案。\n关于静态的使用到这里，我们就学习完了。\n# 二、继承 # 2.1 继承快速入门 各位同学，我们继续学习面向对象相关内容。面向对象编程之所以能够能够被广大开发者认可，有一个非常重要的原因，是因为它有三大特征，继承、封装和多态。封装我们在基础班已经学过了，接下来我们学习一下继承。\n接下来，我们演示一下使用继承来编写代码，注意观察继承的特点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class A{ //公开的成员 public int i; public void print1(){ System.out.println(\u0026#34;===print1===\u0026#34;); } //私有的成员 private int j; private void print2(){ System.out.println(\u0026#34;===print2===\u0026#34;); } } 然后，写一个B类，让B类继承A类。在继承A类的同时，B类中新增一个方法print3\n1 2 3 4 5 6 7 8 9 10 11 public class B extends A{ public void print3(){ //由于i和print1是属于父类A的公有成员，在子类中可以直接被使用 System.out.println(i); //正确 print1(); //正确 //由于j和print2是属于父类A的私有成员，在子类中不可以被使用 System.out.println(j); //错误 print2(); } } 接下来，我们再演示一下，创建B类对象，能否调用父类A的成员。再写一个测试类\n1 2 3 4 5 6 7 8 9 10 11 12 public class Test{ public static void main(String[] args){ B b = new B(); //父类公有成员，子类对象是可以调用的 System.out.println(i); //正确 b.print1(); //父类私有成员，子类对象时不可以调用的 System.out.println(j); //错误 b.print2(); //错误 } } 到这里，关于继承的基本使用我们就算学会了。为了让大家对继承有更深入的认识，我们来看看继承的内存原理。\n这里我们只需要关注一点：子类对象实际上是由子、父类两张设计图共同创建出来的。\n所以，在子类对象的空间中，既有本类的成员，也有父类的成员。但是子类只能调用父类公有的成员。\n# 2.2 继承的好处 各位同学，学习完继承的快速入门之后，接下来我们学习一下继承的好处，以及它的应用场景。\n我们通过一个案例来学习\n观察代码发现，我们会发现Teacher类中和Consultant类中有相同的代码；其实像这种两个类中有相同代码时，没必要重复写。\n我们可以把重复的代码提取出来，作为父类，然后让其他类继承父类就可以了，这样可以提高代码的复用性。改造后的代码如下：\n接下来使用继承来完成上面的案例，这里只演示People类和Teacher类，然后你尝试自己完成Consultant类。\n先写一个父类 People，用来设计Teacher和Consultant公有的成员。 1 2 3 4 5 6 7 8 9 10 public class People{ private String name; public String getName(){ return name; } public void setName(String name){ this.name=name; } } 再写两个子类Teacher继承People类，同时在子类中加上自己特有的成员。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Teacher extends People{ private String skill; //技能 public String getSkill(){ return skill; } public void setSkill(String skill){ this.skill=skill; } public void printInfo(){ System.out.println(getName()+\u0026#34;具备的技能：\u0026#34;+skill); } } 最后再写一个测试类，再测试类中创建Teacher、Consultant对象，并调用方法。 1 2 3 4 5 6 7 8 9 10 11 public class Test { public static void main(String[] args) { // 目标：搞清楚继承的好处。 Teacher t = new Teacher(); t.setName(\u0026#34;播仔\u0026#34;); t.setSkill(\u0026#34;Java、Spring\u0026#34;); System.out.println(t.getName()); System.out.println(t.getSkill()); t.printInfo(); } } 执行代码，打印结果如下：\n关于继承的好处我们只需要记住：继承可以提高代码的复用性\n# 2.3 权限修饰符 各位同学，在刚才使用继承编写的代码中我们有用到两个权限修饰符，一个是public（公有的）、一个是private（私有的），实际上还有两个权限修饰符，一个是protected（受保护的）、一个是缺省的（不写任何修饰符）。\n接下来我们就学习一下这四个权限修饰符分别有什么作用。\n什么是权限修饰符呢？\n权限修饰符是用来限制类的成员（成员变量、成员方法、构造器\u0026hellip;）能够被访问的范围。\n每一种权限修饰符能够被访问的范围如下\n下面我们用代码演示一下，在本类中可以访问到哪些权限修饰的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Fu { // 1、私有:只能在本类中访问 private void privateMethod(){ System.out.println(\u0026#34;==private==\u0026#34;); } // 2、缺省：本类，同一个包下的类 void method(){ System.out.println(\u0026#34;==缺省==\u0026#34;); } // 3、protected: 本类，同一个包下的类，任意包下的子类 protected void protectedMethod(){ System.out.println(\u0026#34;==protected==\u0026#34;); } // 4、public： 本类，同一个包下的类，任意包下的子类，任意包下的任意类 public void publicMethod(){ System.out.println(\u0026#34;==public==\u0026#34;); } public void test(){ //在本类中，所有权限都可以被访问到 privateMethod(); //正确 method(); //正确 protectedMethod(); //正确 publicMethod(); //正确 } } 接下来，在和Fu类同一个包下，创建一个测试类Demo，演示同一个包下可以访问到哪些权限修饰的方法。\n1 2 3 4 5 6 7 8 9 public class Demo { public static void main(String[] args) { Fu f = new Fu(); // f.privateMethod();\t//私有方法无法使用 f.method(); f.protectedMethod(); f.publicMethod(); } } 接下来，在另一个包下创建一个Fu类的子类，演示不同包下的子类中可以访问哪些权限修饰的方法。\n1 2 3 4 5 6 7 8 9 public class Zi extends Fu { //在不同包下的子类中，只能访问到public、protected修饰的方法 public void test(){ // privateMethod(); // 报错 // method(); // 报错 protectedMethod();\t//正确 publicMethod();\t//正确 } } 接下来，在和Fu类不同的包下，创建一个测试类Demo2，演示一下不同包的无关类，能访问到哪些权限修饰的方法；\n1 2 3 4 5 6 7 8 9 10 11 12 public class Demo2 { public static void main(String[] args) { Fu f = new Fu(); // f.privateMethod(); // 报错 // f.method();\t//报错 // f.protecedMethod();//报错 f.publicMethod();\t//正确 Zi zi = new Zi(); // zi.protectedMethod(); } } # 2.4 单继承、Object 刚才我们写的代码中，都是一个子类继承一个父类，那么有同学问到，一个子类可以继承多个父类吗？\nJava语言只支持单继承，不支持多继承，但是可以多层继承。就像家族里儿子、爸爸和爷爷的关系一样：一个儿子只能有一个爸爸，不能有多个爸爸，但是爸爸也是有爸爸的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Test { public static void main(String[] args) { // 目标：掌握继承的两个注意事项事项。 // 1、Java是单继承的：一个类只能继承一个直接父类； // 2、Object类是Java中所有类的祖宗。 A a = new A(); B b = new B(); ArrayList list = new ArrayList(); list.add(\u0026#34;java\u0026#34;); System.out.println(list.toString()); } } class A {} //extends Object{} class B extends A{} // class C extends B , A{} // 报错 class D extends B{} # 2.5 方法重写 各位同学，学习完继承之后，在继承的基础之上还有一个很重要的现象需要给大家说一下。\n叫做方法重写。为了让大家能够掌握方法重写，我们先认识什么是方法重写，再说一下方法的应用场景。\n什么是方法重写\n当子类觉得父类方法不好用，或者无法满足父类需求时，子类可以重写一个方法名称、参数列表一样的方法，去覆盖父类的这个方法，这就是方法重写。\n注意：重写后，方法的访问遵循就近原则。下面我们看一个代码演示\n写一个A类作为父类，定义两个方法print1和print2\n1 2 3 4 5 6 7 8 9 public class A { public void print1(){ System.out.println(\u0026#34;111\u0026#34;); } public void print2(int a, int b){ System.out.println(\u0026#34;111111\u0026#34;); } } 再写一个B类作为A类的子类，重写print1和print2方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class B extends A{ // 方法重写 @Override // 安全，可读性好 public void print1(){ System.out.println(\u0026#34;666\u0026#34;); } // 方法重写 @Override public void print2(int a, int b){ System.out.println(\u0026#34;666666\u0026#34;); } } 接下来，在测试类中创建B类对象，调用方法\n1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { // 目标：认识方法重写，掌握方法重写的常见应用场景。 B b = new B(); b.print1(); b.print2(2, 3); } } 执行代码，我们发现真正执行的是B类中的print1和print2方法\n知道什么是方法重写之后，还有一些注意事项，需要和大家分享一下。\n1 2 3 4 5 - 1.重写的方法上面，可以加一个注解@Override,用于标注这个方法是复写的父类方法 - 2.子类复写父类方法时，访问权限必须大于或者等于父类方法的权限 public \u0026gt; protected \u0026gt; 缺省 - 3. 重写的方法返回值类型，必须与被重写的方法返回值类型一样，或者范围更小 - 4. 私有方法、静态方法不能被重写，如果重写会报错。 关于这些注意事项，同学们其实只需要了解一下就可以了。实际上我们实际写代码时，只要和父类写的一样就可以（ 总结起来就8个字：声明不变，重新实现）\n方法重写的应用场景\n学习完方法重写之后，接下来，我们还需要大家掌握方法重写，在实际中的应用场景。方法重写的应用场景之一就是：子类重写Object的toString()方法，以便返回对象的内容。\n比如：有一个Student类，这个类会默认继承Object类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Student extends Object{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 其实Object类中有一个toString()方法，直接通过Student对象调用Object的toString()方法，会得到对象的地址值。\n1 2 3 4 5 6 7 public class Test { public static void main(String[] args) { Student s = new Student(\u0026#34;播妞\u0026#34;, 19); // System.out.println(s.toString()); System.out.println(s); } } 但是，此时不想调用父类Object的toString()方法，那就可以在Student类中重新写一个toSting()方法，用于返回对象的属性值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package com.itheima.d12_extends_override; public class Student extends Object{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 重新运行测试类，结果如下\n好了，到这里方法什么是方法重写，以及方法重写的应用场景我们就学习完了。\n# 2.6 子类中访问成员的特点 各位同学，刚才我们已经学习了继承，我们发现继承至少涉及到两个类，而每一个类中都可能有各自的成员（成员变量、成员方法），就有可能出现子类和父类有相同成员的情况，那么在子类中访问其他成员有什么特点呢？\n原则：在子类中访问其他成员（成员变量、成员方法），是依据就近原则的 定义一个父类，代码如下\n1 2 3 4 5 6 7 public class F { String name = \u0026#34;父类名字\u0026#34;; public void print1(){ System.out.println(\u0026#34;==父类的print1方法执行==\u0026#34;); } } 再定义一个子类，代码如下。有一个同名的name成员变量，有一个同名的print1成员方法；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Z extends F { String name = \u0026#34;子类名称\u0026#34;; public void showName(){ String name = \u0026#34;局部名称\u0026#34;; System.out.println(name); // 局部名称 } @Override public void print1(){ System.out.println(\u0026#34;==子类的print1方法执行了=\u0026#34;); } public void showMethod(){ print1(); // 子类的 } } 接下来写一个测试类，观察运行结果，我们发现都是调用的子类变量、子类方法。\n1 2 3 4 5 6 7 8 public class Test { public static void main(String[] args) { // 目标：掌握子类中访问其他成员的特点：就近原则。 Z z = new Z(); z.showName(); z.showMethod(); } } 如果子类和父类出现同名变量或者方法，优先使用子类的；此时如果一定要在子类中使用父类的成员，可以加this或者super进行区分。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Z extends F { String name = \u0026#34;子类名称\u0026#34;; public void showName(){ String name = \u0026#34;局部名称\u0026#34;; System.out.println(name); // 局部名称 System.out.println(this.name); // 子类成员变量 System.out.println(super.name); // 父类的成员变量 } @Override public void print1(){ System.out.println(\u0026#34;==子类的print1方法执行了=\u0026#34;); } public void showMethod(){ print1(); // 子类的 super.print1(); // 父类的 } } # 2.7 子类中访问构造器的特点 各位同学，我们知道一个类中可以写成员变量、成员方法，还有构造器。在继承关系下，子类访问成员变量和成员方法的特点我们已经学过了；接下来再学习子类中访问构造器的特点。\n我们先认识子类构造器的语法特点，再讲一下子类构造器的应用场景\n子类中访问构造器的语法规则\n首先，子类全部构造器，都会先调用父类构造器，再执行自己。\n执行顺序，如下图按照① ② ③ 步骤执行：\n子类访问构造器的应用场景\n如果不想使用默认的super()方式调用父类构造器，还可以手动使用super(参数)调用父类有参数构造器。 在本类中访问自己的构造方法\n刚才我们学习了通过super()和super(参数)可以访问父类的构造器。有时候我们也需要访问自己类的构造器。语法如下\n1 2 this(): 调用本类的空参数构造器 this(参数): 调用本类有参数的构造器 最后我们被this和super的用法在总结一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 访问本类成员： this.成员变量\t//访问本类成员变量 this.成员方法\t//调用本类成员方法 this()\t//调用本类空参数构造器 this(参数)\t//调用本类有参数构造器 访问父类成员： super.成员变量\t//访问父类成员变量 super.成员方法\t//调用父类成员方法 super()\t//调用父类空参数构造器 super(参数)\t//调用父类有参数构造器 注意：this和super访问构造方法，只能用到构造方法的第一句，否则会报错。 ","date":"2024-04-17T12:08:04+08:00","permalink":"http://localhost:1313/p/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A71/","title":"Java面向对象高级1"},{"content":" # Java面向对象基础 各位同学，恭喜大家！！！大家学习完前面的课程后，说明Java的基础语法就全掌握了。\n接下来，我们要学习的是Java中最核心的课程——面向对象编程。\n# 一、面向对象入门 各位同学，为什么说面向对象是Java最核心的课程呢？因为写Java程序是有套路的，而面向对象就是写Java程序的套路；你如果不知道面向对象编程，那么你Java语言就算白学了。\n那这种编程套路是咋回事呢？ 接下来，我们通过一个案例快速的认识一下。\n现在假设我们需要处理的是学生的姓名、语文成绩、数学成绩这三个数据，要求打印输出这个学生的总成绩，和平均成绩。\n遇到这样的需求，我们以前都会定义方法来做，如下图所示\n注意：这里每一个方法有三个参数\n定义好方法之后，我们调用方法的时候，需要给每一个方法传递三个实际参数\n在上面案例中，这种编程方式是一种面向过程的编程方式。所谓面向过程，就是编写一个的方法，有数据要进行处理就交给方法来处理。\n但是实际上姓名、语文成绩、数学成绩三个数据可以放在一起，组合成一个对象，然后让对象提供方法对自己的数据进行处理。这种方式称之为面向对象编程。\n总结一些：所谓编写对象编程，就是把要处理的数据交给对象，让对象来处理。\n# 二、深刻认识面向对象 好的各位同学，在上一节课我们已经用面向对象的编程套路，处理了学生数据。接下来我们就要搞清楚，面向对象的几个最核心问题了。\n我们把这三个问题搞明白，那么你对面向对象的理解就很到位。\n# 2.1 面向对象编程有什么好处？ 先来看第一个问题，面向对象编程到底有什么好处呢？ 那就不得不谈，Java的祖师爷对这个世界的理解了。\nJava的祖师爷，詹姆斯高斯林认为，在这个世界中 万物皆对象！任何一个对象都可以包含一些数据，数据属于哪个对象，就由哪个对象来处理。\n这样的话，只要我们找到了对象，其实就找到了对数据的处理方式。\n所以面向对象编程的好处，用一句话总结就是：面向对象的开发更符合人类的思维习惯，让编程变得更加简单、更加直观。\n# 2.2 程序中对象到底是个啥？ 说完面向对象编程有什么好处之后，这里有同学可能会有问题了，你刚才举的例子中，“汽车”、“手机”、“蔡徐坤”是一个实实在在的东西，你说是一个对象好理解。那我们程序中的对象到底是个啥呢？\n对象实质上是一种特殊的数据结构。这种结构怎么理解呢？\n你可以把对象理解成一张表格，表当中记录的数据，就是对象拥有的数据。\n这就是程序中的对象到底是个啥！ 一句话总结，对象其实就是一张数据表，表当中记录什么数据，对象就处理什么数据。\n# 2.3 对象是怎么出来的？ 刚刚我们讲到对象就是一张数据表，那么这个数据表是怎么来的呢？这张表是不会无缘无故存在的，因为Java也不知道你这个对象要处理哪些数据，所以这张表需要我们设计出来。\n用什么来设计这张表呢？就是类（class），类可以理解成对象的设计图，或者对象的模板。\n我们需要按照对象的设计图创造一个对象。设计图中规定有哪些数据，对象中就只能有哪些数据。\n一句话总结：对象可以理解成一张数据表，而数据表中可以有哪些数据，是有类来设计的。\n# 三、对象在计算机中的执行原理 各位同学，前面我们已经带同学写了面向对象的代码，也知道对象到底是咋回事。如果我们再搞清楚对象在计算机中的执行原理，那我们对面向对象的理解就更加专业了。\n按照我们之前讲的数组的执行原理，数组变量记录的其实数数组在堆内存中的地址。其实面向对象的代码执行原理和数组的执行原理是非常类似的。\n其实Student s1 = new Student();这句话中的原理如下\nStudent s1表示的是在栈内存中，创建了一个Student类型的变量，变量名为s1\n而new Student()会在堆内存中创建一个对象，而对象中包含学生的属性名和属性值\n同时系统会为这个Student对象分配一个地址值0x4f3f5b24\n接着把对象的地址赋值给栈内存中的变量s1，通过s1记录的地址就可以找到这个对象\n当执行s1.name=“播妞”时，其实就是通过s1找到对象的地址，再通过对象找到对象的name属性，再给对象的name属性赋值为播妞;\n搞明白Student s1 = new Student();的原理之后，Student s2 = new Student();原理完全一样，只是在堆内存中重新创建了一个对象，又有一个新的地址。s2.name是访问另对象的属性。\n# 四、类和对象的一些注意事项 各位同学，前面几节课我们已经入门了。接下来，关于面向对象有一些细枝末节的东西需要给大家交代一下。\n我把这些注意事项已经列举在下面了，我们把几个不好理解的解释一下就可以了（标记方框），其他的大大家一看就能理解。\n第一条：一个代码文件中，可以写多个class类，但是只能有一个是public修饰，且public修饰的类必须和文件名相同。\n假设文件名为Demo1.java，这个文件中假设有两个类Demo1类和Student类，代码如下\n1 2 3 4 5 6 7 8 //public修饰的类Demo1，和文件名Demo1相同 public class Demo1{ } class Student{ } **第二条：**对象与对象之间的数据不会相互影响，但是多个变量指向同一个对象会相互影响。\n如下图所示，s1和s2两个变量分别记录的是两个对象的地址值，各自修改各自属性值，是互不影响的。\n如下图所示，s1和s2两个变量记录的是同一个对象的地址值，s1修改对象的属性值，再用s2访问这个属性，会发现已经被修改了。\n# 五、this关键字 各位同学，接下来我们学习几个面向对象的小知识点，这里我们先认识一下this关键字是什么含义，再说一下this的应用场景。\nthis是什么呢？\nthis就是一个变量，用在方法中，可以拿到当前类的对象。\n我们看下图所示代码，通过代码来体会这句话到底是什么意思。哪一个对象调用方法方法中的this就是哪一个对象\n上面代码运行结果如下\nthis有什么用呢？\n通过this在方法中可以访问本类对象的成员变量。我们看下图代码，分析打印结果是多少\n分析上面的代码s3.score=325，调用方法printPass方法时，方法中的this.score也是325； 而方法中的参数score接收的是250。执行结果是\n关于this关键字我们就学习到这里，重点记住这句话：哪一个对象调用方法方法中的this就是哪一个对象\n# 六、构造器 好同学们，接下来我们学习一个非常实用的语法知识——叫做构造器。\n关于构造器，我们掌握下面几个问题就可以了：\n什么是构造器？ 掌握构造器的特点？ 构造器的应用场景？ 构造器有哪些注意事项？ 我们一个问题一个问题的来学习，先来学习什么是构造器？\n什么是构造器？\n构造器其实是一种特殊的方法，但是这个方法没有返回值类型，方法名必须和类名相同。\n如下图所示：下面有一个Student类，构造器名称也必须叫Student；也有空参数构造器，也可以有有参数构造器。\n认识了构造器之后，接着我们看一下构造器有什么特点。\n构造器的特点？\n在创建对象时，会调用构造器。\n也就是说 new Student()就是在执行构造器，当构造器执行完了，也就意味着对象创建成功。\n当执行new Student(\u0026quot;播仔\u0026quot;,99)创建对象时，就是在执行有参数构造器，当有参数构造器执行完，就意味着对象创建完毕了。\n关于构造器的特点，我们记住一句话：new 对象就是在执行构造方法\n构造器的应用场景？\n其实构造器就是用来创建对象的。可以在创建对象时给对象的属性做一些初始化操作。如下图所示：\n构造器的注意事项？\n学习完构造器的应用场景之后，接下来我们再看一下构造器有哪些注意事项。\n1 2 1.在设计一个类时，如果不写构造器，Java会自动生成一个无参数构造器。 2.一定定义了有参数构造器，Java就不再提供空参数构造器，此时建议自己加一个无参数构造器。 关于构造器的这几个问题我们再总结一下。掌握这几个问题，构造方法就算完全明白了。\n1 2 3 4 5 6 7 8 9 10 11 12 1.什么是构造器？ 答：构造器其实是一种特殊的方法，但是这个方法没有返回值类型，方法名必须和类名相\t同。 2.构造器什么时候执行？ 答：new 对象就是在执行构造方法； 3.构造方法的应用场景是什么？ 答：在创建对象时，可以用构造方法给成员变量赋值 4.构造方法有哪些注意事项？ 1)在设计一个类时，如果不写构造器，Java会自动生成一个无参数构造器。 2)一定定义了有参数构造器，Java就不再提供空参数构造器，此时建议自己加一个无参数构\t造器。 # 七、封装性 各位同学，接下来我们再学习一个面向对象很重要的特征叫做——封装性。\n1. 什么是封装呢？\n所谓封装，就是用类设计对象处理某一个事物的数据时，应该把要处理的数据，以及处理数据的方法，都设计到一个对象中去。\n比如：在设计学生类时，把学生对象的姓名、语文成绩、数学成绩三个属性，以及求学生总分、平均分的方法，都封装到学生对象中来。\n现在我们已经知道什么是封装了。那我们学习封装，学习个啥呢？ 其实在实际开发中，在用类设计对事处理的数据，以及对数据处理的方法时，是有一些设计规范的。\n封装的设计规范用8个字总结，就是：合理隐藏、合理暴露\n比如，设计一辆汽车时，汽车的发动机、变速箱等一些零件并不需要让每一个开车的知道，所以就把它们隐藏到了汽车的内部。\n把发动机、变速箱等这些零件隐藏起来，这样做其实更加安全，因为并不是所有人都很懂发动机、变速箱，如果暴露在外面很可能会被不懂的人弄坏。\n在设计汽车时，除了隐藏部分零件，但是还是得合理的暴露一些东西出来，让司机能够操纵汽车，让汽车跑起来。比如：点火按钮啊、方向盘啊、刹车啊、油门啊、档把啊\u0026hellip; 这些就是故意暴露出来让司机操纵汽车的。\n好了，到现在我们已经理解什么是封装的一些规范了。就是：合理暴露、合理隐藏\n2. 封装在代码中的体现\n知道什么是封装之后，那封装在代码中如何体现呢？一般我们在设计一个类时，会将成员变量隐藏，然后把操作成员变量的方法对外暴露。\n这里需要用到一个修饰符，叫private，被private修饰的变量或者方法，只能在本类中被访问。\n如下图所示，private double score; 就相当于把score变量封装在了Student对象的内部，且不对外暴露，你想要在其他类中访问score这个变量就，就不能直接访问了；\n如果你想给Student对象的score属性赋值，得调用对外暴露的方法setScore(int score)，在这个方法中可以对调用者传递过来的数据进行一些控制，更加安全。\n当你想获取socre变量的值时，就得调用对外暴露的另一个方法 getScore()\n关于封装我们就学习到这里了。\n# 八、实体JavaBean 接下来，我们学习一个面向对象编程中，经常写的一种类——叫实体JavaBean类。我们先来看什么是实体类？\n1. 什么是实体类？\n实体类就是一种特殊的类，它需要满足下面的要求：\n接下来我们按照要求，写一个Student实体类；\n写完实体类之后，我们看一看它有什么特点？ 其实我们会发现实体类中除了有给对象存、取值的方法就没有提供其他方法了。所以实体类仅仅只是用来封装数据用的。\n知道实体类有什么特点之后，接着我们看一下它有哪些应用场景？\n2. 实体类的应用场景\n在实际开发中，实体类仅仅只用来封装数据，而对数据的处理交给其他类来完成，以实现数据和数据业务处理相分离。如下图所示\n在实际应用中，会将类作为一种数据类型使用。如下图所示，在StudentOperator类中，定义一个Student类型的成员变量student，然后使用构造器给student成员变量赋值。\n然后在Student的printPass()方法中，使用student调用Student对象的方法，对Student对象的数据进行处理。\n到这里，我们已经学习了JavaBean实体类的是什么，以及它的应用场景，我们总结一下\n1 2 3 4 5 6 7 1.JavaBean实体类是什么？有啥特点 JavaBean实体类，是一种特殊的；它需要私有化成员变量，有空参数构造方法、同时提供\tgetXxx和setXxx方法； JavaBean实体类仅仅只用来封装数据，只提供对数据进行存和取的方法 2.JavaBean的应用场景？ JavaBean实体类，只负责封装数据，而把数据处理的操作放在其他类中，以实现数据和数\t据处理相分离。 # 九、面向对象综合案例 学习完面向对象的语法知识之后。接下来，我们做一个面向对象的综合案例——模仿电影信息系统。\n需求如下图所示\n1. 想要展示系统中全部的电影信息（每部电影：编号、名称、价格） 2. 允许用户根据电影的编号（id），查询出某个电影的详细信息。 运行程序时，能够根据用户的选择，执行不同的功能，如下图所示\n按照下面的步骤来完成需求\n# 1. 第一步：定义电影类 首先每一部电影，都包含这部电影的相关信息，比如：电影的编号（id）、电影的名称（name）、电影的价格（price）、电影的分数（score）、电影的导演（director）、电影的主演（actor）、电影的简介（info）。\n为了去描述每一部电影，有哪些信息，我们可以设计一个电影类（Movie），电影类仅仅只是为了封装电影的信息，所以按照JavaBean类的标准写法来写就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 public class Movie { private int id; private String name; private double price; private double score; private String director; private String actor; private String info; public Movie() { } public Movie(int id, String name, double price, double score, String director, String actor, String info) { this.id = id; this.name = name; this.price = price; this.score = score; this.director = director; this.actor = actor; this.info = info; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } public String getDirector() { return director; } public void setDirector(String director) { this.director = director; } public String getActor() { return actor; } public void setActor(String actor) { this.actor = actor; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } # 2. 第二步：定义电影操作类 前面我们定义的Movie类，仅仅只是用来封装每一部电影的信息。为了让电影数据和电影数据的操作相分离，我们还得有一个电影操作类（MovieOperator）。\n因为系统中有多部电影，所以电影操作类中MovieOperator，需要有一个Movie[] movies; 用来存储多部电影对象；\n同时在MovieOperator类中，提供对外提供，对电影数组进行操作的方法。如printAllMovies()用于打印数组中所有的电影信息，searchMovieById(int id)方法根据id查找一个电影的信息并打印。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class MovieOperator { //因为系统中有多部电影，所以电影操作类中，需要有一个Movie的数组 private Movie[] movies; public MovieOperator(Movie[] movies){ this.movies = movies; } /** 1、展示系统全部电影信息 movies = [m1, m2, m3, ...]*/ public void printAllMovies(){ System.out.println(\u0026#34;-----系统全部电影信息如下：-------\u0026#34;); for (int i = 0; i \u0026lt; movies.length; i++) { Movie m = movies[i]; System.out.println(\u0026#34;编号：\u0026#34; + m.getId()); System.out.println(\u0026#34;名称：\u0026#34; + m.getName()); System.out.println(\u0026#34;价格：\u0026#34; + m.getPrice()); System.out.println(\u0026#34;------------------------\u0026#34;); } } /** 2、根据电影的编号查询出该电影的详细信息并展示 */ public void searchMovieById(int id){ for (int i = 0; i \u0026lt; movies.length; i++) { Movie m = movies[i]; if(m.getId() == id){ System.out.println(\u0026#34;该电影详情如下：\u0026#34;); System.out.println(\u0026#34;编号：\u0026#34; + m.getId()); System.out.println(\u0026#34;名称：\u0026#34; + m.getName()); System.out.println(\u0026#34;价格：\u0026#34; + m.getPrice()); System.out.println(\u0026#34;得分：\u0026#34; + m.getScore()); System.out.println(\u0026#34;导演：\u0026#34; + m.getDirector()); System.out.println(\u0026#34;主演：\u0026#34; + m.getActor()); System.out.println(\u0026#34;其他信息：\u0026#34; + m.getInfo()); return; // 已经找到了电影信息，没有必要再执行了 } } System.out.println(\u0026#34;没有该电影信息~\u0026#34;); } } # 3. 第三步：定义测试类 最后，我们需要在测试类中，准备好所有的电影数据，并用一个数组保存起来。每一部电影的数据可以封装成一个对象。然后把对象用数组存起来即可。\n1 2 3 4 5 6 7 8 9 10 11 12 public class Test { public static void main(String[] args) { //创建一个Movie类型的数组 Movie[] movies = new Movie[4]; //创建4个电影对象，分别存储到movies数组中 movies[0] = new Movie(1,\u0026#34;水门桥\u0026#34;, 38.9, 9.8, \u0026#34;徐克\u0026#34;, \u0026#34;吴京\u0026#34;,\u0026#34;12万人想看\u0026#34;); movies[1] = new Movie(2, \u0026#34;出拳吧\u0026#34;, 39, 7.8, \u0026#34;唐晓白\u0026#34;, \u0026#34;田雨\u0026#34;,\u0026#34;3.5万人想看\u0026#34;); movies[2] = new Movie(3,\u0026#34;月球陨落\u0026#34;, 42, 7.9, \u0026#34;罗兰\u0026#34;, \u0026#34;贝瑞\u0026#34;,\u0026#34;17.9万人想看\u0026#34;); movies[3] = new Movie(4,\u0026#34;一点就到家\u0026#34;, 35, 8.7, \u0026#34;许宏宇\u0026#34;, \u0026#34;刘昊然\u0026#34;,\u0026#34;10.8万人想看\u0026#34;); } } 准备好测试数据之后，接下来就需要对电影数据进行操作。我们已经把对电影操作先关的功能写到了MovieOperator类中，所以接下来，创建MovieOperator类对象，调用方法就可以完成相关功能。\n继续再main方法中，接着写下面的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 4、创建一个电影操作类的对象，接收电影数据，并对其进行业务处理 MovieOperator operator = new MovieOperator(movies); Scanner sc = new Scanner(System.in); while (true) { System.out.println(\u0026#34;==电影信息系统==\u0026#34;); System.out.println(\u0026#34;1、查询全部电影信息\u0026#34;); System.out.println(\u0026#34;2、根据id查询某个电影的详细信息展示\u0026#34;); System.out.println(\u0026#34;请您输入操作命令：\u0026#34;); int command = sc.nextInt(); switch (command) { case 1: // 展示全部电影信息 operator.printAllMovies(); break; case 2: // 根据id查询某个电影的详细信息展示 System.out.println(\u0026#34;请您输入查询的电影id:\u0026#34;); int id = sc.nextInt(); operator.searchMovieById(id); break; default: System.out.println(\u0026#34;您输入的命令有问题~~\u0026#34;); } } 到这里，电影信息系统就完成了。 小伙伴们，自己尝试写一下吧！！\n# 十、成员变量和局部变量的区别 各位同学，面向对象的基础内容咱们已经学习完了。同学们在面向对象代码时，经常会把成员变量和局部变量搞混。所以现在我们讲一讲他们的区别。\n如下图所示，成员变量在类中方法外，而局部变量在方法中。\n到这里，我们关于面向对象的基础知识就学习完了。面向对象的核心点就是封装，将数据和数据的处理方式，都封装到对象中； 至于对象要封装哪些数据？对数据进行怎样的处理？ 需要通过类来设计。\n需要注意的是，不同的人，对同一个对象进行设计，对象封装那些数据，提供哪些方法，可能会有所不同；只要能够完成需求，符合设计规范，都是合理的设计。\n","date":"2024-04-16T23:33:19+08:00","permalink":"http://localhost:1313/p/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/","title":"Java面向对象基础"},{"content":" # 工具准备 1、hugo下载安装（下载扩展版）\n1）下载地址 https://github.com/gohugoio/hugo/releases 2）更改系统环境变量（让系统知道你已经下载了）\n在path中添加hugo目录\n3）运行hugo version查看版本，若出现版本号表示成功安装，若不成功，查看加入 path 的路径是否填对。\n2、下载网站主题\n1）下载网址 https://themes.gohugo.io/\n# 网站搭建 1、新建一个文件夹，在文件夹内用cmd命令hugo new site xx在文件夹内创建一个网站 命令行：hugo new site MyBlog 此时的目录结构应该是这样:\n.\n├── archetypes # 内容类型，在创建新内容时自动生成内容的配置\n├── content # 网站内容，Markdown 文件\n├── data\n├── layouts # 网站模版，选择主题后会将主题中的 layouts 文件夹中的内容复制到此文件夹中\n├── static # 包含 CSS、JavaScript、Fonts、media 等，决定网站的外观。选择主题后会将主题中的 ststic 文件夹中的内容复制到此文件夹中\n├── themes # 存放主题文件\n└── config.toml # 网站的配置文件\n2、复制网站主题到MyBlog目录下themes文件夹中\n3、修改网站配置信息（以hugo-theme-stack模板为例）\n删掉默认的配置文件config.toml\n将主题文件中的exampleSite中的config.yaml拷贝到blog根目录中\n将themes/hugo-theme-stack/exampleSite里的content整个文件夹复制到根目录中\n跟据需要修改config.yaml中的内容可以配置各个页面及相应功能：\n1 2 3 4 5 6 7 8 9 baseURL = \u0026#34;https://xiegl6.github.io\u0026#34; # \u0026lt;head\u0026gt; 里面的 baseurl 信息，填你的博客地址 title = \u0026#34;Day Day Up\u0026#34; # 浏览器的标题 languageCode = \u0026#34;zh-cn\u0026#34; # 语言 hasCJKLanguage = true # 开启可以让「字数统计」统计汉字 theme = \u0026#34;hugo-theme-stack\u0026#34; # 主题 (需要自己下载) paginate = 11 # 每页的文章数 enableEmoji = true # 支持 Emoji enableRobotsTXT = true # 支持 robots.txt googleAnalytics = \u0026#34;\u0026#34; # Google 统计 id 4、开始创作\n1）在MyBlog文件夹中用命令行：hugo new post/Hugo搭建静态网页/index.md即可在content/post/Hugo搭建静态网页目录中生成一篇博客 index.md内容为： 其中：\n两条 \u0026mdash; 间的信息是文章的配置信息，有的信息是自动生成的 (如：title、date 等)，简单介绍以下各项配置:\n以下项目是自动生成的:\ntitle: # 文章标题\ndate: # 写作时间\ndraft: # 是否为草稿，如果为 true 需要在命令中加入 \u0026ndash;buildDrafts 参数才会生成这个文档。或者写完后改为 false，则可以通过网址看到这篇博客。\n以下项目需要自行添加:\ndescription: # 描述\ntags: # 标签，用于文章分类\n自动生成 和 执行添加 的内容并不是绝对的，你可以根据自己的喜好配置模板文件 archetypes/default.md\n5、启动网站服务 1）在根目录下使用hugo server命令 2）使用http://localhost:1313/即可访问！\n# 将网站部署在GitHub 1、使用hugo -t=hugo-theme-stack -b=\u0026ldquo;https://xiegl6.github.io/\" \u0026ndash;buildDrafts命令在根目录生成一个public文件夹（public存放静态网页）\n2、在github上建一个名为xiegl6.github.io的仓库（必须是用户名.github.io）\n3、在public目录中用用git初始化本地仓库，然后把public目录下的文件都提交到本地仓库\n1 2 3 git init git add -A git commit -m\u0026#39;提交描述\u0026#39; 4、连接GitHub远程仓库，并将本地仓库文件同步到远程仓库\n1 2 git remote add origin https://github.com/xiegl6/xiegl6.github.io.git git push -u origin master 5、使用https://xiegl6.github.io/即可访问！\n结束！撒花！\n","date":"2024-04-10T22:57:41+08:00","permalink":"http://localhost:1313/p/hugo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5/","title":"Hugo搭建静态网页"},{"content":" # 效果展示 # 标题1 \u0026ndash;记得空格 # 标题2 # 标题3 # 标题4 # 标题5 # 标题6 \u0026ndash;共六级标题 这是一段引用\n引用 哈哈 Written with StackEdit中文版.\n有序列表：符号‘1. ’ 注意空格\n哈哈 看看 水水水水水 无序列表：符号‘- ’ 注意空格\n沙发沙发 十点十分 生复试 任务列表：符号‘- [ ] ’ 注意空格\n吃饭 睡觉 打豆豆 代码块：```c 三个反引号+语言\n1 2 3 int main(){ return 0; } 三个反引号+回车=不沿用上面的格式\n数学公式：使用 \u0026lsquo;$ + latex\u0026rsquo;\n$$ \\frac{\\partial f}{\\partial x}=2\\sqrt{a}x $$\n表格：表头+三种对齐方式（：在哪边就是怎么对齐，至少一个“-”号）\n姓名 年龄 成绩 张三 26 99 李四 25 56 脚注：内容+链接 一健三连1\n横线：符号‘\u0026mdash;’\n链接： 百度\n注意：网址前面要加协议。\n引用链接：网址先用字母表示，然后再解释 谷歌 谷歌，谷歌\n链接到其他位置： 请参考哈哈\n注意：一个#且没有空格\nURL： http://www.baidu.com\n图片：(图片地址 \u0026ldquo;鼠标放图片上显示内容\u0026rdquo;) 行内格式：\n斜体 , 加粗 , 反引号：行内代码 , 下划线，表情 :smile: emoji国际通用代码， 数学公式: $\\theta=x^2$, 下标\u0026quot;~~\u0026quot;，上标\u0026quot;^^\u0026quot; H~2~O, X^2^, ==高亮==\n注：1、可以用html来表示一些markdown不支持的内容！\n2、目录只生成2、3、4级标题！\n# MarkDown基础语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 # 标题1 --记得空格 ## 标题2 ### 标题3 #### 标题4 ##### 标题5 ###### 标题6 --共六级标题 \u0026gt; 这是一段引用 \u0026gt; 引用 哈哈 \u0026gt; Written with [StackEdit中文版](https://stackedit.cn/). 有序列表：符号‘1. ’ 注意空格 1. 哈哈 2. 看看 3. 水水水水水 无序列表：符号‘- ’ 注意空格 - 沙发沙发 - 十点十分 - 生复试 任务列表：符号‘- [ ] ’ 注意空格 - [ ] 吃饭 - [ ] 睡觉 - [x] 打豆豆 代码块：```c 三个反引号+语言 ```c int main(){ return 0; } 三个反引号+回车=不沿用上面的格式 数学公式：使用 \u0026#39;$ + latex\u0026#39; $$ \\frac{\\partial f}{\\partial x}=2\\sqrt{a}x $$ 表格：表头+三种对齐方式（：在哪边就是怎么对齐，至少一个“-”号） |姓名|年龄|成绩| |:--:|--:|:--| |张三|26|99| |李四|25|56| 脚注：内容+链接 一健三连[^三连] [^三连]: 点赞、投币 横线：符号‘---’ --- 链接： [百度](https://www.baidu.com/ \u0026#34;一个搜索引擎\u0026#34;)\u0026lt;br\u0026gt; 注意：网址前面要加协议。\u0026#39;\u0026lt;br\u0026gt;\u0026#39;表示换行 引用链接：网址先用字母表示，然后再解释 [谷歌][sb1] [谷歌][sb1]，[谷歌][sb1] [sb1]: https://google.com \u0026#34;哈哈\u0026#34; 链接到其他位置： 请参考[哈哈](#标题2)\u0026lt;br\u0026gt; 注意：一个#且没有空格 URL： http://www.baidu.com 图片：(图片地址 \u0026#34;鼠标放图片上显示内容\u0026#34;) ![百度](https://www.baidu.com/s?wd=%E7%99%BE%E5%BA%A6%E7%83%AD%E6%90%9C\u0026amp;sa=ire_dl_gh_logo_texing\u0026amp;rsv_dl=igh_logo_pc \u0026#34;百度搜索\u0026#34;) 行内格式： \u0026gt; *斜体* , **加粗** , `反引号：行内代码` , \u0026gt; \u0026lt;u\u0026gt;下划线\u0026lt;/u\u0026gt;，表情 :smile: emoji国际通用代码， \u0026gt; 数学公式: $\\theta=x^2$, 下标\u0026#34;~~\u0026#34;，上标\u0026#34;^^\u0026#34; \u0026gt; H~2~O, X^2^, ==高亮== 注：可以用html来表示一些markdown不支持的内容！ 目录只生成2、3、4级标题！ 点赞、投币\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-04-09T16:22:48+08:00","image":"http://localhost:1313/p/learn_markdown/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/p/learn_markdown/","title":"Learn_markdown"}]